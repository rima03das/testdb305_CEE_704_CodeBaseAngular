import * as i0 from '@angular/core';
import { EventEmitter, Injectable, ComponentFactoryResolver, Inject, ViewContainerRef, Component, Input, HostListener, Pipe, InjectionToken, Directive, Output, NgModule, ViewChild, forwardRef, ApplicationRef, ViewEncapsulation, ElementRef, CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from '@angular/core';
import * as i9 from '@angular/common/http';
import { HttpHeaders, HttpEventType, HttpClientModule } from '@angular/common/http';
import { take, map, takeUntil } from 'rxjs/operators';
import { __decorate } from 'tslib';
import { EntityStore, StoreConfig, QueryEntity, isArray } from '@datorama/akita';
import * as moment from 'moment';
import moment__default from 'moment';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { BehaviorSubject, forkJoin, Observable, defer, Subscription, Subject } from 'rxjs';
import * as i7 from 'ngx-toastr';
import { ToastrModule, provideToastr } from 'ngx-toastr';
import * as i13 from '@angular/common';
import { CommonModule, NgSwitch, getCurrencySymbol, NgClass, NgStyle, NgTemplateOutlet, DatePipe } from '@angular/common';
import * as i14 from '@angular/forms';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import * as i11 from '@angular/router';
import { NavigationEnd, NavigationStart } from '@angular/router';
import * as i12 from '@angular/material/form-field';
import { MatFormFieldModule } from '@angular/material/form-field';
import * as i12$1 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import * as i15 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i5$1 from '@angular/material/tree';
import { MatTreeFlattener, MatTreeNestedDataSource, MatTreeFlatDataSource, MatTreeModule } from '@angular/material/tree';
import * as i7$1 from '@angular/material/dialog';
import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import * as i5 from 'ngx-image-zoom';
import { NgxImageZoomModule } from 'ngx-image-zoom';
import * as i1 from '@angular/platform-browser';
import { BrowserModule, Title } from '@angular/platform-browser';
import moment$1 from 'moment-timezone';
import * as i8 from '@angular/material/snack-bar';
import { MatSnackBarModule, MAT_SNACK_BAR_DATA } from '@angular/material/snack-bar';
import * as CryptoJS from 'crypto-js';
import { MatTooltipModule } from '@angular/material/tooltip';
import { debounce } from 'lodash';
import * as i8$1 from '@ng-idle/core';
import { DEFAULT_INTERRUPTSOURCES } from '@ng-idle/core';
import jQuery from 'jquery';
import { NestedTreeControl, FlatTreeControl } from '@angular/cdk/tree';
import * as i9$1 from '@ng-idle/keepalive';
import { NgIdleKeepaliveModule } from '@ng-idle/keepalive';
import * as i1$1 from 'ngx-socket-io';
import { Socket, SocketIoModule } from 'ngx-socket-io';
import * as XLSX from 'xlsx';
import html2canvas from 'html2canvas';
import html2pdf from 'html2pdf.js';
import jsPDF, { jsPDF as jsPDF$1 } from 'jspdf';
import { Md5 } from 'ts-md5/dist/md5';
import { sha256 } from 'js-sha256';
import { BrowserAnimationsModule, provideAnimations } from '@angular/platform-browser/animations';
import { UiSwitchModule } from 'ngx-ui-switch';
import * as i2 from 'ng2-charts';
import { NgChartsModule, ThemeService, NgChartsConfiguration } from 'ng2-charts';
import { Ng2GoogleChartsModule } from 'ng2-google-charts';
import { MatNativeDateModule } from '@angular/material/core';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatMenuModule } from '@angular/material/menu';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatRadioModule } from '@angular/material/radio';
import { MatSortModule } from '@angular/material/sort';
import { MatTableModule } from '@angular/material/table';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatTabsModule } from '@angular/material/tabs';
import { MatButtonModule } from '@angular/material/button';
import { MatSelectModule } from '@angular/material/select';
import { NgbModule, NgbTimepickerModule } from '@ng-bootstrap/ng-bootstrap';
import { MatChipsModule } from '@angular/material/chips';
import * as i8$2 from '@angular/material/progress-bar';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { NgxMaterialTimepickerModule } from 'ngx-material-timepicker';
import * as i4 from 'angular-oauth2-oidc';
import { OAuthModule } from 'angular-oauth2-oidc';
import { WebcamModule } from 'ngx-webcam';
import { NgxBarcodeScannerModule, NgxBarcodeScannerService } from '@eisberg-labs/ngx-barcode-scanner';
import { CdkMenuModule } from '@angular/cdk/menu';
import { NgxMatTimepickerModule, NgxMatNativeDateModule, NgxMatDatetimePickerModule } from '@angular-material-components/datetime-picker';
import { YouTubePlayerModule } from '@angular/youtube-player';
import { GoogleMapsModule } from '@angular/google-maps';
import * as i6 from 'ngx-daterangepicker-bootstrap';
import { NgxDaterangepickerBootstrapModule, NgxDaterangepickerLocaleService } from 'ngx-daterangepicker-bootstrap';
import { ImageCropperComponent } from 'ngx-image-cropper';
import * as i7$2 from 'ngx-quill';
import { QuillModule } from 'ngx-quill';

class SharedEventsServiceService {
    modelEmitter = new EventEmitter();
    eventHandlerEmitter = new EventEmitter();
    apiIntegrationEventHandlerEmitter = new EventEmitter();
    apiIntegrationParallelEventHandlerEmitter = new EventEmitter();
    apiConfigTokenEmitter = new EventEmitter();
    oidcDataEmitter = new EventEmitter();
    oidcCheckLoginStatusEmitter = new EventEmitter();
    oidcEventEmitter = new EventEmitter();
    oidcApiEmitter = new EventEmitter();
    apiUnauthorizedEmitter = new EventEmitter();
    repeatableBlockSessionClearanceEmitter = new EventEmitter();
    associatedRepeatableBlockSessionClearanceEmitter = new EventEmitter();
    accordionStateEmitter = new EventEmitter();
    customEventVariableEmitter = new EventEmitter();
    customEventTargetSubscriber = new EventEmitter();
    eventResponseSubscriber = new EventEmitter();
    emitApiSuccessResponse = new EventEmitter();
    emitApiErrorResponse = new EventEmitter();
    emitOnDataSetOrUpdated = new EventEmitter();
    emitOnDataSetOrUpdatedForSection = new EventEmitter();
    emitOnDataSetOrUpdatedForBlock = new EventEmitter();
    emitOnDataSetOrUpdatedForGenericBlock = new EventEmitter();
    showMandatoryErrorMsg = new EventEmitter();
    showValidationErrorMsg = new EventEmitter();
    emitForEmptySession = new EventEmitter();
    mapMarkerEmitter = new EventEmitter();
    mapCenterEmitter = new EventEmitter();
    mapLayerEmitter = new EventEmitter();
    searchFilterEmitter = new EventEmitter();
    toggleAccordionEmitter = new EventEmitter();
    emitKeyDown = new EventEmitter();
    emitSetFieldValueOnEvent = new EventEmitter();
    settingFieldValueEventFinished = new EventEmitter();
    stateHistoryEmitter = new EventEmitter();
    buttonValidationEmitter = new EventEmitter();
    validateButtonForTagEmitter = new EventEmitter();
    emitFieldStateChangeEventEmitter = new EventEmitter();
    customSectionLoaderEmitter = new EventEmitter();
    stepLoaderEmitter = new EventEmitter();
    exitWorkflowSameStepRedirectEmmiter = new EventEmitter();
    uploadEmitter = new EventEmitter();
    removeFileEmitter = new EventEmitter();
    hamburgermenuEmitter = new EventEmitter();
    startTickerEmitter = new EventEmitter();
    stopTickerEmitter = new EventEmitter();
    pauseTickerEmitter = new EventEmitter();
    httpProgressEmitter = new EventEmitter();
    contextMenuEmitter = new EventEmitter();
    eventConditionalFailureSubscriber = new EventEmitter();
    emitOnApplyRearrangeBtnClicked = new EventEmitter();
    emitOnTableInlineEditClicked = new EventEmitter();
    emitOnTableInlineEditCancelClicked = new EventEmitter();
    eventDeleteRepeatedBlockSubscriber = new EventEmitter();
    emitOnEditableStatusChanged = new EventEmitter();
    emitOnApplyFilter = new EventEmitter();
    targetStepRedirection = new EventEmitter();
    emitOnAddOrRemoveRB = new EventEmitter();
    closeDrawerOnClickExternalUrl = new EventEmitter();
    emitToreactEmitter = new EventEmitter();
    rbCurrentIndex = new EventEmitter();
    generatePdfUsingShadowDom = new EventEmitter();
    printUploadUsingShadowDom = new EventEmitter();
    tableCellDataSet = new EventEmitter();
    sideMenuSelectionResetEmitter = new EventEmitter();
    params = {};
    constructor() { }
    static ɵfac = function SharedEventsServiceService_Factory(t) { return new (t || SharedEventsServiceService)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: SharedEventsServiceService, factory: SharedEventsServiceService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SharedEventsServiceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [], null); })();

class UserDataHandlerService {
    sharedEventsService;
    constructor(sharedEventsService) {
        this.sharedEventsService = sharedEventsService;
    }
    mandatoryData = [];
    setOrUpdateFieldData(apiKey, value) {
        window.sessionStorage.setItem(apiKey, value);
        // this.sharedEventsService.emitOnDataSetOrUpdated.emit({apiKey, value});
    }
    getFieldData(apiKey) {
        if (window.sessionStorage.getItem(apiKey)) {
            return window.sessionStorage.getItem(apiKey);
        }
        else {
            return '';
        }
    }
    removeSessionValues(apiKeys) {
        for (const key of apiKeys) {
            window.sessionStorage.removeItem(key);
        }
    }
    removeSessionValue(apiKey) {
        window.sessionStorage.removeItem(apiKey);
    }
    clearSessionValue() {
        window.sessionStorage.clear();
    }
    static ɵfac = function UserDataHandlerService_Factory(t) { return new (t || UserDataHandlerService)(i0.ɵɵinject(SharedEventsServiceService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: UserDataHandlerService, factory: UserDataHandlerService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(UserDataHandlerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: SharedEventsServiceService }], null); })();

class BearerTokenServiceService {
    storageService;
    tokenObj = {};
    constructor(storageService) {
        this.storageService = storageService;
    }
    intercept(request, next) {
        this.tokenObj['bearerToken'] = this.storageService.getFieldData('access_token'.toLowerCase());
        request = request.clone({
            setHeaders: {
                Authorization: "Bearer " + this.tokenObj['bearerToken']
            }
        });
        return next.handle(request);
    }
    static ɵfac = function BearerTokenServiceService_Factory(t) { return new (t || BearerTokenServiceService)(i0.ɵɵinject(UserDataHandlerService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: BearerTokenServiceService, factory: BearerTokenServiceService.ɵfac });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(BearerTokenServiceService, [{
        type: Injectable
    }], () => [{ type: UserDataHandlerService }], null); })();

class CeeInitServiceService {
    http;
    appConfigData;
    customErrors;
    apiConfigData;
    constructor(http) {
        this.http = http;
    }
    async initConfigurationJSON() {
        if (!this.getAppConfigData) {
            const appConfigData = await this.http.get('assets/jsons/app_config.json?hash=' + Date.now()).toPromise();
            for (const singleRes of Object.keys(appConfigData)) {
                if (singleRes === 'API_TYPE') {
                    if ((appConfigData[singleRes] === 'INTERNAL' || appConfigData[singleRes] === 'EXTERNAL') && !this.getApiConfigData) {
                        window.localStorage.setItem('hash_api_key', 'true');
                        const apiConfig = await this.http.get('assets/jsons/api_config.json').toPromise();
                        let apiConfigData = {};
                        (apiConfig.config || []).forEach((obj) => apiConfigData = { ...apiConfigData, ...{ [obj['id']]: obj } });
                        // try {
                        //     //marge API JOIN data
                        //     const apiJoin: any = await this.http.get('assets/jsons/api_join.json').toPromise();
                        //     // let apiJoinData = {};
                        //     (apiJoin.config || []).forEach((obj) => {
                        //         if (apiConfigData[obj['id']]) {
                        //             apiConfigData[obj['id']] = { ...apiConfigData[obj['id']], ...obj }
                        //         }
                        //     });
                        // } catch (error) {
                        // }
                        // locally caching the api config data
                        this.setApiConfigData = apiConfigData;
                        window.localStorage.setItem('API_CONFIG', JSON.stringify(apiConfigData));
                    }
                    else {
                        window.localStorage.removeItem('hash_api_key');
                        window.localStorage.removeItem('API_CONFIG');
                    }
                }
                if (singleRes === 'customErrorSteps' && !this.customErrors) {
                    this.customErrors = await this.http.get('assets/jsons/custom_errors_config.json').toPromise();
                }
                window.localStorage.setItem(singleRes, typeof (appConfigData[singleRes]) === 'string' ?
                    appConfigData[singleRes] :
                    JSON.stringify(appConfigData[singleRes]));
            }
            // caching the app config data
            this.setAppConfigData = appConfigData;
        }
        return this.getAppConfigData;
    }
    get getApiConfigData() {
        return this.apiConfigData;
    }
    set setApiConfigData(data) {
        this.apiConfigData = data;
    }
    get getAppConfigData() {
        return this.appConfigData;
    }
    set setAppConfigData(data) {
        this.appConfigData = data;
    }
    static ɵfac = function CeeInitServiceService_Factory(t) { return new (t || CeeInitServiceService)(i0.ɵɵinject(i9.HttpClient)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CeeInitServiceService, factory: CeeInitServiceService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CeeInitServiceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: i9.HttpClient }], null); })();

class Log {
    platform;
    applicationName;
    message;
    constructor(platform = '', applicationName = '', message = []) {
        this.platform = platform;
        this.applicationName = applicationName;
        this.message = message;
    }
}

class CeeLogHandlerService {
    httpClient;
    ceeInitService;
    // [DateTime] [App ID]  [Platform]  [Log Type] [Module Name] [Version]  [Tag] [Data]
    baseURL = '';
    token = '';
    applicationId = '';
    platform = 'web';
    applicationName = 'wfeAngular8';
    logData = [];
    environment = { version: 1.0 };
    constructor(httpClient, ceeInitService) {
        this.httpClient = httpClient;
        this.ceeInitService = ceeInitService;
        this.ceeInitService.initConfigurationJSON().then(res => {
            const data = JSON.parse(JSON.stringify(res));
            this.baseURL = data.logBaseURL;
            this.token = data.logToken;
            this.applicationId = data.applicationId;
        });
    }
    e(tag, data) {
        const logData = '[' + new Date() + '] [' + this.applicationId + '] [Angular] [ERROR] [CEE Core Library] ['
            + this.environment.version + '] [' + tag + '] [' + data + ']';
        this.uploadLogData(logData);
        console.error(tag, data);
    }
    i(tag, data) {
        const logData = '[' + new Date() + '] [' + this.applicationId + '] [Angular] [INFO] [CEE Core Library] ['
            + this.environment.version + '] [' + tag + '] [' + data + ']';
        this.uploadLogData(logData);
        console.info(tag, data);
    }
    w(tag, data) {
        const logData = '[' + new Date() + '] [' + this.applicationId + '] [Angular] [WARNING] [CEE Core Library] ['
            + this.environment.version + '] [' + tag + '] [' + data + ']';
        this.uploadLogData(logData);
        console.warn(tag, data);
    }
    d(tag, data) {
        const logData = '[' + new Date() + '] [' + this.applicationId + '] [Angular] [DEBUG] [CEE Core Library] ['
            + this.environment.version + '] [' + tag + '] [' + data + ']';
        this.uploadLogData(logData);
        console.debug(tag, data);
    }
    log(tag, data) {
        const logData = '[' + new Date() + '] [' + this.applicationId + '] [Angular] [LOG] [CEE Core Library] ['
            + this.environment.version + '] [' + tag + '] [' + data + ']';
        this.uploadLogData(logData);
        // console.log(tag, data);
    }
    uploadLogData(logData) {
        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                'token': this.token
            })
        };
        const log = new Log();
        log.platform = this.platform;
        log.applicationName = this.applicationName;
        log.message.push(logData);
        this.httpClient.post(`${this.baseURL}/logapplication/application`, log, httpOptions).subscribe((res) => {
            //console.log(res);
        });
    }
    static ɵfac = function CeeLogHandlerService_Factory(t) { return new (t || CeeLogHandlerService)(i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(CeeInitServiceService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CeeLogHandlerService, factory: CeeLogHandlerService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CeeLogHandlerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: i9.HttpClient }, { type: CeeInitServiceService }], null); })();

class DynamicComponentHandlerService {
    factoryResolver;
    rootViewContainer;
    dynamicComponents = [];
    constructor(factoryResolver) {
        this.factoryResolver = factoryResolver;
    }
    registerComponent(name, component) {
        this.dynamicComponents[name] = component;
    }
    unregisterComponents() {
        this.dynamicComponents = [];
    }
    setRootViewContainerRef(viewContainerRef) {
        this.rootViewContainer = viewContainerRef;
    }
    addDynamicComponent(name, cInput) {
        const factory = this.factoryResolver.resolveComponentFactory(this.dynamicComponents[name]);
        const component = factory.create(this.rootViewContainer.parentInjector);
        for (const input of factory.inputs) {
            if (cInput && cInput[input.propName]) {
                component.setInput(input.propName, cInput[input.propName]);
            }
        }
        this.rootViewContainer.insert(component.hostView);
    }
    static ɵfac = function DynamicComponentHandlerService_Factory(t) { return new (t || DynamicComponentHandlerService)(i0.ɵɵinject(ComponentFactoryResolver)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DynamicComponentHandlerService, factory: DynamicComponentHandlerService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DynamicComponentHandlerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: undefined, decorators: [{
                type: Inject,
                args: [ComponentFactoryResolver]
            }] }], null); })();

class FlatUnflat {
    appDataService;
    flattenedJSON = {};
    constructor(appDataService) {
        this.appDataService = appDataService;
    }
    // Create Request Body according to step data and blocks data
    createRequestBodyonStepBlockData(requestBody, stepId) {
        const obj = {};
        /** store the app data in the request body */
        this.appDataService.getAllStepDataWithApiKey(stepId).subscribe(results => {
            for (const data of results) {
                obj[data.apiKey] = data.value;
            }
        });
        return obj;
    }
    // Parse the json and create the nested structure
    createNestedObject(obj, type = "") {
        // console.log(obj);
        let flattened;
        if (type == "repeatable") {
            flattened = this.flattenRepeatableBlock(obj);
        }
        else {
            flattened = this.flatten(obj);
        }
        if (flattened === undefined) {
            flattened = obj;
        }
        return flattened;
    }
    // Code flattening function
    // responseFlattener = (function (isArray, wrapped) {
    //   return function (table) {
    //     return reduce("", {}, table);
    //   };
    //   function reduce(path, accumulator, table) {
    //     if (isArray(table)) {
    //       var length = table.length;
    //       if (length) {
    //         var index = 0;
    //         while (index < length) {
    //           var property = path + "[]", item = table[index++];
    //           if (wrapped(item) !== item) accumulator[property] = item;
    //           else reduce(property, accumulator, item);
    //         }
    //       } else accumulator[path] = table;
    //     } else {
    //       var empty = true;
    //       if (path) {
    //         for (var property in table) {
    //           var item = table[property], property = path + "." + property, empty = false;
    //           if (wrapped(item) !== item) accumulator[property] = item;
    //           else reduce(property, accumulator, item);
    //         }
    //       } else {
    //         for (var property in table) {
    //           var item = table[property], empty = false;
    //           if (wrapped(item) !== item) accumulator[property] = item;
    //           else reduce(property, accumulator, item);
    //         }
    //       }
    //       if (empty) accumulator[path] = table;
    //     }
    //     return accumulator;
    //   }
    // }(Array.isArray, Object));
    /**
     * Code for flattening the response
     * @param data
     */
    flattenJSON(data) {
        this.flattenedJSON = {};
        return this.recurse(data, '');
    }
    recurse(cur, prop) {
        if (Object(cur) !== cur) {
            this.flattenedJSON[prop] = cur;
        }
        else if (Array.isArray(cur)) {
            // tslint:disable-next-line: no-var-keyword
            for (var i = 0, l = cur.length; i < l; i++) {
                this.recurse(cur[i], prop + '[' + i + ']');
            }
            if (l === 0) {
                this.flattenedJSON[prop] = [];
            }
        }
        else {
            let isEmpty = true;
            // tslint:disable-next-line: forin
            for (const p in cur) {
                isEmpty = false;
                this.recurse(cur[p], prop ? prop + '.' + p : p);
            }
            if (isEmpty && prop) {
                this.flattenedJSON[prop] = {};
            }
        }
        return this.flattenedJSON;
    }
    flatten(table) {
        var result = {};
        for (var path in table) {
            var cursor = result, length = path.length, property = "", index = 0;
            while (index < length) {
                var char = path.charAt(index);
                if (char === "[") {
                    var start = index + 1, end = path.indexOf("]", start), cursor = cursor[property] = cursor[property] || [], property = path.slice(start, end), index = end + 1;
                }
                else {
                    var cursor = cursor[property] = cursor[property] || {}, start = char === "." ? index + 1 : index, bracket = path.indexOf("[", start), dot = path.indexOf(".", start);
                    if (bracket < 0 && dot < 0)
                        var end = index = length;
                    else if (bracket < 0)
                        var end = index = dot;
                    else if (dot < 0)
                        var end = index = bracket;
                    else
                        var end = index = bracket < dot ? bracket : dot;
                    var property = path.slice(start, end);
                }
            }
            cursor[property] = table[path];
        }
        // Helper function to deep clone an object/array to avoid read-only property issues
        const deepClone = (obj) => {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            if (Array.isArray(obj)) {
                return obj.map(item => deepClone(item));
            }
            const cloned = {};
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    cloned[key] = deepClone(obj[key]);
                }
            }
            return cloned;
        };
        // Process arrays to handle gaps and empty elements
        const processArrays = (obj) => {
            for (const key in obj) {
                if (Array.isArray(obj[key])) {
                    // Create a new array instead of modifying the original
                    const filteredArray = obj[key].filter(item => item !== null && item !== undefined);
                    // Deep clone the filtered array to avoid read-only issues
                    obj[key] = deepClone(filteredArray);
                    // Recursively process nested arrays/objects
                    obj[key].forEach(item => {
                        if (item && typeof item === 'object') {
                            processArrays(item);
                        }
                    });
                }
                else if (obj[key] && typeof obj[key] === 'object') {
                    // Deep clone nested objects to avoid read-only issues
                    obj[key] = deepClone(obj[key]);
                    processArrays(obj[key]);
                }
            }
        };
        // Deep clone the result before processing to avoid read-only property issues
        const clonedResult = deepClone(result['']);
        processArrays(clonedResult);
        return clonedResult;
    }
    flattenRepeatableBlock(input) {
        const result = {};
        for (const key in input) {
            if (input.hasOwnProperty(key)) {
                const parts = key.split('.');
                let current = result;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (part.includes('[')) {
                        const [arrayKey, index] = part.split(/\[|\]/g).filter(Boolean);
                        current[arrayKey] = current[arrayKey] || {};
                        current = current[arrayKey];
                        current[index] = current[index] || {};
                        current = current[index];
                    }
                    else {
                        if (i === parts.length - 1) {
                            current[part] = input[key];
                        }
                        else {
                            current[part] = current[part] || {};
                            current = current[part];
                        }
                    }
                }
            }
        }
        return result;
    }
    ;
    parseDotNotation(str, val, obj) {
        let currentObj = obj;
        const keys = str.split('|');
        let i;
        const l = Math.max(1, keys.length - 1);
        let key;
        for (i = 0; i < l; ++i) {
            key = keys[i];
            currentObj[key] = currentObj[key] || {};
            currentObj = currentObj[key];
        }
        currentObj[keys[i]] = val;
        delete obj[str];
    }
    parseDotNotationArray(str, val, obj) {
        let currentObj = obj;
        const keys = str.split('.');
        let i;
        const l = Math.max(1, keys.length - 1);
        let key;
        for (i = 0; i < l; ++i) {
            key = keys[i];
            currentObj[key] = currentObj[key] || {};
            currentObj = currentObj[key];
        }
        currentObj[keys[i]] = val;
        delete obj[str];
    }
}

class RepeatableBlockData {
    localStorageStaticName = 'RepeatableBlock_';
    constructor() { }
    /**
     * setting data to the local storage
     * @param id the repeatable Block Id
     * @param data is basicaly the field data
     */
    setLocalStorageData(id, data) {
        localStorage.setItem(this.localStorageStaticName + id, JSON.stringify(this.returnFieldData(data)));
    }
    /**
     * updating data to the local storage
     * @param id the repeatable Block Id
     * @param data is basicaly the field data
     */
    updateRepeatableLocalStorageData(id, data) {
        const repeatableLocalData = localStorage.getItem(this.localStorageStaticName + id);
        if (repeatableLocalData !== null) {
            const repeatedData = JSON.parse(repeatableLocalData);
            repeatedData[data.fieldId] = data;
            localStorage.setItem(this.localStorageStaticName + id, JSON.stringify(repeatedData));
        }
        else {
            this.setLocalStorageData(id, data);
        }
    }
    /**
     * updating data to the local storage after set session is called from the base class
     * @param id the repeatable Block Id
     * @param data is basicaly the field data
     */
    updateRepeatableLocalStorageDataAfterSessionSet(id, data) {
        const repeatableLocalData = localStorage.getItem(this.localStorageStaticName + id);
        if (repeatableLocalData !== null) {
            const repeatedData = JSON.parse(repeatableLocalData);
            if (repeatedData.hasOwnProperty(data.fieldId)) {
                repeatedData[data.fieldId] = data;
                localStorage.setItem(this.localStorageStaticName + id, JSON.stringify(repeatedData));
            }
        }
    }
    /**
     * returns true if exists and false if not exists
     * @param blockId repeatableBlockId
     * @param uniqueId uniqueId of the field
     */
    returnIfData(blockId, uniqueId) {
        const repeatableLocalData = localStorage.getItem(this.localStorageStaticName + blockId);
        let hasData = false;
        if (repeatableLocalData !== null) {
            const repeatedData = JSON.parse(repeatableLocalData);
            if (repeatedData.hasOwnProperty(uniqueId)) {
                hasData = true;
            }
        }
        return hasData;
    }
    getRepeatableLocalStorageDataByBlockId(blockId) {
        const repeatableLocalData = localStorage.getItem(this.localStorageStaticName + blockId);
        if (repeatableLocalData) {
            return JSON.parse(repeatableLocalData);
        }
        return null;
    }
    /**
     * returns data from the local storage
     * @param blockId repeatableBlockId
     * @param uniqueId uniqueId of the field
     */
    getRepeatableLocalStorageData(blockId, uniqueId) {
        const repeatableLocalData = localStorage.getItem(this.localStorageStaticName + blockId);
        let data = {};
        if (repeatableLocalData !== null) {
            const repeatedData = JSON.parse(repeatableLocalData);
            if (repeatedData.hasOwnProperty(uniqueId)) {
                data = repeatedData[uniqueId];
            }
        }
        return data;
    }
    /**
     * remove data when a block is removed
     * @param blockId id of the block
     * @param ids fieldIds that are removed
     */
    removeDataUsingMultipleIds(blockId, ids) {
        const repeatableLocalData = localStorage.getItem(this.localStorageStaticName + blockId);
        if (repeatableLocalData !== null) {
            const repeatedData = JSON.parse(repeatableLocalData);
            const obj = {};
            for (const fieldId in repeatedData) {
                if (!ids.includes(fieldId)) {
                    obj[fieldId] = repeatedData[fieldId];
                }
            }
            localStorage.removeItem(this.localStorageStaticName + blockId);
            localStorage.setItem(this.localStorageStaticName + blockId, JSON.stringify(obj));
        }
    }
    /**
     * set the block count of repeatable block
     * @param blockId repeatable Block Id
     * @param count no of times the block is repeated
     */
    localStorageSetMaxBlockCount(blockId, count) {
        localStorage.setItem(blockId + '_count', JSON.stringify(count));
    }
    /**
     * return the count of the repeatable block is set
     * @param blockId string
     */
    localStorageGetMaxBlockCount(blockId) {
        return JSON.parse(localStorage.getItem(blockId + '_count'));
    }
    returnFieldData(data) {
        const obj = {};
        obj[data.fieldId] = data;
        return obj;
    }
    /**
     * removes data or count according to the type of clearance
     * @param blockId block id of the repeatable block
     * @param type if type is empty or not DATA or COUNT remove both count and data
     */
    removeByBlockId(blockId, type) {
        switch (type) {
            case 'DATA':
                localStorage.removeItem(this.localStorageStaticName + blockId);
                break;
            case 'COUNT':
                localStorage.removeItem(blockId + '_count');
                break;
            default:
                localStorage.removeItem(blockId + '_count');
                localStorage.removeItem(this.localStorageStaticName + blockId);
                break;
        }
    }
    /**
     * function to reset the whole repeatable block store
     */
    resetRepeatableStore() {
        for (const key of Object.entries(localStorage)) {
            const repetableName = key[0].split('_');
            if (repetableName[0] + '_' === this.localStorageStaticName) {
                localStorage.removeItem(key[0]);
            }
            if ('_' + repetableName[repetableName.length - 1] === '_count') {
                localStorage.removeItem(key[0]);
            }
        }
    }
}

class APIKeyUtil {
    constructor() { }
    getConcatenatedApiKeys(apiKey) {
        if (apiKey && apiKey.includes('||')) {
            // console.log(apiKey.split('||').map(str => str.trim()).join('+'));
            return apiKey.split('||').map(str => str.trim()).join('+');
        }
        else {
            return apiKey;
        }
    }
    getMultipleApiKeys(apiKey) {
        if (apiKey && apiKey.includes('|')) {
            return apiKey.split('|').map(str => str.trim());
        }
        else {
            return new Array(apiKey);
        }
    }
}

let AppDataStore = class AppDataStore extends EntityStore {
    constructor() {
        super();
    }
    static ɵfac = function AppDataStore_Factory(t) { return new (t || AppDataStore)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AppDataStore, factory: AppDataStore.ɵfac, providedIn: 'root' });
};
AppDataStore = __decorate([
    StoreConfig({ name: 'app-data' })
], AppDataStore);
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AppDataStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], () => [], null); })();

class AppDataQuery extends QueryEntity {
    store;
    constructor(store) {
        super(store);
        this.store = store;
    }
    static ɵfac = function AppDataQuery_Factory(t) { return new (t || AppDataQuery)(i0.ɵɵinject(AppDataStore)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AppDataQuery, factory: AppDataQuery.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AppDataQuery, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], () => [{ type: AppDataStore }], null); })();

class CommonUtil {
    constructor() { }
    getValue(data) {
        if (typeof (data) === 'string') {
            const value = data.split('||');
            if (value.length > 1) {
                return value[1];
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    getTitlesOptions(data) {
        if (typeof (data) === 'string') {
            const value = data.split('||');
            if (value.length > 2) {
                return value[2];
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    getDescriptionOptions(data) {
        if (typeof (data) === 'string') {
            const value = data.split('||');
            if (value.length > 3) {
                return value[3];
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    getID(data) {
        if (typeof (data) === 'string') {
            const value = data.split('||');
            if (value.length > 1) {
                return value[0].trim();
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    /**
     * function that returns the handler name from the key that is concatenated with ## handler name
     * @param data basically the api key example handlerName##key
     */
    getHandlerName(data) {
        if (typeof (data) === 'string') {
            const value = data.split('##');
            if (value.length > 1) {
                return value[0].trim();
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    /**
     * function that returns the api key from the key that is concatenated with ## handler name
     * @param data basically the api key example handlerName##key
     */
    getAPIKey(data) {
        if (typeof (data) === 'string') {
            const value = data.split('##');
            if (value.length > 1) {
                return value[1].trim();
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    getPossibleId(data) {
        if (typeof (data) === 'string') {
            const array = data.split('||');
            if (array.length > 1) {
                return array[0].trim();
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    getPossibleValue(data) {
        if (typeof (data) === 'string') {
            const array = data.split('||');
            if (array.length > 1) {
                return array[1].trim();
            }
            else {
                return data;
            }
        }
        else {
            return data;
        }
    }
    implodeClassName(data) {
        if (data) {
            return String(data).split(',').map(s => s.trim()).join(' ');
        }
        else {
            return '';
        }
    }
    blockBootstrapProcess(blockData) {
        if (localStorage.getItem('is_bootstrap') === 'true') {
            if (blockData.block_fields) {
                for (let i = 0; i < blockData.block_fields.length; i++) {
                    const field = blockData.block_fields[i];
                    if (field.field_style) {
                        if (blockData.block_style && blockData.block_style.bootstrap_class_name && !field.field_style.bootstrap_class_name) {
                            field.field_style.bootstrap_class_name = blockData.block_style.bootstrap_class_name;
                        }
                        field.field_style.bootstrap_class_name = this.implodeClassName(field.field_style.bootstrap_class_name);
                        field.field_style.custom_class_name = this.implodeClassName(field.field_style.custom_class_name);
                    }
                }
            }
            if (blockData.block_style) {
                blockData.block_style.custom_class_name = this.implodeClassName(blockData.block_style.custom_class_name);
            }
        }
        return blockData;
    }
    bootstrapColClass(data, isBootstrap = false, templateClass = '', bootstrapConditionalOutput = true) {
        if (data) {
            return bootstrapConditionalOutput ? data : (isBootstrap ? 'col-12' : '');
        }
        else {
            return templateClass ? templateClass : (isBootstrap ? 'col-12' : '');
        }
    }
    /**
     * function to validate date string with multiple format
     * @param dateString input date string
     * @param dateFormat date format to validate
     */
    isValidDateStr(dateString, dateFormat = 'MM/DD/YYYY', withTime = false) {
        if (dateString.hasOwnProperty('date')) {
            return true;
        }
        let dfregx = dateFormat
            .replace(/\//g, '\\/')
            .replace(/\-/g, '\\-')
            .replace(/\ /g, '\\ ')
            .replace('MM', '\\d{1,2}')
            .replace('M', '\\d{1,2}')
            .replace('DD', '\\d{1,2}')
            .replace('D', '\\d{1,2}')
            .replace('YYYY', '\\d{4}')
            .replace('YY', '\\d{2}');
        if (withTime) {
            dfregx = dfregx.replace('HH', '\\d{2}')
                .replace('H', '\\d{1,2}')
                .replace('hh', '\\d{2}')
                .replace('h', '\\d{1,2}')
                .replace('mm', '\\d{2}')
                .replace('m', '\\d{1,2}')
                .replace('ss', '\\d{2}')
                .replace('s', '\\d{1,2}')
                .replace('A', '(AM|PM)')
                .replace('a', '(am|pm)');
        }
        let dateRegex = new RegExp(dfregx);
        // First check for the pattern
        if (!dateRegex.test(dateString))
            return false;
        // Parse the date parts to integers
        var partFormats = dateFormat.split(dateFormat.match(/[\/\-\ ]/gm)[0]);
        var parts = !Array.isArray(dateString) ? dateString.split(dateFormat.match(/[\/\-\ ]/gm)[0]) : dateString[0].split(dateFormat.match(/[\/\-\ ]/gm)[0]);
        var day = parseInt(parts[partFormats.findIndex(v => v === 'DD')], 10);
        var month = parseInt(parts[partFormats.findIndex(v => v === 'MM')], 10);
        var year = parseInt(parts[partFormats.findIndex(v => v === 'YYYY')], 10);
        // Check the ranges of month and year
        if (year < 1000 || year > 3000 || month == 0 || month > 12)
            return false;
        var monthLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        // Adjust for leap years
        if (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0))
            monthLength[1] = 29;
        // Check the range of the day
        return day > 0 && day <= monthLength[month - 1];
    }
    ;
    /**
     * function to validate time string with multiple format
     * @param dateString input date string
     * @param dateFormat date format to validate
     */
    isValidTimeStr(timeString, dateFormat = 'h:mm A') {
        let timeRegex = new RegExp(dateFormat
            .replace(/\ /g, '\\ ')
            .replace('HH', '\\d{2}')
            .replace('H', '\\d{1,2}')
            .replace('hh', '\\d{2}')
            .replace('h', '\\d{1,2}')
            .replace('mm', '\\d{2}')
            .replace('m', '\\d{1,2}')
            .replace('ss', '\\d{2}')
            .replace('s', '\\d{1,2}')
            .replace('A', '(AM|PM)')
            .replace('a', '(am|pm)'));
        // First check for the pattern
        if (!timeRegex.test(timeString))
            return false;
        else
            return true;
    }
    ;
    /**
     * function to parse time with multiple format
     * @param timeString input time string
     * @param dateFormat date format to return
     */
    parseTime(timeString, dateFormat) {
        var d = new Date();
        if (!timeString || typeof timeString !== 'string') {
            return '';
        }
        var time = timeString.match(/(\d+)(?::(\d\d))?\s*(p|P?)/);
        d.setHours(parseInt(time[1]) + (time[3] ? 12 : 0));
        d.setMinutes(parseInt(time[2]) || 0);
        return moment.default(d.toISOString()).format(dateFormat);
    }
    escapeRegExp = str => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    setFilterKeys(dataSource, fKeys) {
        fKeys = fKeys.filter(str => str);
        dataSource.filterPredicate = (data, filter) => {
            // for (const col in data) {
            //     if ((fKeys.length === 0 || fKeys.includes(col)) && data[col].toString().toLowerCase().indexOf(filter) != -1) {
            //         found = true;
            //     }
            // }
            return this.setFilterPredicateInner(data, filter, fKeys);
        };
    }
    setFilterPredicateInner(data, filter, fKeys, found = false) {
        for (const col in data) {
            if (Array.isArray(data[col])) {
                for (const innerRow of data[col]) {
                    if (this.setFilterPredicateInner(innerRow, filter, fKeys, found)) {
                        found = true;
                    }
                }
            }
            else {
                if ((fKeys.length === 0 || fKeys.includes(col)) && data[col].toString().toLowerCase().indexOf(filter) != -1) {
                    found = true;
                }
            }
        }
        return found;
    }
    isValidDate(d) {
        return d instanceof Date && !isNaN(d.getDate());
    }
    // public adjustTZ(dateTime: Date) {
    //     if (this.isValidDate(dateTime) && dateTime.getTimezoneOffset() > 0) {
    //         let dtString = new Date(dateTime.toISOString().slice(0, 10));
    //         dtString.setMinutes(dtString.getMinutes() + dtString.getTimezoneOffset());
    //         return dtString;
    //     }
    //     return dateTime;
    // }
    adjustTZ(dateTime) {
        if (this.isValidDate(dateTime)) {
            // Convert the given date to the user's local time zone
            const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            // Get the local time in ISO format and create a new Date object
            const localTimeString = dateTime.toLocaleString('en-US', { timeZone: userTimeZone });
            return new Date(localTimeString);
        }
        return dateTime;
    }
    // public adjustTZ(dateTime: Date) {
    //     console.log('dateTime')
    //     if (this.isValidDate(dateTime) && dateTime.getTimezoneOffset() > 0) {
    //         //let dtString = new Date(dateTime.toISOString().slice(0, 10));
    //         let dtString = new Date(dateTime.toISOString());
    //         //dtString.setMinutes(dtString.getMinutes() + dtString.getTimezoneOffset());
    //        // dtString.setMinutes(dtString.getMinutes());
    //         return dtString;
    //     }
    //     return dateTime;
    // }
    /**
     * the api key that is set to dynamic
     * @param maskstr the api key string
     * @param maskpostion then position you want mask
     * @param mask the character of masking
     * @param masknum then number character you want to mask
     * @param extraTitle the optional extra title
     * @param extraTitlePosition then option extra title position
     */
    getMaskedData(maskstr, maskpostion, mask, masknum, extraTitle, extraTitlePosition) {
        let str;
        if (extraTitle && extraTitlePosition) {
            if (extraTitlePosition == "s") {
                str = extraTitle + maskstr;
            }
            if (extraTitlePosition == "e") {
                str = maskstr + extraTitle;
            }
        }
        else {
            str = maskstr;
        }
        let strippedStr = str?.replace(/\s+/g, '');
        let maskedStr;
        if (maskpostion === 'end') {
            maskedStr = strippedStr?.slice(0, -masknum) + mask?.repeat(masknum);
        }
        if (maskpostion === 'start') {
            maskedStr = mask?.repeat(masknum) + strippedStr?.slice(masknum);
        }
        if (maskpostion === 'both') {
            let maskedStr2 = mask?.repeat(masknum) + strippedStr?.slice(masknum);
            maskedStr = maskedStr2?.slice(0, -masknum) + mask?.repeat(masknum);
        }
        if (maskpostion === 'all') {
            maskedStr = mask?.repeat(str.length) + strippedStr?.slice(masknum.length);
        }
        let outputStr = '';
        let j = 0;
        for (let i = 0; i < str?.length; i++) {
            if (str[i] === ' ') {
                outputStr += ' ';
            }
            else {
                outputStr += maskedStr[j];
                j++;
            }
        }
        return outputStr;
    }
    setAppConfigValue(arg0) {
        if (typeof arg0 === 'object') {
            if (Array.isArray(arg0)) {
                for (let i = 0; i < arg0.length; i++) {
                    arg0[i] = this.setAppConfigValue(arg0[i]);
                }
            }
            else {
                for (const arg1 in arg0) {
                    arg0[arg1] = this.setAppConfigValue(arg0[arg1]);
                }
            }
        }
        else if (typeof arg0 === 'string') {
            const reg = /\${.+}/g;
            let matchArg;
            while ((matchArg = reg.exec(arg0)) !== null) {
                const matchArgValue = matchArg[0].replace('${', '').replace('}', '');
                const matchArgValueData = localStorage.getItem(matchArgValue);
                if (matchArgValueData) {
                    arg0 = arg0.replace('${' + matchArgValue + '}', matchArgValueData);
                }
            }
        }
        return arg0;
    }
    // *************************************************
    returnAccessToken() {
        const accessToken = `${this.getCookie('headerPayload')}.${this.getCookie('signature')}`;
        return accessToken;
    }
    getCookie(name) {
        const ca = document.cookie.split(';');
        const caLen = ca.length;
        const cookieName = `${name}=`;
        let c;
        for (let i = 0; i < caLen; i += 1) {
            c = ca[i].replace(/^\s+/g, '');
            if (c.indexOf(cookieName) === 0) {
                return c.substring(cookieName.length, c.length);
            }
        }
        return '';
    }
    async getBase64ImageFromUrl(imageUrl) {
        var res = await fetch(imageUrl);
        var blob = await res.blob();
        return new Promise((resolve, reject) => {
            var reader = new FileReader();
            reader.addEventListener("load", function () {
                resolve(reader.result);
            }, false);
            reader.onerror = () => {
                return reject(this);
            };
            reader.readAsDataURL(blob);
        });
    }
    async processZipFile(AttachmentFiles) {
        const zip = new JSZip();
        for (const attachmentFile of AttachmentFiles) {
            if (attachmentFile.url) {
                const result = await this.getBase64ImageFromUrl(attachmentFile.url);
                const base64result = result.split(',')[1];
                zip.file(attachmentFile.name, base64result, { base64: true });
            }
        }
        zip.generateAsync({ type: "blob" }).then(function (content) {
            saveAs(content, Date.now() + ".zip");
        });
    }
    /**
     * Extracts the last two values from a given string.
     *
     * @param str - The input string
     * @param delimiter - The delimiter string
     *
     * @returns An object containing two properties. If the extraction fails returns `null`.
     */
    extractLastValues(str, delimiter) {
        const regex = new RegExp(`\\${delimiter}(\\d+)\\${delimiter}(\\d+)$`);
        // const regex = /\$(\d+)\$(\d+)$/;
        const match = str.match(regex);
        if (match) {
            const a = match[1];
            const b = match[2];
            return { a, b };
        }
        return null;
    }
    /**
     * Extracts the lastvalue from a given string.
     *
     * @param str - The input string
     * @param delimiter - The delimiter string
     *
     * @returns An object containing two properties. If the extraction fails returns `null`.
     */
    extractLastValue(str, delimiter) {
        // const regex = /\$(\d+)$/;
        const regex = new RegExp(`\\${delimiter}(\\d+)$`);
        const match = str.match(regex);
        if (match) {
            return match[1];
        }
        return null;
    }
    /**
    * Find indices from a given string `unique_id` and substitute [*] in key with indices once by one.
    *
    * @param key - The string in which to replace [*] with indices
    * @param unique_id - The string in which to search indices.
    * @param delimiter - The delimiter string
    *
    * @returns A new string with all instances of `key` replaced by asterisks.
    */
    findIndicesAndSubstituteStars(key, unique_id, delimiter) {
        const result = this.extractLastValues(unique_id, delimiter);
        if (result != null) {
            key = this.substituteAlternateStars(key, result.a, result.b);
        }
        else {
            const ind = this.extractLastValue(unique_id, delimiter);
            if (ind != null) {
                key = this.substituteAllStars(key, ind);
            }
        }
        return key;
    }
    /**
     * Replaces all occurrences of [*] with the string `i` in the string `str`.
     *
     * @param str - The input string in which substitutions are to be made.
     * @param i - The character to be replaced by asterisks [*].
     * @param delimiter - The delimiter string
     *
     * @returns A new string with all instances of `i` replaced by asterisks.
     */
    substituteAllStars(str, i) {
        const pattern = '\\[\\*\\]';
        const result = str.replace(new RegExp(pattern, 'g'), `[${i}]`);
        return result;
    }
    /**
     * Substitutes alternating stars in a string with [*].
     *
     * @param str - The string in which substitutions are to be made.
     * @param i - The character to replace with first search of [*].
     * @param j - The character to replace with second search of [*].
     * @returns A new string with alternating replacements of `i` by asterisks and `j` unchanged.
     */
    substituteAlternateStars(str, i, j) {
        let result = '';
        let insidePercent = false;
        let toggle = true;
        let tempSegment = '';
        // iterate through each character in the string
        for (let k = 0; k < str.length; k++) {
            const char = str[k];
            if (char === '%' && !insidePercent) {
                // start of a %...% block
                insidePercent = true;
                result += char;
            }
            else if (char === '%' && insidePercent) {
                // end of a %...% block
                insidePercent = false;
                result += tempSegment + char;
                tempSegment = ''; // Clear tempSegment for the next block
            }
            else if (insidePercent) {
                // inside a %...% block, so handle replacements
                if (char === '[' && str[k + 1] === '*' && str[k + 2] === ']') {
                    tempSegment += `[${toggle ? i : j}]`; // Add the replacement
                    toggle = !toggle; // Alternate between i and j
                    k += 2; // Skip "]"
                }
                else {
                    tempSegment += char; // non [*] characters in the segment
                }
            }
            else {
                // outside of %...% blocks, append the character
                result += char;
            }
        }
        return result;
    }
    // ****************** MatDialog in Dialog (StepModal) *******************************
    /**
     * Search dialog in DOM and find the stepModal if exist
     *
     * @returns StepModal html element if found else undefined
     */
    getStepModalDialogIfExist() {
        const dialogElements = document.getElementsByTagName('dialog');
        for (let i = 0; i < dialogElements.length; i++) {
            const dialog = dialogElements[i];
            if (dialog.id.includes("stepModal-")) {
                return dialog;
            }
        }
    }
    /**
     * Find and move the MatDialog in DOM from body to stepModal if exists.
     * cdk-overlay-container is used to find the MatDialog
     *
     * @returns StepModal html element if found else undefined
     */
    moveMatDialogToStepModalIfExist() {
        let stepModal = this.getStepModalDialogIfExist();
        if (stepModal) {
            const dialogContainer = document.querySelector('.cdk-overlay-container');
            if (dialogContainer) {
                stepModal.appendChild(dialogContainer);
            }
        }
    }
    /**
     * Move the MatDialog in DOM from stepModal to body if exists.
     * cdk-overlay-container is used to find the MatDialog.
     *
     * @returns StepModal html element if found else undefined
     */
    moveMatDialogToBody() {
        let stepModal = this.getStepModalDialogIfExist();
        const body = document.getElementsByTagName('body');
        if (stepModal && body && body.length > 0) {
            const dialogContainer = document.querySelector('.cdk-overlay-container');
            if (dialogContainer) {
                body[0].appendChild(dialogContainer);
            }
        }
    }
    // Custom function to format large numbers without losing precision
    formatNumber(value) {
        if (!value)
            return '';
        const stringValue = String(value);
        // Prevent JavaScript from modifying numbers by keeping them as a string
        return stringValue.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }
}

let ApiDataStore = class ApiDataStore extends EntityStore {
    constructor() {
        super();
    }
    static ɵfac = function ApiDataStore_Factory(t) { return new (t || ApiDataStore)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ApiDataStore, factory: ApiDataStore.ɵfac, providedIn: 'root' });
};
ApiDataStore = __decorate([
    StoreConfig({ name: 'api-data' })
], ApiDataStore);
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ApiDataStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], () => [], null); })();

class ApiDataQuery extends QueryEntity {
    store;
    constructor(store) {
        super(store);
        this.store = store;
    }
    static ɵfac = function ApiDataQuery_Factory(t) { return new (t || ApiDataQuery)(i0.ɵɵinject(ApiDataStore)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ApiDataQuery, factory: ApiDataQuery.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ApiDataQuery, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], () => [{ type: ApiDataStore }], null); })();

class ApiDataService {
    apiDataStore;
    apiDataQuery;
    sessionDataAddedCallback;
    sessionDataUpdatedCallback;
    sessionDataRemovedCallback;
    commonUtil;
    logoutAllTabChannel;
    constructor(apiDataStore, apiDataQuery) {
        this.apiDataStore = apiDataStore;
        this.apiDataQuery = apiDataQuery;
        this.commonUtil = new CommonUtil();
        this.logoutAllTabChannel = new BroadcastChannel('logoutAllTab');
        this.listenForClearData();
    }
    // return top largest entities with size
    topLargestEntities(n) {
        const storeStates = this.apiDataStore.getValue();
        const storeEntries = Object.entries(storeStates.entities);
        const storeStatesWithSize = storeEntries.map(([key, value]) => {
            const sizeKB = (new Blob([JSON.stringify(value)]).size / 1024).toFixed(2);
            ;
            return { key, sizeKB };
        });
        return storeStatesWithSize
            .sort((a, b) => Number(b.sizeKB) - Number(a.sizeKB))
            .slice(0, n);
    }
    setSessionDataAddedCallback(callback) {
        this.sessionDataAddedCallback = callback;
    }
    setSessionDataUpdatedCallback(callback) {
        this.sessionDataAddedCallback = callback;
    }
    setSessionDataRemovedCallback(callback) {
        this.sessionDataRemovedCallback = callback;
    }
    setApiData(appData) {
        if (this.apiDataQuery.hasEntity(entity => entity.apiKey === appData.apiKey)) {
            this.apiDataStore.update(appData.id, { ...appData });
        }
        else {
            if (appData.id != undefined || appData.id != 'undefined') {
                this.apiDataStore.add(appData);
            }
        }
    }
    setApiDataByApiUrl(appData) {
        if (this.apiDataQuery.hasEntity(entity => entity.apiUrl === appData.apiUrl)) {
            this.apiDataStore.update(appData.id, { ...appData });
        }
        else {
            this.apiDataStore.add(appData);
        }
    }
    addApiData(apiData, isMultiTab = false) {
        // let data = this.apiDataStore.getValue();
        // console.log("data: ",data)
        if (isMultiTab) {
            this.deleteApiData(apiData.id);
        }
        if (apiData.id != undefined || apiData.id != 'undefined') {
            this.apiDataStore.add(apiData);
        }
    }
    updateApiData(appData) {
        this.apiDataStore.update(appData.id, { ...appData });
    }
    // replaceStorageData() {
    //     let data = new ApiDataStore();
    //     let newData = data.getValue();
    //     sessionStorage.setItem("AkitaStores", JSON.stringify(newData));
    // }
    deleteApiData(id) {
        this.apiDataStore.remove(id);
    }
    deleteMultipleApiData(ids, fromStep) {
        this.apiDataStore.remove(ids);
        if (localStorage.getItem('singleApiKey') !== 'true') {
            this.deleteAPIDataUsingApiKeyAndApiHandler(ids, fromStep);
        }
    }
    removeAllApiData() {
        this.apiDataStore.remove();
    }
    destroyAllApiData() {
        this.apiDataStore.destroy();
    }
    // TODO: Session Clearance using API Keys when using hashed API KEY needs to be fixed
    async deleteAPIDataUsingApiKeyAndApiHandler(ids, fromStep) {
        ids = [...new Set(ids)];
        const apiStoreData = this.apiDataStore.getValue().entities;
        // const keys = Object.keys(apiStoreData);
        const obj = {};
        for (const id of ids) {
            if (id) {
                const handlerName = this.commonUtil.getHandlerName(id);
                // get the data from the handler name match
                // check if the id contains [*] in it then
                // get the keys from the object
                if (String(id).includes('[*]') && apiStoreData[handlerName]) {
                    const key = String(id).replace(/\[(\*)\]/g, '\\[\\d+\\]');
                    const regex = new RegExp(key);
                    const matchedKeys = this.returnMatchedKeys(apiStoreData[handlerName].value, regex);
                    obj[handlerName] = [...(obj[handlerName] || []), ...matchedKeys];
                }
                else {
                    if (obj[handlerName]) {
                        obj[handlerName].push(id);
                    }
                    else {
                        obj[handlerName] = [id];
                    }
                }
            }
        }
        for (const key of Object.keys(obj)) {
            if (apiStoreData[key]) {
                this.returnFilteredValues(apiStoreData[key].value, obj[key], key, fromStep);
            }
        }
    }
    returnMatchedKeys(apiData, r) {
        const keys = [];
        Object.keys(apiData).forEach(key => {
            const matched = key.match(r);
            if (matched) {
                keys.push(matched['input']);
            }
        });
        return keys;
    }
    /**
     * function that filters the key value pair from the given array of keys
     * @param storeData the value of the handler
     * @param keys keys that needs to be removed
     * @param handlerName handlerName
     */
    returnFilteredValues(storeData, keys, handlerName, fromStep) {
        const newApiData = {
            id: handlerName,
            apiKey: '',
            apiUrl: handlerName,
            value: ''
        };
        if (!fromStep) {
            const obj = {};
            // const obj = keys.reduce((o, k) => { o[k] = storeData[k]; return o; }, {});
            const myArray = Object.keys(storeData).filter((el) => {
                return !keys.includes(el);
            });
            // for (const key of keys) {
            //     if (key.includes('[*]')) {
            //         const regex = key.split('[*]').join('\\[\\d+\\]');
            //         for (const el of myArray) {
            //             const result = el.match(new RegExp(regex));
            //             if (result !== null) {
            //                 myArray.splice(myArray.indexOf(result[0]), 1);
            //             }
            //         }
            //     }
            // }
            myArray.forEach(elm => {
                obj[elm] = storeData[elm];
            });
            // console.log(obj);
            newApiData.value = obj;
            // console.log(newApiData);
            this.updateApiData(Object.assign({}, newApiData));
        }
        else {
            this.deleteApiData(handlerName);
        }
    }
    /////////////////////// Query Statements ///////////////////////
    getApiKeyValueByKeyString(concatenatedApiKeys, separator) {
        const apiStoreData = this.apiDataStore.getValue();
        const fieldValues = [];
        for (const entity of concatenatedApiKeys.split(separator)) {
            const currentity = entity.split("#")[0];
            fieldValues.push(apiStoreData.entities[currentity] !== undefined ? apiStoreData.entities[currentity].value[entity] : undefined);
            // fieldValues.push(apiStoreData.entities[entity] !== undefined ? apiStoreData.entities[entity].value : undefined);
        }
        return fieldValues;
    }
    getAPIKeyValueByArray(concatenatedApiKeys, separator) {
        const apiStoreData = this.apiDataStore.getValue();
        const fieldValues = [];
        for (const entity of concatenatedApiKeys.split(separator)) {
            const currentity = entity.split("#")[0];
            let arrOfElements = this.extractValuesOfArrayFromHandler(apiStoreData.entities[currentity].value);
            fieldValues.push(arrOfElements[entity]);
        }
        return fieldValues;
    }
    extractValuesOfArrayFromHandler(input) {
        var newobj = {};
        Object.keys(input).forEach((key) => {
            if (key === "handler_name") {
                return;
            }
            var fieldName = key.replace(/\[\d+\]$/, '');
            if (!newobj[fieldName]) {
                newobj[fieldName] = [];
            }
            if (input[key].length > 0) {
                newobj[fieldName].push(input[key]);
            }
        });
        return newobj;
    }
    getApiKeyValueByApiKey(apiKey) {
        let appData;
        let success = false;
        this.apiDataQuery.selectAll({
            filterBy: [
                entity => entity.apiKey === apiKey
            ]
        }).subscribe(res => {
            if (res.length > 0) {
                appData = res[0].value;
            }
            success = true;
        });
        if (success) {
            return appData;
        }
    }
    /**
     * function that return role value from the api
     * @param roleId the api key for UserRole
     */
    getUserRoleValue(roleId) {
        let roleValue;
        if (roleId) {
            for (const roleApikey of roleId.split('|').map(str => str.trim())) {
                roleValue = this.getApiDataByApiKey(roleApikey) ? this.getApiDataByApiKey(roleApikey).value : undefined;
                if (roleValue === undefined && roleApikey.includes('##')) {
                    const handlerName = roleApikey.split('##')[0].trim();
                    const apiData = this.getApiDataByHandler(handlerName);
                    if (roleApikey.includes('[*]') && apiData) {
                        const regex = roleApikey.split('[*]').join('\\[\\d+\\]');
                        const roleValues = [];
                        for (const dataKey of Object.keys(apiData.value)) {
                            const result = dataKey.match(new RegExp(regex));
                            if (result) {
                                roleValues.push(apiData.value[dataKey]);
                            }
                        }
                        roleValue = roleValues.join(',');
                    }
                    else {
                        roleValue = apiData ? apiData.value[roleApikey] : undefined;
                    }
                }
                if (roleValue !== undefined) {
                    break;
                }
            }
        }
        return roleValue;
    }
    getApiDataByApiKey(name) {
        const apiStoreData = this.apiDataStore.getValue();
        for (const entity of Object.keys(apiStoreData.entities)) {
            if (apiStoreData.entities[entity].apiKey === name) {
                return apiStoreData.entities[entity];
            }
        }
        return undefined;
    }
    getApiDataByHandler(name) {
        const apiStoreData = this.apiDataStore.getValue();
        for (const entity of Object.keys(apiStoreData.entities)) {
            if (apiStoreData.entities[entity].apiUrl === name) {
                return apiStoreData.entities[entity];
            }
        }
        return undefined;
    }
    getAllApiStoreData() {
        const data = [];
        const apiStoreData = this.apiDataStore.getValue();
        // tslint:disable-next-line: forin
        for (const apiData in apiStoreData.entities) {
            data.push(apiStoreData.entities[apiData]);
        }
        return data;
    }
    getAllApiData() {
        return this.apiDataQuery.selectAll();
    }
    listenForClearData() {
        this.logoutAllTabChannel.addEventListener('message', (event) => {
            if (event.data === 'redirectToLogoutTabs') {
                this.removeAllApiData();
            }
        });
    }
    ngOnDestroy() {
        if (this.logoutAllTabChannel) {
            this.logoutAllTabChannel.close();
        }
    }
    static ɵfac = function ApiDataService_Factory(t) { return new (t || ApiDataService)(i0.ɵɵinject(ApiDataStore), i0.ɵɵinject(ApiDataQuery)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ApiDataService, factory: ApiDataService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ApiDataService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: ApiDataStore }, { type: ApiDataQuery }], null); })();

class AppDataService {
    appDataStore;
    appDataQuery;
    apiDataService;
    repetableBlockUtil;
    apiKeyUtil;
    appDatasubscription;
    appDatacurrentValue;
    logoutAllTabChannel;
    constructor(appDataStore, appDataQuery, apiDataService) {
        this.appDataStore = appDataStore;
        this.appDataQuery = appDataQuery;
        this.apiDataService = apiDataService;
        this.repetableBlockUtil = new RepeatableBlockData();
        this.apiKeyUtil = new APIKeyUtil();
        this.fetchappData();
        this.logoutAllTabChannel = new BroadcastChannel('logoutAllTab');
        this.listenForClearData();
    }
    // return top largest entities with size
    topLargestEntities(n) {
        const storeStates = this.appDataStore.getValue();
        const storeEntries = Object.entries(storeStates.entities);
        const storeStatesWithSize = storeEntries.map(([key, value]) => {
            const sizeKB = (new Blob([JSON.stringify(value)]).size / 1024).toFixed(2);
            ;
            return { key, sizeKB };
        });
        return storeStatesWithSize
            .sort((a, b) => Number(b.sizeKB) - Number(a.sizeKB))
            .slice(0, n);
    }
    fetchappData() {
        this.appDatasubscription = this.currentValueChanges().subscribe(newState => {
            this.appDatacurrentValue = newState;
        });
    }
    currentValueChanges() {
        return this.appDataQuery.select(state => state);
    }
    ngOnDestroy() {
        if (this.appDatasubscription) {
            this.appDatasubscription.unsubscribe();
        }
        if (this.logoutAllTabChannel) {
            this.logoutAllTabChannel.close();
        }
    }
    addAppData(appData) {
        this.appDataStore.add({ ...appData, ...{ createdOn: (new Date()).getTime(), updatedOn: (new Date()).getTime() } });
    }
    updateMultipleAppData(data) {
    }
    getIndividualAppData(id) {
        return this.appDataQuery.selectAll({
            filterBy: entity => entity.id === id
        });
    }
    updateAppData(appData) {
        // const data = this.appDataStore.getValue();
        const dataEnities = this.appDatacurrentValue['entities'];
        const keyData = dataEnities[appData.id] !== undefined ? JSON.parse(JSON.stringify(dataEnities[appData.id])) : undefined;
        if (keyData) {
            keyData.createdOn && delete keyData.createdOn;
            keyData.updatedOn && delete keyData.updatedOn;
            appData["createdOn"] && delete appData["createdOn"];
            appData["updatedOn"] && delete appData["updatedOn"];
        }
        if (keyData && JSON.stringify(keyData) !== JSON.stringify(appData)) {
            if (keyData['value'] === appData['value']) {
                this.appDataStore.update(appData.id, { ...appData });
            }
            else {
                this.appDataStore.update(appData.id, { ...appData, ...{ updatedOn: (new Date()).getTime() } });
            }
        }
    }
    deleteAppData(id) {
        this.appDataStore.remove(id);
    }
    deleteMultipleAppData(ids) {
        // clear the language in the session storage
        // if (ids.includes(window.localStorage.getItem('langField'))) {
        //     window.localStorage.removeItem('lang');
        //     localStorage.removeItem('stepDataCache');
        //     localStorage.removeItem('lastBlockLoaded');
        //     localStorage.removeItem('blockDataCache');
        // }
        this.appDataStore.remove(ids);
    }
    removeAllAppData() {
        const saveFieldListValue = localStorage.getItem('saveFieldList');
        if (saveFieldListValue) {
            const saveFieldList = saveFieldListValue.split('|').map(str => str.trim());
            this.appDataQuery.selectAll().subscribe(apiKeyValues => {
                const ids = [];
                for (const apiKeyVal of apiKeyValues) {
                    if (!saveFieldList.includes(String(apiKeyVal.id))) {
                        ids.push(apiKeyVal.id);
                    }
                }
                this.appDataStore.remove(ids);
            });
        }
        else {
            this.appDataStore.remove();
        }
        // clear the language data
        // window.localStorage.removeItem('lang');
        // localStorage.removeItem('stepDataCache');
        // localStorage.removeItem('lastBlockLoaded');
        // localStorage.removeItem('blockDataCache');
        this.repetableBlockUtil.resetRepeatableStore();
    }
    destroyAllAppData() {
        this.appDataStore.destroy();
    }
    /////////////////////// Query Statements ///////////////////////
    /**
     * function that updates appData to the akita store if the field is found
     * else adds the appData to the akita store
     * @param appData AppData model object
     */
    setAppData(appData) {
        this.getAppDataByFieldId(String(appData.id)).pipe(take(1)).subscribe(val => {
            if (val && (val.id === String(appData.id))) {
                this.updateAppData({ ...val, ...appData });
            }
            else {
                this.addAppData(appData);
            }
        });
    }
    getFieldPropertiesByID(fieldId) {
        return this.appDataStore.getValue().entities[fieldId];
    }
    getAllAppStoreData(blockId) {
        let storeData = [];
        if (blockId && blockId !== 'true' && blockId !== 'false') {
            return this.appDataQuery.getAll({
                filterBy: [
                    entity => String(entity.id).includes(blockId),
                    entity => entity.mandatory
                ]
            });
        }
        else {
            storeData = Object.values(this.appDataStore.getValue().entities);
        }
        const appData = [];
        // tslint:disable-next-line: forin
        for (const data in storeData) {
            let obj = storeData[data];
            // if (obj.linkedBlockId) {
            //     obj = {
            //         ...obj,
            //         ...{
            //             mandatory: this.repetableBlockUtil.getRepeatableLocalStorageData
            //                 (obj.linkedBlockId, String(obj.id))['isMandatory']
            //         }
            //     };
            // }
            appData.push(obj);
        }
        return appData;
    }
    getAllAppData() {
        return this.appDataQuery.selectAll();
    }
    getAllStepData(stepId) {
        return this.appDataQuery.selectAll({
            filterBy: entity => entity.stepId === stepId
        });
    }
    getAllStepDataWithApiKey(stepId) {
        return this.appDataQuery.selectAll({
            filterBy: [
                entity => entity.stepId === stepId,
                entity => entity.apiKey.trim().length > 0
            ]
        });
    }
    getAllStepDataWithRequestApiKey(stepId) {
        return this.appDataQuery.selectAll({
            filterBy: [
                entity => entity.stepId === stepId
            ]
        }).pipe(map(res => {
            let finalArr = [];
            for (const data of res) {
                let obj = {};
                const arr = [];
                for (const requestKey of data.requestApiKey) {
                    obj = data;
                    obj = { ...obj, apiKey: requestKey };
                    arr.push(obj);
                }
                finalArr = [...finalArr, ...arr];
            }
            return finalArr;
        }));
    }
    getAllStepDataByMandatory(stepId, isMandatory) {
        return this.appDataQuery.selectAll({
            filterBy: [
                entity => entity.stepId === stepId,
                entity => entity.mandatory === isMandatory
            ]
        });
    }
    getAppDataByFieldId(fieldId) {
        return this.appDataQuery.selectEntity(fieldId);
    }
    getFieldDataByFieldIds(separatedFieldString, separator) {
        const data = this.appDataStore.getValue();
        const fieldData = [];
        for (const field of separatedFieldString.split(separator)) {
            fieldData.push(data.entities[field.trim()] !== undefined ? data.entities[field.trim()].value : undefined);
        }
        return fieldData;
    }
    getFieldDataByFieldId(fieldId) {
        // let success = false;
        // let keyValue = '';
        // this.appDataQuery.selectEntity(fieldId)
        //     .pipe(take(1)).subscribe(val => {
        //         keyValue = val ? val.value : undefined;
        //         success = true;
        //     });
        // return keyValue;
        const data = this.appDataStore.getValue();
        const keyVal = data.entities[fieldId] !== undefined ? data.entities[fieldId].value : undefined;
        return keyVal;
    }
    returnIfRepeatedField(repeatedBlockFieldId) {
        const data = this.appDataStore.getValue();
        let isRepeated = false;
        for (const entity in data.entities) {
            if (entity === repeatedBlockFieldId) {
                if (data.entities[repeatedBlockFieldId].isRepeatedField) {
                    isRepeated = true;
                    break;
                }
            }
        }
        return isRepeated;
    }
    getFieldIdMapFieldValueByRepeatedBlockFieldId(repeatedBlockFieldId) {
        const obj = {};
        const data = this.appDataStore.getValue();
        for (const entity in data.entities) {
            if (data.entities[entity].repeatedBlockFieldId) {
                if (repeatedBlockFieldId === data.entities[entity].repeatedBlockFieldId) {
                    obj[entity] = data.entities[entity].value;
                }
            }
        }
        return obj;
    }
    // getFieldDataByApiKey(apiKey: string) {
    //     let success = false;
    //     let keyValue = '';
    //     this.appDataQuery.selectAll({
    //         filterBy: [
    //             entity => entity.apiKey === apiKey
    //         ]
    //     }).subscribe(val => {
    //         keyValue = val[0].value;
    //         success = true;
    //     });
    //     if (success) {
    //         return keyValue;
    //     }
    // }
    /**
     * returns the field value of the basis of the type of the api key
     *
     * @param apiKey is tha api key that is required
     * @param type is bsically the type of the api key i.e request or response
     */
    getFieldDataByApiKey(apiKey, type) {
        let success = false;
        let keyValue = '';
        this.appDataQuery.selectAll().subscribe(val => {
            for (const singleVal of val) {
                if (type === 'request') {
                    for (const api_key of singleVal.requestApiKey) {
                        if (api_key === apiKey) {
                            keyValue = singleVal.value;
                            success = true;
                        }
                    }
                }
                else if (type === 'response') {
                    for (const api_key of singleVal.responseApiKey) {
                        if (api_key === apiKey) {
                            keyValue = singleVal.value;
                            success = true;
                        }
                    }
                }
                else {
                    if (apiKey === singleVal.apiKey) {
                        keyValue = singleVal.value;
                        success = true;
                    }
                }
            }
        });
        if (success) {
            return keyValue;
        }
    }
    // getAppDataByApiKey(apiKey: string) {
    //     return this.appDataQuery.selectAll({
    //         filterBy: entity => entity.apiKey === apiKey
    //     });
    // }
    /**
     * returns the app data on the basis of api key and
     *  the type of the apiKey
     *
     * @param apiKey is the api key
     * @param type can be of two types ex. request or response
     */
    getAppDataByApiKey(apiKey, type) {
        let success = false;
        let appData;
        this.appDataQuery.selectAll().subscribe(val => {
            for (const singleVal of val) {
                if (type === 'request') {
                    for (const api_key of singleVal.requestApiKey) {
                        if (api_key === apiKey) {
                            appData = singleVal;
                            success = true;
                        }
                    }
                }
                else if (type === 'response') {
                    for (const api_key of singleVal.responseApiKey) {
                        if (api_key === apiKey) {
                            appData = singleVal;
                            success = true;
                        }
                    }
                }
                else {
                    if (apiKey === singleVal.apiKey) {
                        appData = singleVal;
                        success = true;
                    }
                }
            }
        });
        if (success) {
            return appData;
        }
    }
    removeDataFromStep(stepId, callback) {
        let loopEnded = false;
        try {
            this.appDataQuery.selectAll().subscribe(stepValues => {
                if (!loopEnded) {
                    for (const stepVal of stepValues) {
                        if (stepId === stepVal.stepId) {
                            // clear the session storage
                            this.apiDataService.deleteApiData(stepVal.apiKey);
                            this.deleteAppData(stepVal.id);
                        }
                        if (stepVal.linkedBlockId) {
                            // localStorage.removeItem(stepVal.linkedBlockId + '_count');
                            this.repetableBlockUtil.removeByBlockId(stepVal.linkedBlockId);
                        }
                    }
                    if (callback) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (error) {
            if (callback) {
                loopEnded = true;
                callback(false);
            }
        }
    }
    removeDataFromStepIds(stepIds, callback) {
        let loopEnded = false;
        try {
            this.appDataQuery.selectAll().subscribe(stepValues => {
                if (!loopEnded) {
                    for (const stepVal of stepValues) {
                        if (stepIds.includes(stepVal.stepId)) {
                            this.apiDataService.deleteApiData(stepVal.apiKey);
                            this.deleteAppData(stepVal.id);
                        }
                        if (stepVal.linkedBlockId) {
                            // localStorage.removeItem(stepVal.linkedBlockId + '_count');
                            this.repetableBlockUtil.removeByBlockId(stepVal.linkedBlockId);
                        }
                    }
                    if (callback && !loopEnded) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (e) {
            if (callback) {
                loopEnded = true;
                callback(false);
            }
        }
    }
    getDataFromStepIds(stepIds, callback) {
        let loopEnded = false;
        let mandatoryCheck = true;
        try {
            this.appDataQuery.selectAll().subscribe(stepValues => {
                if (!loopEnded) {
                    for (const stepVal of stepValues) {
                        if (stepIds.includes(stepVal.stepId)) {
                            if (stepVal.mandatory === true && stepVal.value === '') {
                                mandatoryCheck = false;
                                break;
                            }
                        }
                    }
                    if (callback) {
                        loopEnded = true;
                        callback(mandatoryCheck);
                    }
                }
            });
        }
        catch (e) {
            if (callback) {
                loopEnded = true;
                callback(false);
            }
        }
    }
    // removeDataUsingAPIKeys(apiKeys: Array<any>, callback: any) {
    //     let loopEnded = false;
    //     try {
    //         this.appDataQuery.selectAll().subscribe(apiKeyValues => {
    //             if (!loopEnded) {
    //                 for (const apiKeyVal of apiKeyValues) {
    //                     if (apiKeys.includes(apiKeyVal.apiKey)) {
    //                         this.apiDataService.deleteApiData(apiKeyVal.apiKey);
    //                         this.deleteAppData(apiKeyVal.id);
    //                     }
    //                 }
    //                 if (callback) {
    //                     loopEnded = true;
    //                     callback(true);
    //                 }
    //             }
    //         });
    //     } catch (error) {
    //         if (callback) {
    //             loopEnded = true;
    //             callback(true);
    //         }
    //     }
    // }
    /**
     * function to remove data for both request and response api keys
     * @param apiKeys
     * @param callback
     */
    removeDataUsingRequestAndResponseAPIKeys(apiKeys, callback) {
        let loopEnded = false;
        try {
            this.appDataQuery.selectAll().pipe(take(1)).subscribe(apiKeyValues => {
                if (!loopEnded) {
                    for (const apiKeyVal of apiKeyValues) {
                        for (const resApiKey of apiKeyVal.responseApiKey) {
                            if (apiKeys.includes(resApiKey)) {
                                this.apiDataService.deleteApiData(resApiKey);
                                this.deleteAppData(apiKeyVal.id);
                            }
                        }
                        for (const reqApiKey of apiKeyVal.requestApiKey) {
                            if (apiKeys.includes(reqApiKey)) {
                                this.apiDataService.deleteApiData(reqApiKey);
                                this.deleteAppData(apiKeyVal.id);
                            }
                        }
                    }
                    if (callback) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (error) {
            if (callback) {
                loopEnded = true;
                callback(true);
            }
        }
    }
    /**
     * function to remove data from either response or request api keys
     * @param apiKeys
     * @param callback
     */
    removeDataUsingAPIKeys(apiKeys, callback) {
        let loopEnded = false;
        try {
            this.appDataQuery.selectAll().subscribe(apiKeyValues => {
                const singleAPIKey = localStorage.getItem('singleApiKey') === 'true' ? true : false;
                if (!loopEnded) {
                    for (const apiKey of apiKeys) {
                        this.apiDataService.deleteApiData(apiKey);
                    }
                    for (const apiKeyVal of apiKeyValues) {
                        if (singleAPIKey) {
                            if (apiKeys.includes(apiKeyVal.apiKey)) {
                                this.deleteAppData(apiKeyVal.id);
                            }
                        }
                        else {
                            // remove from response api keys
                            for (const key of apiKeyVal.responseApiKey) {
                                if (apiKeys.includes(key)) {
                                    this.apiDataService.deleteApiData(key);
                                    if (apiKeyVal.responseApiKey.length === 1) {
                                        this.deleteAppData(apiKeyVal.id);
                                    }
                                    else {
                                        this.appDataStore.update(apiKeyVal.id, {
                                            ...apiKeyVal,
                                            ...{
                                                responseApiKey: apiKeyVal.responseApiKey.splice(apiKeyVal.responseApiKey.indexOf(key), 1)
                                            },
                                            ...{ updatedOn: (new Date()).getTime() }
                                        });
                                    }
                                }
                            }
                            // remove from request api keys
                            for (const key of apiKeyVal.requestApiKey) {
                                if (apiKeys.includes(key)) {
                                    this.apiDataService.deleteApiData(key);
                                    if (apiKeyVal.requestApiKey.length === 1) {
                                        this.deleteAppData(apiKeyVal.id);
                                    }
                                    else {
                                        this.appDataStore.update(apiKeyVal.id, {
                                            ...apiKeyVal,
                                            ...{
                                                requestApiKey: apiKeyVal.requestApiKey.splice(apiKeyVal.requestApiKey.indexOf(key), 1)
                                            },
                                            ...{ updatedOn: (new Date()).getTime() }
                                        });
                                    }
                                }
                            }
                        }
                    }
                    if (callback) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (error) {
            if (callback) {
                loopEnded = true;
                callback(true);
            }
        }
    }
    /**
     * function to check delete an api key that is under response api keys or
     * reuest api keys or simply api an api key
     * @param apiKey
     * @param type type can be of request or response or simply
     * @param callback
     */
    removeDataUsingAPIKey(apiKey, type = '', callback) {
        this.apiDataService.deleteApiData(apiKey);
        let loopEnded = false;
        try {
            this.appDataQuery.selectAll().subscribe(apiKeyValues => {
                if (!loopEnded) {
                    for (const apiKeyVal of apiKeyValues) {
                        if (type === 'request') {
                            if (apiKeyVal.requestApiKey.includes(apiKey)) {
                                this.apiDataService.deleteApiData(apiKey);
                                this.deleteAppData(apiKeyVal.id);
                            }
                        }
                        else if (type === 'response') {
                            if (apiKeyVal.responseApiKey.includes(apiKey)) {
                                this.apiDataService.deleteApiData(apiKey);
                                this.deleteAppData(apiKeyVal.id);
                            }
                        }
                        else {
                            if (apiKeyVal.apiKey === apiKey) {
                                this.apiDataService.deleteApiData(apiKey);
                                this.deleteAppData(apiKeyVal.id);
                            }
                        }
                    }
                    if (callback && !loopEnded) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (error) {
            if (callback) {
                loopEnded = true;
                callback(true);
            }
        }
    }
    removeDataUsingResponseAndRequestAPIKey(apiKey, callback) {
        this.apiDataService.deleteApiData(apiKey);
        let loopEnded = false;
        try {
            this.appDataQuery.selectAll().subscribe(apiKeyValues => {
                if (!loopEnded) {
                    for (const apiKeyVal of apiKeyValues) {
                        if (apiKeyVal.requestApiKey.includes(apiKey)) {
                            this.apiDataService.deleteApiData(apiKey);
                            this.deleteAppData(apiKeyVal.id);
                        }
                        if (apiKeyVal.responseApiKey.includes(apiKey)) {
                            this.apiDataService.deleteApiData(apiKey);
                            this.deleteAppData(apiKeyVal.id);
                        }
                    }
                    if (callback) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (error) {
            if (callback) {
                loopEnded = true;
                callback(true);
            }
        }
    }
    removeDataUsingUniqueIds(fieldIds, callback) {
        let loopEnded = false;
        try {
            this.appDataQuery.selectMany(fieldIds).subscribe(fieldValues => {
                if (!loopEnded) {
                    for (const fieldIdVal of fieldValues) {
                        if (fieldIds.includes(fieldIdVal.id)) {
                            this.appDataStore.remove(fieldIdVal.id);
                        }
                    }
                    if (callback) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (error) {
            if (callback) {
                loopEnded = true;
                callback(true);
            }
        }
    }
    removeDataUsingUniqueId(fieldId, callback) {
        let loopEnded = false;
        try {
            this.appDataQuery.selectAll({
                filterBy: entity => entity.id === fieldId
            }).subscribe(fieldValues => {
                if (!loopEnded) {
                    for (const apiKeyVal of fieldValues) {
                        this.appDataStore.remove(apiKeyVal.id);
                    }
                    if (callback) {
                        loopEnded = true;
                        callback(true);
                    }
                }
            });
        }
        catch (error) {
            if (callback) {
                loopEnded = true;
                callback(true);
            }
        }
    }
    clearDataUsingUniqueIds(fieldIds, callback) {
        // const data = this.appDataStore.getValue();
        const dataEnities = this.appDatacurrentValue['entities'];
        for (const entity in dataEnities) {
            if (fieldIds.includes(dataEnities[entity].id)) {
                const newData = { ...dataEnities[entity], ...{ value: '' } };
                this.updateAppData(newData);
            }
        }
        callback(true);
    }
    clearDataUsingApiKeys(apiKeys, callback) {
        // const data = this.appDataStore.getValue();
        const dataEnities = this.appDatacurrentValue['entities'];
        // tslint:disable-next-line: forin
        for (const entity in dataEnities) {
            if (apiKeys.includes(dataEnities[entity].apiKey)) {
                const newData = { ...dataEnities[entity], ...{ value: '' } };
                this.updateAppData(newData);
            }
            // should only work when using multiple api keys
            if (localStorage.getItem('singleApiKey') === 'false') {
                if (apiKeys.includes(this.apiKeyUtil.getMultipleApiKeys(this.apiKeyUtil.getConcatenatedApiKeys(dataEnities[entity].requestApiKey)))) {
                    const newData = { ...dataEnities[entity], ...{ value: '' } };
                    this.updateAppData(newData);
                }
                if (apiKeys.includes(this.apiKeyUtil.getMultipleApiKeys(dataEnities[entity].responseApiKey))) {
                    const newData = { ...dataEnities[entity], ...{ value: '' } };
                    this.updateAppData(newData);
                }
            }
        }
        callback(true);
    }
    listenForClearData() {
        this.logoutAllTabChannel.addEventListener('message', (event) => {
            if (event.data === 'redirectToLogoutTabs') {
                this.removeAllAppData();
            }
        });
    }
    static ɵfac = function AppDataService_Factory(t) { return new (t || AppDataService)(i0.ɵɵinject(AppDataStore), i0.ɵɵinject(AppDataQuery), i0.ɵɵinject(ApiDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AppDataService, factory: AppDataService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AppDataService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: AppDataStore }, { type: AppDataQuery }, { type: ApiDataService }], null); })();

class CeeApiService {
    http;
    appDataService;
    apiDataService;
    requestMappingData;
    configurationData;
    fileData;
    downloadData = false;
    downloadZip = false;
    environment = {};
    stepId = '';
    adminStepIds = [];
    flatUnflat;
    constructor(http, appDataService, apiDataService) {
        this.http = http;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.flatUnflat = new FlatUnflat(appDataService);
    }
    setStepId(id) {
        this.stepId = id;
    }
    ESBRequestHandler(url, body, apiConfig) {
        // HIT Service BUS API
        const requestBody = body;
        // console.log(requestBody);
        if (requestBody !== undefined) {
            requestBody['api_request'] =
                JSON.stringify(this.flatUnflat.createNestedObject(this.flatUnflat.createRequestBodyonStepBlockData(body, this.stepId)));
        }
        return this.http.post(localStorage.getItem('URL') + url, requestBody, {});
    }
    ExternalAPIHandler(apiConfig) {
        let appData = [];
        let apiData = [];
        const body = {};
        let methodType = '';
        // const requestType = 'application/json';
        const urlParams = [];
        const queryParams = [];
        const headerParams = [];
        let requestBody = [];
        // store the appData
        this.appDataService.getAllAppData().subscribe(res => {
            if (localStorage.getItem('singleApiKey') === 'true') {
                appData = res;
            }
            else {
                let finalArr = [];
                for (const data of res) {
                    let obj = {};
                    const arr = [];
                    for (const requestKey of data['requestApiKey']) {
                        obj = data;
                        obj = { ...obj, apiKey: requestKey };
                        arr.push(obj);
                    }
                    finalArr = [...finalArr, ...arr];
                }
                appData = finalArr;
            }
            // console.log('app Data', appData);
        });
        // store the apiData
        this.apiDataService.getAllApiData().subscribe(res => {
            // console.log('apiData', res);
            apiData = res;
        });
        for (const singleAppData of appData) {
            body[singleAppData.apiKey] = singleAppData.value;
        }
        for (const singleApiData of apiData) {
            body[singleApiData.apiKey] = singleApiData.value;
        }
        if (Object.keys(apiConfig).length > 0) {
            methodType = apiConfig['methodType'];
            if (apiConfig['urlParams'].length > 0) {
                for (const singleParam of apiConfig['urlParams']) {
                    urlParams.push(body[singleParam]);
                }
            }
            if (apiConfig['queryParams'].length > 0) {
                for (const singleParam of apiConfig['queryParams']) {
                    const obj = {};
                    obj[singleParam] = body[singleParam];
                    queryParams.push(obj);
                }
            }
            if (apiConfig['headerParams'].length > 0) {
                for (const singleParam of apiConfig['headerParams']) {
                    const obj = {};
                    obj[singleParam] = body[singleParam];
                    headerParams.push(obj);
                }
            }
            if (apiConfig['requestBody'].length > 0) {
                requestBody = apiConfig['requestBody'];
            }
        }
        else {
            methodType = 'POST';
        }
        return this.ceeApiService(apiConfig['url'], methodType, body, urlParams, queryParams, headerParams, requestBody);
    }
    /**
     * function returns teh formatted body if the requestBody key in the
     * api config object has a length > 0
     * @param bodyObj
     * @param apiConfigBodyArr
     */
    returnFormattedRequestBody(bodyObj, apiConfigBodyArr) {
        const flattendBody = this.flatUnflat.flattenJSON(bodyObj);
        let body = {};
        for (const singlekey of apiConfigBodyArr) {
            if (singlekey.includes('*')) {
                // console.log(singlekey);
                const matched = {};
                const regex = singlekey.replace('[*]', '\\[\\d+\\]');
                // tslint:disable-next-line: forin
                for (const key in flattendBody) {
                    const result = key.match(new RegExp(regex));
                    if (result) {
                        matched[key] = flattendBody[key];
                    }
                }
                body = { ...body, ...matched };
            }
            else {
                if (flattendBody.hasOwnProperty(singlekey)) {
                    body[singlekey] = flattendBody[singlekey];
                }
            }
        }
        return this.flatUnflat.createNestedObject(body);
    }
    /**
     * function that will hit the api
     * Note: for now only application/json type is supported
     */
    ceeApiService(url, method, body, urlParams, queryParams, headerParams, apiConfigRequestBody) {
        const URLParam = urlParams.length > 0 ? urlParams.join('/') : '';
        const queryParam = queryParams.map((key) => {
            return Object.keys(key).map(data => {
                return data + '=' + key[data];
            })[0];
        }).join('&');
        let headers = new HttpHeaders();
        headers = headers.append('Content-Type', 'application/json');
        headerParams.forEach(key => {
            Object.keys(key).forEach(data => {
                headers = headers.append(data, key[data]);
            });
        });
        switch (method) {
            case 'POST':
                return this.http.post(url +
                    (URLParam ? '/' + URLParam : '') +
                    (queryParam ? '?' + queryParam : ''), apiConfigRequestBody.length > 0 ? this.returnFormattedRequestBody(body, apiConfigRequestBody) : body, { headers, observe: 'response' });
            case 'PUT':
                return this.http.put(url +
                    (URLParam ? '/' + URLParam : '') +
                    (queryParam ? '?' + queryParam : ''), apiConfigRequestBody.length > 0 ? this.returnFormattedRequestBody(body, apiConfigRequestBody) : body, { headers, observe: 'response' });
            case 'GET':
                return this.http.get(url +
                    (URLParam ? '/' + URLParam : '') +
                    (queryParam ? '?' + queryParam : ''), { headers, observe: 'response' });
            case 'PATCH':
                return this.http.patch(url +
                    (URLParam ? '/' + URLParam : '') +
                    (queryParam ? '?' + queryParam : ''), apiConfigRequestBody.length > 0 ? this.returnFormattedRequestBody(body, apiConfigRequestBody) : body, { headers, observe: 'response' });
            case 'DELETE':
                return this.http.delete(url +
                    (URLParam ? '/' + URLParam : '') +
                    (queryParam ? '?' + queryParam : ''), { headers, observe: 'response' });
        }
    }
    static ɵfac = function CeeApiService_Factory(t) { return new (t || CeeApiService)(i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(AppDataService), i0.ɵɵinject(ApiDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CeeApiService, factory: CeeApiService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CeeApiService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: i9.HttpClient }, { type: AppDataService }, { type: ApiDataService }], null); })();

class ApplicationStateStoreUtil {
    appDataService;
    appData = {
        id: '',
        stepId: '',
        apiKey: '',
        requestApiKey: [],
        responseApiKey: [],
        mandatory: false,
        editable: false,
        visible: false,
        value: '',
        isValid: true
    };
    apiKeyUtil;
    constructor(appDataService) {
        this.appDataService = appDataService;
        this.apiKeyUtil = new APIKeyUtil();
    }
    setState(stepId, type, progressBarId) {
        const stepMap = this.getStepMap(progressBarId) || {};
        stepMap[stepId] = type;
        this.setStepMap(progressBarId, stepMap);
    }
    /**
     * set any state
     * @param progressBarId
     * @param stepId
     * @param type
     */
    // do not use the function until and unless extremely required
    setAnyState(progressBarId, stepId, type) {
        this.setState(stepId, type, progressBarId);
    }
    /**
     * function that sets progress bar
     * @param progressBarId
     * @param stepId
     */
    setProgressStatusOnLastSavedState(progressBarId, stepId, progressBarMap) {
        const stepMap = this.getStepMap(progressBarId) || {};
        // stepMap[stepId] = type;
        if (stepMap) {
            const stepIds = progressBarMap.steps.filter(stepData => stepData.tid === stepId)[0];
            if (stepIds) {
                const stepIndex = progressBarMap.steps.indexOf(stepIds);
                if (stepIndex !== -1) {
                    progressBarMap.steps.forEach((value, index) => {
                        if (index <= stepIndex) {
                            stepMap[value.tid] = 'STATE_COMPLETE';
                        }
                        else {
                            stepMap[value.tid] = 'STATE_PENDING';
                        }
                    });
                    this.setStepMap(progressBarId, stepMap);
                }
            }
        }
    }
    /**
     * set active state active to a step in progress bar
     * @param progressBarId
     * @param stepId
     */
    setActive(progressBarId, stepId) {
        this.setState(stepId, 'STATE_ACTIVE', progressBarId);
    }
    /**
     * set active state active to a step in progress bar
     * @param progressBarId
     * @param stepId
     */
    setPending(progressBarId, stepId) {
        this.setState(stepId, 'STATE_PENDING', progressBarId);
    }
    /**
     * set active state incomplete to a step in progress bar
     * @param progressBarId
     * @param stepId
     */
    setIncomplete(progressBarId, stepId) {
        this.setState(stepId, 'STATE_INCOMPLETE', progressBarId);
    }
    /**
     * set active state complete to a step in progress bar
     * @param progressBarId
     * @param stepId
     */
    setComplete(progressBarId, stepId) {
        this.setState(stepId, 'STATE_COMPLETE', progressBarId);
    }
    /**
     * get current step state
     * @param progressBarId
     * @param stepId
     */
    getStepState(progressBarId, stepId) {
        const stepMap = this.getStepMap(progressBarId) || {};
        return stepMap[stepId];
    }
    /**
     * set active state pending to a step in progress bar
     * @param progressBlock
     * @param stepId
     */
    setDefaultState(progressBlock, stepId) {
        const { progress_bar_id, request_api_key, response_api_key, api_key } = progressBlock;
        const stepMap = this.getStepMap(progress_bar_id) || {};
        if (Object.keys(stepMap).length !== 0) {
            if (!stepMap[stepId]) {
                stepMap[stepId] = 'STATE_PENDING';
            }
        }
        else {
            const obj = {
                id: progress_bar_id,
                responseApiKey: this.apiKeyUtil.getMultipleApiKeys(response_api_key),
                requestApiKey: this.apiKeyUtil.getMultipleApiKeys(request_api_key),
                apiKey: api_key
            };
            this.appDataService.setAppData({ ...this.appData, ...obj });
            stepMap[stepId] = 'STATE_PENDING';
        }
        this.setStepMap(progress_bar_id, stepMap);
    }
    /**
     * set state value set to a progress bar
     * @param progressBarId
     * @param value
     */
    setStateValue(progressBarId, value) {
        this.setStepMap(progressBarId, value);
    }
    setStepMap(progressBarId, obj) {
        // window.sessionStorage.setItem('state-map', JSON.stringify(obj));
        // window.sessionStorage.setItem('state-map', btoa(JSON.stringify(obj)));
        this.appDataService.getAppDataByFieldId(progressBarId).pipe(take(1))
            .subscribe(val => {
            this.appDataService.updateAppData(Object.assign({}, val, { value: btoa(JSON.stringify(obj)) }));
        });
    }
    getStepMap(progressBarId) {
        const data = this.appDataService.getFieldDataByFieldId(progressBarId);
        // const data = window.sessionStorage.getItem('state-map');
        if (data) {
            // return JSON.parse(data);
            return JSON.parse(atob(data));
        }
        else {
            return undefined;
        }
    }
    static ɵfac = function ApplicationStateStoreUtil_Factory(t) { return new (t || ApplicationStateStoreUtil)(i0.ɵɵinject(AppDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ApplicationStateStoreUtil, factory: ApplicationStateStoreUtil.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ApplicationStateStoreUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], () => [{ type: AppDataService }], null); })();

class SetAPICallbackData {
    apiDataService;
    appDataService;
    apiKeyUtil;
    flatAndNestUtil;
    commonUtil;
    constructor(apiDataService, appDataService) {
        this.apiDataService = apiDataService;
        this.appDataService = appDataService;
        this.apiKeyUtil = new APIKeyUtil();
        this.flatAndNestUtil = new FlatUnflat(appDataService);
        this.commonUtil = new CommonUtil();
    }
    // TODO : Handle when data is undefined
    setApiCallBackData(fieldData, data) {
        let apiData;
        if (data) {
            if (typeof (fieldData) === 'string' || (this.isSingleApiKey && fieldData.api_key)) {
                const apiKey = typeof (fieldData) === 'string' ? fieldData : fieldData.api_key;
                if (this.isHashedApiKey) {
                    // this will only work if hashed api key is set and that is set if the api_type in app_config.json is
                    // set to EXTERNAL or INTERNAL
                    apiData = apiKey && apiKey.includes('##') ?
                        this.commonUtil.getHandlerName(apiKey) === data.handler_name ?
                            this.getAPIData(data, apiKey) : undefined : this.getAPIData(data, apiKey);
                }
                else {
                    apiData = data[apiKey];
                }
            }
            else if (fieldData && fieldData.response_api_key) {
                // TODO: check the functionality
                // check for the api key first
                if (fieldData.response_api_key.includes('|')) {
                    // set multiple field values
                    const apiKeys = this.apiKeyUtil.getMultipleApiKeys(this.apiKeyUtil.getConcatenatedApiKeys(fieldData.response_api_key));
                    for (const key of apiKeys) {
                        if (key.includes('+')) {
                            let value;
                            const keys = key.split('+');
                            for (const singleKey of keys) {
                                let isHashed = false;
                                isHashed = singleKey.includes('##') ?
                                    this.commonUtil.getHandlerName(singleKey) === data.handler_name ? true : false : true;
                                if (isHashed) {
                                    value = keys.indexOf(singleKey) === 0 ?
                                        this.getAPIData(data, singleKey) :
                                        value + ' ' + this.getAPIData(data, singleKey);
                                }
                            }
                            apiData = value;
                        }
                        else {
                            const getAPIValue = key.includes('##') ?
                                (this.commonUtil.getHandlerName(key) === data.handler_name) ? this.getAPIData(data, key) :
                                    undefined : this.getAPIData(data, key);
                            if (getAPIValue !== undefined) {
                                apiData = getAPIValue;
                            }
                        }
                    }
                }
                else {
                    const getAPIValue = fieldData.response_api_key.includes('##') ?
                        ((this.commonUtil.getHandlerName(fieldData.response_api_key) === data.handler_name) ?
                            this.getAPIData(data, fieldData.response_api_key) :
                            undefined) : this.getAPIData(data, fieldData.response_api_key);
                    if (getAPIValue !== undefined) {
                        apiData = getAPIValue;
                    }
                }
            }
        }
        if (fieldData && fieldData.additional_parameters) {
            const checkSkipBlankAPiField = fieldData.additional_parameters.find(i => i.parameter_type === 'skip_blank_api_data' && i.value === 'true');
            if (checkSkipBlankAPiField && !apiData) {
                const defaultValue = fieldData.additional_parameters.find(i => i.parameter_type === 'default_value');
                if (defaultValue) {
                    apiData = defaultValue.value;
                }
            }
        }
        if (apiData !== undefined) {
            return apiData;
        }
        else {
            return null;
        }
    }
    /**
     * function that returns the value according to the api key
     * @param data the data from the api
     * @param apiKey the key from where the data is retrieved
     */
    getAPIData(data, apiKey) {
        if (data[apiKey] || this.isSingleApiKey) {
            return (data[apiKey]);
        }
        else {
            if (apiKey.includes('[*]')) {
                const arr = apiKey.split('[*]');
                if (arr[1] !== '') {
                    const regex = apiKey.replaceAll('[', '\\[').replaceAll(']', '\\]').replaceAll('\\[*\\]', '\\[\\d+\\]');
                    const array = [];
                    for (const key of Object.keys(data)) {
                        const result = key.match(new RegExp(regex));
                        const lastKey = key && key.includes('.') && key.split('.').length > 0 ? key.split('.')[key.split('.').length - 1] : key;
                        const lastRegex = regex && regex.includes('.') && regex.split('.').length > 0 ? regex.split('.')[regex.split('.').length - 1] : regex;
                        if (result && lastKey == lastRegex) {
                            array.push(data[result[0]]);
                        }
                    }
                    return (array.length <= 0 ? undefined : array);
                }
                else {
                    return (this.getArrayWithIndex(data, arr[0]));
                }
            }
            else {
                return (this.getArrayWithIndex(data, apiKey));
            }
        }
    }
    getArrayWithIndex(apiData, apiKey) {
        try {
            let result = this.flatAndNestUtil.createNestedObject(apiData);
            const arr = apiKey.split('.');
            let data;
            for (const singleKey of arr) {
                const regex = singleKey.match(new RegExp(/(?:\[)(\d+)(?:\])/g));
                if (regex) {
                    // const index = Number(regex.slice(1, (regex.length - 1)).join());
                    const index = Number(regex[0].replace('[', '').replace(']', ''));
                    data = arr.indexOf(singleKey) === 0
                        ? typeof (result) === 'object' ? result[singleKey.split(regex.join(''))[0]][index] : result[index]
                        : result[singleKey.split(regex.join(''))[0]][index];
                }
                else {
                    data = result[singleKey];
                }
                result = data;
            }
            return data;
        }
        catch (error) {
            return undefined;
        }
    }
    /**
     * function the data in the api store using the handler name
     * @param keyName can be a string
     */
    returnValueFromApiStoreUsingHandlerName(keyName) {
        const handlerValue = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(keyName)) ?
            this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(keyName)).value : {};
        return handlerValue;
    }
    // all getter setters goes here
    get isSingleApiKey() {
        return localStorage.getItem('singleApiKey') === 'true' ? true : false;
    }
    get isHashedApiKey() {
        return localStorage.getItem('hash_api_key') === 'true' ? true : false;
    }
    static ɵfac = function SetAPICallbackData_Factory(t) { return new (t || SetAPICallbackData)(i0.ɵɵinject(ApiDataService), i0.ɵɵinject(AppDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: SetAPICallbackData, factory: SetAPICallbackData.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SetAPICallbackData, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], () => [{ type: ApiDataService }, { type: AppDataService }], null); })();

class LoaderService {
    skipLoading = false;
    loadingStack = 0;
    isLoading = new BehaviorSubject(false);
    loader = this.isLoading.asObservable();
    loadingTextSet = new BehaviorSubject('');
    loadingTextGet = this.loadingTextSet.asObservable();
    isLoading$ = new BehaviorSubject(false);
    constructor() { }
    static ɵfac = function LoaderService_Factory(t) { return new (t || LoaderService)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: LoaderService, factory: LoaderService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LoaderService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [], null); })();

class WfeStepLoaderService {
    http;
    ceeInitService;
    apiDataService;
    appDataService;
    loaderService;
    sharedEventsService;
    toastr;
    globalPath = localStorage.getItem('ENABLE_AUTO_PREVIEW')?.toLowerCase() == "true" && localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') ? localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') : 'assets/config';
    fieldIdMapBasePath = '/wfe_unique_id.json';
    configBasePath = '/base_wfe.json?hash=' + Date.now();
    configApplicationPath = '/application_step/application_step_';
    configBlockPath = '/application_blocks/application_blocks_';
    customErrorMessages;
    progressBarMap = {};
    progressBarSequenceMap = {};
    userRoleDataMap = [];
    sequenceDataMap = [];
    messagesDataMap = {};
    menuDataMap = [];
    additionalParameters = {};
    stepNameAndIdDataMap = {};
    // blockNameAndIdDataMap: any[] = [];
    stepData = {};
    fieldStepData = {};
    blocksData = [];
    baseJSONData; // can also be declared {} but to check undefined it is undeclared
    currentSequenceId = '';
    currentSequencePointer = 0;
    applicationStateStoreUtil;
    defaultLang = '';
    rootData;
    lastStepRootData;
    stepDataStore = {};
    blockDataStore = {};
    setAPIKeyUtil;
    commonUtil;
    constructor(http, ceeInitService, apiDataService, appDataService, loaderService, sharedEventsService, toastr) {
        this.http = http;
        this.ceeInitService = ceeInitService;
        this.apiDataService = apiDataService;
        this.appDataService = appDataService;
        this.loaderService = loaderService;
        this.sharedEventsService = sharedEventsService;
        this.toastr = toastr;
        this.applicationStateStoreUtil = new ApplicationStateStoreUtil(this.appDataService);
        this.defaultLang = window.localStorage.getItem('lang') || '';
        if (!this.defaultLang && window.localStorage.getItem('defaultLang')) {
            this.defaultLang = '/' + window.localStorage.getItem('defaultLang');
        }
        this.setAPIKeyUtil = new SetAPICallbackData(apiDataService);
        this.commonUtil = new CommonUtil();
    }
    processBaseJSON(data) {
        if (data) {
            const obj = {};
            const navigateStepNameOnly = localStorage.getItem('navigateStepNameOnly') === 'true' ? true : false;
            for (const sequence of data.workflow_sequence) {
                this.sequenceDataMap[sequence.sequence_id] = sequence;
                for (const step of sequence.sequence) {
                    this.stepNameAndIdDataMap[step.name] = step.tid;
                    if (navigateStepNameOnly) {
                        obj[step.tid] =
                            step.name.toLowerCase().replace(/[^a-zA-Z ]/g, '').split(' ').join('-');
                    }
                    else {
                        obj[step.tid] =
                            step.name.toLowerCase().replace(/[^a-zA-Z ]/g, '').split(' ').join('-') + '-' + step.tid;
                    }
                }
                // for the progress bar
                if (sequence.progress_bar_id) {
                    if (data.progress_block) {
                        for (const progressBlock of data.progress_block) {
                            if (progressBlock.progress_bar_id === sequence.progress_bar_id) {
                                const stepMap = sequence.sequence.map(step => {
                                    this.applicationStateStoreUtil.setDefaultState(progressBlock, step.tid);
                                    return step;
                                });
                                this.progressBarMap[sequence.sequence_id] = { steps: stepMap };
                                this.progressBarMap[sequence.sequence_id].progress = progressBlock;
                            }
                        }
                    }
                }
            }
            localStorage.setItem('modals', JSON.stringify(data.modals));
            localStorage.setItem('CEE_ROUTE_MAP', JSON.stringify(obj));
            for (const message of data.constant_text.error_message) {
                if (message && typeof message.message_text === 'string' && message.message_text.includes('%')) {
                    message.message_text = this.extractAPIKeyValue(message).trim() === '' ? message.message_text : this.extractAPIKeyValue(message);
                }
                this.messagesDataMap[message.message_code] = message;
            }
            this.sharedEventsService.emitApiSuccessResponse.subscribe(res => {
                this.setDynamicMessage(res);
            });
            if ((data.application_menu && data.application_menu !== null) ||
                (data.application_menu && data.application_menu.toLowerCase() !== 'null')) {
                for (const menu of data.application_menu) {
                    this.menuDataMap[menu.menu_id] = menu;
                }
            }
            for (const role of data.user_roles) {
                this.userRoleDataMap[role.role] = role.workflow_sequence_ids;
            }
            /**
             * load bootstrap settings
             */
            if (data['application_settings']) {
                const storeData = ['is_bootstrap', 'container_type', 'is_material'];
                for (const sData of storeData) {
                    localStorage.setItem(sData, data['application_settings'][sData] || '');
                }
            }
            if (data['socket_settings']) {
                data['socket_settings'] = this.commonUtil.setAppConfigValue(data['socket_settings']);
                localStorage.setItem('socket_settings', JSON.stringify(data['socket_settings']) || '{}');
            }
        }
    }
    /**
     * the api data that is set to dynamic message
     * @param data then api call back data
     */
    setDynamicMessage(data) {
        for (const messagesData in this.messagesDataMap) {
            const m = this.messagesDataMap[messagesData];
            if (m.type.toLowerCase() === 'dynamic') {
                if (!m.message_text_config) {
                    m.message_text_config = m.message_text;
                }
                else {
                    m.message_text = m.message_text_config;
                }
                const keys = m.message_text.match(new RegExp(/\%(.*?)\%/g));
                if (keys && keys.length > 0) {
                    keys.forEach((apiKey, i) => {
                        apiKey = apiKey.split('%')[1];
                        let keyValue = this.returnKeyValue(apiKey.trim(), data);
                        m.message_text = m.message_text.replace('%' + apiKey + '%', keyValue !== undefined ? keyValue : '');
                    });
                }
            }
        }
        // console.log(this.messagesDataMap)
    }
    extractAPIKeyValue(message) {
        const keys = message.message_text.match(new RegExp(/\%(.*?)\%/g));
        var apiValue = '';
        if (keys && keys.length > 0) {
            keys.forEach((apiKey, i) => {
                apiKey = apiKey.split('%')[1];
                const handlerData = this.apiDataService.getApiDataByHandler(apiKey.split('##')[0]);
                if (handlerData != null) {
                    const extractValue = handlerData.value[apiKey];
                    apiValue = message.message_text.replace('%' + apiKey + '%', extractValue);
                    return apiValue;
                }
            });
        }
        return apiValue;
    }
    /**
     * the api key that is set to dynamic
     * @param apiKey the api key string
     * @param data then api call back data
     */
    returnKeyValue(apiKey, data) {
        return this.setAPIKeyUtil.isSingleApiKey || this.setAPIKeyUtil.setApiCallBackData(apiKey, data) !== null ?
            this.setAPIKeyUtil.setApiCallBackData(apiKey, data) : this.setAPIKeyUtil.setApiCallBackData(apiKey, this.setAPIKeyUtil.returnValueFromApiStoreUsingHandlerName(apiKey)) !== null ? this.setAPIKeyUtil.setApiCallBackData(apiKey, this.setAPIKeyUtil.returnValueFromApiStoreUsingHandlerName(apiKey)) : '';
    }
    reloadPage() {
        window.location.reload();
    }
    /**
     * pre fetch the base wfe json so that it gets loaded once when a step is loaded
     * and the additional parameters get mapped before the step is loaded
     */
    async prefetchBaseJSON() {
        if (!this.baseJSONData) {
            this.baseJSONData = await this.http.get(`${this.globalPath}${this.defaultLang}${this.configBasePath}`).toPromise();
            //config JSON version update process
            if (this.baseJSONData && this.baseJSONData['version_id']) {
                const configJSONVersion = this.baseJSONData['version_id'] + '';
                const configJSONVersionOld = localStorage.getItem('CONFIG_JSON_VERSION');
                let reloadFlag = false;
                if (configJSONVersion && configJSONVersionOld && configJSONVersion !== configJSONVersionOld) {
                    localStorage.clear();
                    sessionStorage.clear();
                    reloadFlag = true;
                }
                configJSONVersion && localStorage.setItem('CONFIG_JSON_VERSION', configJSONVersion);
                if (reloadFlag) {
                    this.reloadPage();
                }
            }
            this.setAdditionalParameters(this.baseJSONData.additional_parameters || []);
        }
        else {
            if (window.sessionStorage.length === 0) {
                this.setAdditionalParameters(this.baseJSONData.additional_parameters || []);
            }
        }
        this.processBaseJSON(this.baseJSONData);
        return;
    }
    getDefaultStep(sequence_id = '') {
        let defaultStep = null;
        if (this.baseJSONData) {
            if (this.baseJSONData.workflow_sequence) {
                const sequenceData = this.baseJSONData.workflow_sequence.find((i) => {
                    if (i.sequence.length > 0 && (!sequence_id || i.sequence_id === sequence_id)) {
                        return true;
                    }
                    else {
                        return false;
                    }
                });
                const navigateStepNameOnly = localStorage.getItem('navigateStepNameOnly') === 'true' ? true : false;
                if (sequenceData) {
                    const { name, tid } = sequenceData.sequence[0];
                    if (navigateStepNameOnly) {
                        defaultStep = {
                            tid,
                            stepName: name.toLowerCase().replace(/[^a-zA-Z ]/g, '').split(' ').join('-')
                        };
                    }
                    else {
                        defaultStep = {
                            tid,
                            stepName: name.toLowerCase().replace(/[^a-zA-Z ]/g, '').split(' ').join('-') + '-' + tid
                        };
                    }
                }
            }
        }
        return defaultStep;
    }
    /**
     * Load step configuration and supporting information
     * @param roleId: string
     * @param stepId: string
     * @param callback: string
     */
    getWFEStepData(roleId, stepId, callback) {
        try {
            this.stepData = {};
            const initCalls = [];
            // const sId = stepId.match(/[0-9]+$/g);
            // stepId = sId[0] ? sId[0] : stepId;
            // if custom Error Messages is undefined then assign the custom error messages from ceeInit service
            if (!this.customErrorMessages) {
                this.customErrorMessages = this.ceeInitService.customErrors;
            }
            initCalls.push(this.http.get(`${this.globalPath}${this.defaultLang}${this.configApplicationPath}${stepId}.json`));
            if (this.sequenceDataMap.length === 0) {
                if (!this.baseJSONData) {
                    initCalls.push(this.http.get(this.configBasePath));
                }
            }
            forkJoin(initCalls).subscribe((results) => {
                if (this.baseJSONData) {
                    results.push(this.baseJSONData);
                }
                this.mapData(roleId, results, callback);
            }, errors => {
                console.error(errors);
                if (callback) {
                    callback(undefined, 'An error occurred while loading page.');
                }
            });
        }
        catch (e) {
            console.error(e);
            if (callback) {
                callback(undefined, 'An error occurred while loading page.');
            }
        }
    }
    /**
     * Get user step access information based on role id.
     * @param roleId: string
     * @param stepData: any
     * @param blocksData: any
     * @param callback: any
     */
    checkUserRoleAccess(roleId, stepData, callback) {
        try {
            const roleArr = this.baseJSONData.user_roles.map((i) => {
                return i.role;
            });
            let anonymousCount = 0;
            const sequenceData = [];
            for (const roleName of roleId.split(',')) {
                if (this.userRoleDataMap[(roleName === '' || roleName === null) ? 'ANONYMOUS' : roleName]) {
                    const sequences = this.userRoleDataMap[(roleName === '' || roleName === null) ? 'ANONYMOUS' : roleName] ||
                        this.userRoleDataMap['ANONYMOUS'];
                    sequenceData.push(...sequences);
                }
                if (roleArr.includes(roleName)) {
                    anonymousCount += 1;
                }
            }
            if (roleId.length > 0 && roleArr.includes('AUTHENTICATED')) {
                const sequences = this.userRoleDataMap['AUTHENTICATED'];
                sequenceData.push(...sequences);
                anonymousCount += 1;
            }
            if (anonymousCount == 0) {
                const sequences = this.userRoleDataMap['ANONYMOUS'];
                sequenceData.push(...sequences);
            }
            if (sequenceData.length > 0) {
                if (this.getAllStepIdFromSequenceArray(sequenceData).includes(stepData.tid)) {
                    if (callback) {
                        callback(stepData, undefined);
                    }
                }
                else {
                    if (callback) {
                        callback(undefined, 'No step found for the given user role.');
                    }
                }
            }
            else {
                if (callback) {
                    callback(undefined, 'Invalid user role definition.');
                }
            }
        }
        catch (e) {
            console.error(e);
            if (callback) {
                callback(undefined, 'An error occured while loading page.');
            }
        }
    }
    /**
     * Get default step by user role id.
     * @param roleId: string
     */
    getDefaultStepByRole(roleId) {
        try {
            const roleArr = this.baseJSONData.user_roles.map((i) => {
                return i.role;
            });
            let anonymousCount = 0;
            const sequenceData = [];
            for (const roleName of roleId.split(',')) {
                if (this.userRoleDataMap[(roleName === '' || roleName === null) ? 'ANONYMOUS' : roleName]) {
                    const sequences = this.userRoleDataMap[(roleName === '' || roleName === null) ? 'ANONYMOUS' : roleName] ||
                        this.userRoleDataMap['ANONYMOUS'];
                    sequenceData.push(...sequences);
                }
                if (roleArr.includes(roleName)) {
                    anonymousCount += 1;
                }
            }
            if (roleId.length > 0 && roleArr.includes('AUTHENTICATED')) {
                const sequences = this.userRoleDataMap['AUTHENTICATED'];
                sequenceData.push(...sequences);
                anonymousCount += 1;
            }
            if (anonymousCount == 0) {
                const sequences = this.userRoleDataMap['ANONYMOUS'];
                sequenceData.push(...sequences);
            }
            return this.getDefaultStep(sequenceData[0][0]);
        }
        catch (e) {
            console.error(e);
            return '';
        }
    }
    /**
     * Map base.json data for access.
     * @param roleId : User role ID
     * @param stepData : WFE Step data
     * @param callback : Data loaded callback
     */
    mapData(roleId, stepData, callback) {
        try {
            this.processBaseJSON(stepData[1]);
            if (stepData[0]) {
                this.stepData = JSON.parse(JSON.stringify(stepData[0]));
                this.checkUserRoleAccess(roleId, this.stepData, callback);
            }
        }
        catch (e) {
            console.error(e);
            if (callback) {
                callback(undefined, 'An error occurred while loading page.');
            }
        }
    }
    /**
     * method loads a step when the function
     * is called based on the step Id
     * @param stepId: string
     */
    loadOnLangChange(stepId, lang) {
        const step = this.http.get(`${this.globalPath}${lang}${this.configApplicationPath}${stepId}.json`);
        const baseJSON = this.http.get(`${this.globalPath}${lang}${this.configBasePath}`);
        return forkJoin([step, baseJSON]);
    }
    setAdditionalParameters(additionalParameters) {
        // this.defaultLang = window.localStorage.getItem('lang') || '';
        for (const additionalParameter of additionalParameters) {
            let paramValue = additionalParameter.value ? additionalParameter.value : '';
            this.additionalParameters[additionalParameter.parameter_type] = paramValue;
            // TODO: uncomment if default Language is set as an additional parameter
            // set default language
            // if (additionalParameter.parameter_type === 'DefaultLanguage' && !this.defaultLang) {
            //     this.defaultLang = paramValue.toLowerCase();
            // }
            if (paramValue && paramValue.includes('$$')) {
                paramValue = paramValue.split('$$')[1].trim();
            }
            if (window.sessionStorage.getItem(additionalParameter.parameter_type) !== '') {
                window.sessionStorage.setItem(additionalParameter.parameter_type, paramValue);
            }
        }
        // if (this.defaultLang) {
        //     window.localStorage.setItem('lang', `${this.defaultLang}`);
        // }
    }
    getListOfStepIdsByWorkflow(workflowIds) {
        const stepIds = [];
        if (typeof workflowIds === 'string') {
            workflowIds = [workflowIds];
        }
        for (const workflowId of workflowIds) {
            if (this.sequenceDataMap[workflowId]) {
                for (const step of this.sequenceDataMap[workflowId].sequence) {
                    stepIds.push(step.tid);
                }
            }
        }
        return stepIds;
    }
    /**
     * function that sets the progress block step to pending
     * @param sequenceId the sequence id
     */
    setSequenceProgressInit(sequenceId) {
        if (this.progressBarMap) {
            const progressBar = this.progressBarMap[sequenceId];
            if (progressBar && progressBar.progress && progressBar.progress.progress_bar_id) {
                progressBar.steps.forEach(step => {
                    this.applicationStateStoreUtil.setAnyState(progressBar.progress.progress_bar_id, step.tid, 'STATE_PENDING');
                });
            }
        }
    }
    /**
     *
     * @param sequenceArray
     */
    getAllStepIdFromSequenceArray(sequenceArray) {
        const stepIdArray = [];
        for (const singleSequence of sequenceArray) {
            for (const sequence of this.sequenceDataMap[singleSequence]?.sequence) {
                stepIdArray.push(sequence.tid);
            }
        }
        return stepIdArray;
    }
    /**
     * Get messages based on message id
     * @param code
     */
    getMessage(code) {
        // TODO handle dynamic messages
        if (this.messagesDataMap[code]) {
            return this.messagesDataMap[code].message_text;
            // if (this.messagesDataMap[code].type.toLowerCase() === 'dynamic') {
            //     return this.messagesDataMap[code].message_text;
            // } else {
            //     return this.messagesDataMap[code].message_text;
            // }
        }
        else {
            return undefined;
        }
    }
    /**
     * Returns the whole WFE Base JSON Data
     */
    loadWFEUniqueIdJSON() {
        return this.http.get(`${this.globalPath}${this.defaultLang}${this.fieldIdMapBasePath}`);
    }
    /**
     * save the step data in cache
     * @param stepName
     */
    setStepDataInCache(stepName, data) {
        stepName = this.stepNameAndIdDataMap[stepName] ? this.stepNameAndIdDataMap[stepName] : stepName;
        this.stepDataStore[stepName] = JSON.stringify(data);
        // let stepData = localStorage.getItem('stepDataCache') ? JSON.parse(localStorage.getItem('stepDataCache'))['data'] : [];
        // let cacheData = ( stepData && stepData.length > 0 ) ? stepData.filter(el => el.step_id == stepName) : [];
        // if(cacheData && cacheData.length == 0) {
        //     stepData.push({step_id: stepName, step_data: data});
        //     localStorage.setItem('stepDataCache', JSON.stringify({data : stepData}))
        // }
    }
    /**
     * fetch the step data from cache
     * @param stepName
     */
    getStepDataFromCache(stepName) {
        stepName = this.stepNameAndIdDataMap[stepName] ? this.stepNameAndIdDataMap[stepName] : stepName;
        return this.stepDataStore[stepName] ? JSON.parse(this.stepDataStore[stepName]) : null;
        // let stepData;
        // let stepDataCache = localStorage.getItem('stepDataCache') ? JSON.parse(localStorage.getItem('stepDataCache'))['data'] : [];
        // let cacheData = ( stepDataCache && stepDataCache.length > 0 ) ? stepDataCache.filter(el => el.step_id == stepName) : [];
        // if(cacheData && cacheData.length > 0) {
        //     stepData = cacheData[0].step_data;
        // }
        // return stepData;
    }
    /**
     * Returns the step data according to the step name
     * @param stepName
     */
    loadStepByName(stepName) {
        if (!this.stepNameAndIdDataMap[stepName]) {
            console.error('Invalid step name: ' + stepName);
        }
        return new Observable((observer) => {
            // const stepDataCache = this.getStepDataFromCache(stepId);
            const stepId = this.stepNameAndIdDataMap[stepName];
            if (this.stepDataStore[stepId]) {
                observer.next(JSON.parse(this.stepDataStore[stepId]));
                observer.complete();
            }
            else {
                this.http.get(`${this.globalPath}${this.defaultLang}${this.configApplicationPath}${stepId}.json`).subscribe((currStepData) => {
                    this.stepDataStore[stepId] = JSON.stringify(currStepData);
                    observer.next(currStepData);
                    observer.complete();
                }, (error) => {
                    observer.error(error);
                    observer.complete();
                });
            }
            return {
                unsubscribe() { }
            };
        });
        // return this.http.get(
        //     `${this.globalPath}${this.defaultLang}${this.configApplicationPath}${this.stepNameAndIdDataMap[stepName]}.json`);
    }
    /**
     * Returns the step data according to the step name
     * @param stepId
     */
    loadStepById(stepId) {
        return new Observable((observer) => {
            const stepDataCache = this.getStepDataFromCache(stepId);
            if (stepDataCache) {
                observer.next(stepDataCache);
                observer.complete();
            }
            else {
                this.http.get(`${this.globalPath}${this.defaultLang}${this.configApplicationPath}${stepId}.json`).subscribe((currStepData) => {
                    this.setStepDataInCache(stepId, currStepData);
                    observer.next(currStepData);
                    observer.complete();
                }, (error) => {
                    observer.error(error);
                    observer.complete();
                });
            }
            return {
                unsubscribe() { }
            };
        });
        // return this.http.get(`${this.globalPath}${this.defaultLang}${this.configApplicationPath}${stepId}.json`);
    }
    /**
     * returns sequence name and index of the current step
     */
    getWorkflowSequenceIndexFromStep(stepId) {
        // tslint:disable-next-line: forin
        for (const sequence in this.sequenceDataMap) {
            for (const singleSequenceIndex in this.sequenceDataMap[sequence].sequence) {
                if (this.sequenceDataMap[sequence].sequence[singleSequenceIndex].tid === stepId) {
                    return { sequence, singleSequenceIndex };
                }
            }
        }
        return undefined;
    }
    getNextStepInCurrentSequence(currentStepId) {
        const sequenceData = this.getWorkflowSequenceIndexFromStep(currentStepId);
        if (sequenceData) {
            const { sequence, singleSequenceIndex } = sequenceData;
            if ((Number(singleSequenceIndex) + 1) < this.sequenceDataMap[sequence].sequence.length) {
                return this.sequenceDataMap[sequence].sequence[Number(singleSequenceIndex) + 1].tid;
            }
        }
        return null;
    }
    getPreviousStepInCurrentSequence(currentStepId) {
        const sequenceData = this.getWorkflowSequenceIndexFromStep(currentStepId);
        if (sequenceData) {
            const { sequence, singleSequenceIndex } = sequenceData;
            if (Number(singleSequenceIndex) !== 0) {
                return this.sequenceDataMap[sequence].sequence[Number(singleSequenceIndex) - 1].tid;
            }
        }
        return null;
    }
    ////////////////////// OLD Implementations ///////////////////////////
    getFirstSequenceInSequenceArray(sequenceArray) {
        if (sequenceArray.length > 0) {
            return this.sequenceDataMap[sequenceArray[0]].sequence[0].tid;
        }
        else {
            return '404';
        }
    }
    getFirstStepInSquence(stepArray) {
        return stepArray[0].tid;
    }
    getSequenceDefaultStepIdBySequenceId(sequenceId) {
        this.currentSequenceId = sequenceId;
        this.currentSequencePointer = 0;
        const selectedSeqData = this.sequenceDataMap[this.currentSequenceId];
        return selectedSeqData;
    }
    // getNextStepInCurrentSequence() {
    //   if (this.currentSequencePointer < (this.sequenceDataMap[this.currentSequenceId].sequence.length - 1)) {
    //     this.currentSequencePointer++;
    //   }
    //   return this.sequenceDataMap[this.currentSequenceId].sequence[this.currentSequencePointer].tid;
    // }
    // getPreviousStepInCurrentSequence() {
    //   if (this.currentSequencePointer > 0) {
    //     this.currentSequencePointer--;
    //   }
    //   return this.sequenceDataMap[this.currentSequenceId].sequence[this.currentSequencePointer].tid;
    // }
    /**
     * Returns the block data according to the block name
     * @param blockName
     */
    searchBlockDataFromCache(blockName) {
        return this.blockDataStore[blockName] ? JSON.parse(this.blockDataStore[blockName]) : null;
        // let blockData;
        // let blockDataCache = localStorage.getItem('blockDataCache') ? JSON.parse(localStorage.getItem('blockDataCache'))['data'] : [];
        // let cacheData = ( blockDataCache && blockDataCache.length > 0 ) ? blockDataCache.filter(el => el.block_id == blockName) : [];
        // if(cacheData && cacheData.length > 0) {
        //     blockData = cacheData[0].block_data;
        // }
        // return blockData;
    }
    /**
     * Returns the block data according to the block name
     * @param blockName
     */
    loadBlockByName(blockName) {
        return new Observable((observer) => {
            const blockDataCache = this.searchBlockDataFromCache(blockName);
            if (blockDataCache) {
                observer.next(blockDataCache);
                observer.complete();
            }
            else {
                this.http.get(`${this.globalPath}${this.defaultLang}${this.configBlockPath}${blockName}.json`).subscribe((currStepData) => {
                    this.setBlockDataInCache(blockName, currStepData);
                    observer.next(currStepData);
                    observer.complete();
                }, (error) => {
                    observer.error(error);
                    observer.complete();
                });
            }
            return {
                unsubscribe() { }
            };
        });
        // return this.http.get(
        // `${this.globalPath}${this.defaultLang}${this.configBlockPath}${blockName}.json`);
    }
    setBlockDataInCache(blockName, data) {
        this.blockDataStore[blockName] = JSON.stringify(data);
        // blockName = this.blockNameAndIdDataMap[blockName] ? this.blockNameAndIdDataMap[blockName] : blockName;
        // let blockData = localStorage.getItem('blockDataCache') ? JSON.parse(localStorage.getItem('blockDataCache'))['data'] : [];
        // let cacheData = ( blockData && blockData.length > 0 ) ? blockData.filter(el => el.step_id == blockName) : [];
        // if(cacheData && cacheData.length == 0) {
        //     blockData.push({block_id: blockName, block_data: data});
        //     localStorage.setItem('blockDataCache', JSON.stringify({data : blockData}))
        // }
    }
    // loadBlockByNameId(blockName) {
    //     return new Observable((observer) => {
    //         const blockDataCache = this.searchBlockDataFromCache(blockName);
    //         if (blockDataCache) {
    //             observer.next(blockDataCache);                  
    //             observer.complete();
    //         }
    //         else {
    //             this.http.get(`${this.globalPath}${this.defaultLang}${this.configBlockPath}${blockName}.json`).subscribe((currStepData: any) => {
    //                 this.setBlockDataInCache(blockName, currStepData);
    //                 observer.next(currStepData);                  
    //                 observer.complete();
    //             }, (error) => {
    //                 observer.error(error);                  
    //                 observer.complete();
    //             });
    //         }
    //         return {
    //             unsubscribe() { }
    //         };
    //     });
    // }
    /**
     * Returns workflow details from step id
     * @param stepId
     */
    getWorkflowDetails(stepId) {
        if (this.baseJSONData.workflow_sequence) {
            return this.baseJSONData.workflow_sequence.find((i) => {
                return i.sequence.findIndex((x) => {
                    return x.tid == stepId;
                }) > -1;
            });
        }
        return null;
    }
    openToster(msgObj) {
        this.toastr.success(msgObj.html, '', {
            enableHtml: true,
            timeOut: Number(msgObj.duration),
            closeButton: msgObj.closeButton,
            toastClass: msgObj.panelClass.join(' '),
            progressBar: msgObj.progressBar,
            positionClass: 'toast-' + msgObj.verticalPosition + '-' + msgObj.horizontalPosition
        });
    }
    manipulateString(type, value) {
        let fieldIds, separator, fieldValueList;
        if (!type)
            return value;
        switch (type.toLowerCase().split("||")[0]) {
            case "trim_spaces":
                value = value.trim();
                // this.inputValue = value;
                break;
            case "remove_all":
                let searchString = type.toLowerCase().split("||").length > 1 ? type.toLowerCase().split("||")[1] : " ";
                let replaceWith = type.toLowerCase().split("||").length > 2 ? type.toLowerCase().split("||")[2] : "";
                value = value.replaceAll(searchString, replaceWith);
                // this.inputValue = value;
                break;
            case "upper":
                value = value.toUpperCase();
                // this.inputValue = value;
                break;
            case "lower":
                value = value.toLowerCase();
                // this.inputValue = value;
                break;
            case "proper":
                const arr = value.split(" ");
                for (var i = 0; i < arr.length; i++) {
                    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
                }
                value = arr.join(" ");
                // this.inputValue = value;
                break;
            case "starts_with":
                let startWith = type.split("||").length > 1 ? type.split("||")[1] : "";
                value = value.trim() ? startWith + value.replaceAll(startWith, '') : '';
                // this.inputValue = value;
                break;
            case "concat":
                fieldIds = type.split("||").length > 1 ? type.split("||").slice(2) : [];
                separator = type.split("||").length > 1 ? type.split("||")[1] : " ";
                fieldValueList = [];
                fieldIds.forEach(element => {
                    fieldValueList.push(this.appDataService.getFieldDataByFieldId(element));
                });
                value = fieldValueList.join(separator);
                // this.inputValue = value;
                break;
            case "split":
                fieldIds = type.split("||").length > 1 ? type.split("||").slice(2) : [];
                separator = type.split("||").length > 1 ? type.split("||")[1] : " ";
                fieldValueList = value ? value.split(separator) : [];
                fieldIds.forEach((element, index) => {
                    this.appDataService.getIndividualAppData(element).pipe(take(1)).subscribe(fieldData => {
                        if (fieldData.length > 0) {
                            this.appDataService.updateAppData({ ...fieldData[0], ...{ value: fieldValueList[index] } });
                            this.sharedEventsService.emitSetFieldValueOnEvent.emit({ uniqueIds: element, values: fieldValueList[index] });
                        }
                    });
                });
                break;
        }
        return value;
    }
    static ɵfac = function WfeStepLoaderService_Factory(t) { return new (t || WfeStepLoaderService)(i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(CeeInitServiceService), i0.ɵɵinject(ApiDataService), i0.ɵɵinject(AppDataService), i0.ɵɵinject(LoaderService), i0.ɵɵinject(SharedEventsServiceService), i0.ɵɵinject(i7.ToastrService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WfeStepLoaderService, factory: WfeStepLoaderService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WfeStepLoaderService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: i9.HttpClient }, { type: CeeInitServiceService }, { type: ApiDataService }, { type: AppDataService }, { type: LoaderService }, { type: SharedEventsServiceService }, { type: i7.ToastrService }], null); })();

class LoaderInterceptorService {
    loaderService;
    sharedEventsServices;
    requests = [];
    configJSONVersion;
    skipJSONLoader;
    constructor(loaderService, sharedEventsServices) {
        this.loaderService = loaderService;
        this.sharedEventsServices = sharedEventsServices;
        this.configJSONVersion = localStorage.getItem('CONFIG_JSON_VERSION');
        this.skipJSONLoader = localStorage.getItem('SKIP_JSON_LOADER');
    }
    removeRequest(req) {
        const i = this.requests.indexOf(req);
        if (i >= 0) {
            this.requests.splice(i, 1);
            this.loaderService.loadingStack--;
        }
        if (this.loaderService.loadingStack > 0) {
            this.loaderService.isLoading.next(this.loaderService.loadingStack > 0);
        }
        else {
            setTimeout(() => {
                this.loaderService.isLoading.next(this.loaderService.loadingStack > 0);
            }, 2000);
        }
    }
    intercept(req, next) {
        const httpProgress = {
            uId: null,
            progress: null,
            complete: false
        };
        if (req.headers && typeof req.headers.get !== "undefined" && req.headers.get('uId')) {
            httpProgress.uId = req.headers.get('uId');
            if (httpProgress.uId) {
                req = req.clone({
                    headers: req.headers.delete('uId')
                });
            }
        }
        let skipValue;
        if (req.headers && typeof req.headers.get !== "undefined" && req.headers.get('skip')) {
            skipValue = req.headers.get('skip');
            if (skipValue) {
                req = req.clone({
                    headers: req.headers.delete('skip')
                });
            }
        }
        //skip loading for OIDC refresh_token
        if (req.body && typeof req.body.get !== "undefined" && req.body.get('grant_type') && req.body.get('grant_type') === 'refresh_token') {
            skipValue = 'true';
        }
        if (!this.configJSONVersion) {
            this.configJSONVersion = localStorage.getItem('CONFIG_JSON_VERSION');
        }
        let newReq;
        if (/\.json$/.test(req.url) && this.configJSONVersion) {
            newReq = req.clone({
                url: req.url + '?version=' + this.configJSONVersion,
            });
        }
        else {
            newReq = req.clone();
        }
        //Skip Loader for JSON file download
        if (!this.skipJSONLoader) {
            this.skipJSONLoader = localStorage.getItem('SKIP_JSON_LOADER');
        }
        if (this.skipJSONLoader && this.skipJSONLoader === 'true' && /\.json$/.test(req.url)) {
            skipValue = 'true';
        }
        if (skipValue !== 'true' && !this.loaderService.skipLoading) {
            this.requests.push(req);
            this.loaderService.loadingStack++;
            // console.log("No of requests--->" + this.requests.length);
            this.loaderService.isLoading.next(true);
            return new Observable(observer => {
                const subscription = next.handle(newReq)
                    .subscribe({
                    next: (event) => {
                        switch (event.type) {
                            case HttpEventType.Sent:
                                //Request has been made!
                                break;
                            case HttpEventType.ResponseHeader:
                                //Response header has been received!
                                break;
                            case HttpEventType.UploadProgress:
                                let progress = Math.round(event.loaded / event.total * 100);
                                httpProgress.progress = progress;
                                break;
                            case HttpEventType.Response:
                                this.removeRequest(req);
                                observer.next(event);
                                httpProgress.complete = true;
                                break;
                        }
                        this.sharedEventsServices.httpProgressEmitter.emit(httpProgress);
                    },
                    error: (err) => {
                        if (err) {
                            this.removeRequest(req);
                            observer.error(err);
                        }
                    },
                    complete: () => {
                        this.removeRequest(req);
                        observer.complete();
                    }
                });
                // remove request from queue when cancelled
                return () => {
                    this.removeRequest(req);
                    subscription.unsubscribe();
                };
            });
        }
        else {
            // console.log('in here');
            return next.handle(newReq);
        }
    }
    static ɵfac = function LoaderInterceptorService_Factory(t) { return new (t || LoaderInterceptorService)(i0.ɵɵinject(LoaderService), i0.ɵɵinject(SharedEventsServiceService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: LoaderInterceptorService, factory: LoaderInterceptorService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LoaderInterceptorService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], () => [{ type: LoaderService }, { type: SharedEventsServiceService }], null); })();

class ExternalRequestResponseUtil {
    http;
    appDataService;
    apiDataService;
    sharedEventsService;
    constructor(http, appDataService, apiDataService, sharedEventsService) {
        this.http = http;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.sharedEventsService = sharedEventsService;
        this.flatAndNestUtil = new FlatUnflat(appDataService);
        this.commonUtil = new CommonUtil();
    }
    flatAndNestUtil;
    apiConfig = {};
    commonUtil;
    externalApiRequest = {
        handler: '',
        headers: {},
        queryParams: {},
        urlParams: {},
        requestBody: {},
        primaryData: {}
    };
    internalApiRequest = {
        handler: '',
        headers: {},
        queryParams: {},
        urlParams: {},
        requestBody: {},
        url: '',
        methodType: '',
        requestType: '',
        isESB: false,
        hasAuthorisation: false,
        storageType: '',
        useUID: false,
        isEvent: false,
        downloadType: '',
        esbRequestBody: [],
        primaryData: {}
    };
    apiData = {
        id: '',
        apiKey: '',
        apiUrl: '',
        value: ''
    };
    booleanValues = {
        1: true,
        0: false,
        "true": true,
        "false": false
    };
    /**
     * this function prepares the object that needs to be sent to the project end
     * so that they can consume the headers, queryParams, urlParams and RequestBody
     * @required @param handler WFE Event handler
     * @param type The API calling type empty
     * @param isEvent If the function is triggered from an event
     * @param downloadType If the function is triggered from an event and is called from an download event
     */
    prepareObjectToBeSent(handler, type = '', isEvent = false, downloadType = '', encriptedFileData = [], primaryData = {}, tableOperations = '', tableOperationsBlock = '') {
        const handlerArr = handler.split('||');
        // console.log('handlerArr: ', handlerArr);
        // try {
        const apiConfig = JSON.parse(localStorage.getItem('API_CONFIG'));
        const apiConfigObject = apiConfig[handler.split('||')[0]];
        // ************ For Parallel API Integration *************
        const apiConfigObjectArr = [];
        handlerArr.forEach((handlerId) => {
            const config = apiConfig[handlerId];
            if (config) {
                apiConfigObjectArr.push(config);
            }
        });
        // console.log('apiConfigObjectArr: ', apiConfigObjectArr);
        // for (const config of apiConfig) {
        //     if (config.id === handler) {
        //         apiConfigObject = config;
        //         break;
        //     }
        // }
        if (!apiConfigObject || !apiConfigObjectArr || apiConfigObjectArr.length !== handlerArr.length) {
            console.log(`Error in Mapping ${handler}`);
            return false;
        }
        // check for use UID
        // if present add it in the request Body array
        if (window.sessionStorage.getItem('CEE_OIDC') === '1' && apiConfigObject.useUID && window.sessionStorage.getItem('CEE_Token')) {
            const splitData = window.sessionStorage.getItem('CEE_Token').split('##');
            let identificationTag = window.sessionStorage.getItem('CEE_SUB') || window.sessionStorage.getItem('CEE_PRN') || '';
            identificationTag = identificationTag.includes('$$') ? identificationTag.split('$$')[1] : identificationTag;
            apiConfigObject.requestBody.push(identificationTag);
            // ************ For Parallel API Integration *************
            apiConfigObjectArr.forEach((config) => {
                config.requestBody.push(identificationTag);
            });
            // console.log("apiConfigObjectArr identificationTag: ", apiConfigObjectArr);
        }
        const { requestBody, headers, queryParams, urlParams, url, methodType, requestType, isESB, hasAuthorisation, storageType, useUID, esbRequestBody } = this.formTheRequestObj(apiConfigObject, encriptedFileData, primaryData.type);
        // const requestBody = apiConfigObject.requestBody.length > 0 ? this.returnFormattedObject(apiConfigObject.requestBody) : {};
        // const headers = apiConfigObject.headerParams.length > 0 ?
        //     this.returnFormattedObject(apiConfigObject.headerParams) : {};
        // const queryParams = apiConfigObject.queryParams.length > 0 ?
        //     this.returnFormattedObject(apiConfigObject.queryParams) : {};
        // const urlParams = apiConfigObject.urlParams.length > 0 ?
        //     this.returnFormattedObject(apiConfigObject.urlParams) : {};
        if (type || window.sessionStorage.getItem('CEE_OIDC') === '1') {
            this.internalApiRequest = {
                handler,
                urlParams,
                headers,
                queryParams,
                requestBody,
                url,
                methodType,
                requestType,
                isESB,
                hasAuthorisation,
                storageType,
                useUID,
                isEvent,
                downloadType,
                esbRequestBody,
                primaryData
            };
            // ************ For Parallel API Integration *************
            var requestArr = [];
            apiConfigObjectArr.forEach((element, index) => {
                const { requestBody, headers, queryParams, urlParams, url, methodType, requestType, isESB, hasAuthorisation, storageType, useUID, esbRequestBody } = this.formTheRequestObj(element, encriptedFileData, primaryData.type);
                this.internalApiRequest = {
                    handler,
                    urlParams,
                    headers,
                    queryParams,
                    requestBody,
                    url,
                    methodType,
                    requestType,
                    isESB,
                    hasAuthorisation,
                    storageType,
                    useUID,
                    isEvent,
                    downloadType,
                    esbRequestBody,
                    primaryData
                };
                requestArr.push({
                    urlParams: element.urlParams,
                    headerParams: element.headerParams,
                    queryParams: element.queryParams,
                    requestBody: element.requestBody,
                    primaryData: primaryData,
                    url: element.url,
                    ...this.internalApiRequest,
                    handler: element.id
                });
            });
            // check if has CEE_OIDC is 1
            if (window.sessionStorage.getItem('CEE_OIDC') === '1') {
                if (apiConfigObjectArr.length > 1) { // For Parallel API Integration
                    this.sharedEventsService.apiIntegrationParallelEventHandlerEmitter.emit(requestArr);
                }
                else if (apiConfigObject.isExternal) {
                    this.externalApiRequest = {
                        handler,
                        urlParams,
                        headers,
                        queryParams,
                        requestBody,
                        primaryData
                    };
                    this.sharedEventsService.eventHandlerEmitter.emit(this.externalApiRequest);
                }
                else {
                    if ((tableOperations === "save" || tableOperations === "update") && tableOperationsBlock == "employment") {
                        this.internalApiRequest.requestBody = this.exployeeSaveBody(this.internalApiRequest, primaryData.value.position, primaryData.value.parentPosition);
                    }
                    if ((tableOperations === "save" || tableOperations === "update") && tableOperationsBlock == "living_address") {
                        this.internalApiRequest.requestBody = this.generateLivingAddressBody(this.internalApiRequest, primaryData.value.position);
                    }
                    if ((tableOperations === "save" || tableOperations === "update") && tableOperationsBlock == "income") {
                        this.internalApiRequest.requestBody = this.generateAdditionalIncomeBody(this.internalApiRequest, primaryData.value.position);
                    }
                    if ((tableOperations === "save" || tableOperations === "update") && tableOperationsBlock == "asset") {
                        this.internalApiRequest.requestBody = this.assetBody(this.internalApiRequest);
                    }
                    if ((tableOperations === "save" || tableOperations === "update") && tableOperationsBlock == "liabilities") {
                        this.internalApiRequest.requestBody = this.liabilityBody(this.internalApiRequest);
                    }
                    if ((tableOperations === "save" || tableOperations === "update") && (tableOperationsBlock == "properties" || tableOperationsBlock == "properties_mortgage")) {
                        this.internalApiRequest.requestBody = this.saveDealPropertiesBody(this.internalApiRequest);
                        if (tableOperations === "save") {
                            this.internalApiRequest.requestBody["data"]["mortgageData"] = [];
                        }
                        if (tableOperations === "update") {
                            // parentPosition
                            let propertyArr = this.getAkitaDataFromHandler("getFullDealDetails")['getFullDealDetails##data']['properties'];
                            let propertyPosition = this.internalApiRequest.primaryData.value?.position ? this.internalApiRequest.primaryData.value?.position : 0;
                            if (tableOperationsBlock == "properties_mortgage") {
                                propertyPosition = this.internalApiRequest.primaryData.value?.parentPosition ? this.internalApiRequest.primaryData.value?.parentPosition : 0;
                            }
                            // let mortgagePosition = this.internalApiRequest.primaryData.value?.position ? this.internalApiRequest.primaryData.value?.position : 0;
                            // console.log("propertyArr: ",propertyArr)
                            let propertyID = propertyArr[propertyPosition].application_id ? propertyArr[propertyPosition].application_id : this.internalApiRequest.requestBody["properties_application_id"];
                            if (this.internalApiRequest.requestBody["properties_application_id"] !== propertyID) {
                                let oldPropertyData = {};
                                for (const [key, value] of Object.entries(this.internalApiRequest.requestBody["data"]["propertyData"])) {
                                    let keyVal = tableOperationsBlock == "properties" ? value : propertyArr[propertyPosition][key];
                                    switch (typeof (value)) {
                                        case 'boolean':
                                            oldPropertyData[key] = Number(keyVal) ? true : false;
                                            break;
                                        case 'string':
                                            oldPropertyData[key] = keyVal;
                                            break;
                                        case 'number':
                                            oldPropertyData[key] = Number(keyVal);
                                            break;
                                        default:
                                            oldPropertyData[key] = keyVal;
                                            break;
                                    }
                                }
                                this.internalApiRequest.requestBody["data"]["propertyData"] = oldPropertyData;
                                this.internalApiRequest.requestBody["properties_application_id"] = propertyID;
                            }
                            // console.log("propertyID: ",propertyID)
                            let propertyData = propertyArr?.filter((item) => item.application_id === propertyID)[0];
                            // var newMortgageData = propertyData?.mortgage ? propertyData.mortgage : [];
                            // if(this.internalApiRequest.requestBody["data"]["mortgageData"][mortgagePosition] && this.internalApiRequest.requestBody["data"]["mortgageData"][mortgagePosition]?.record_id !== "") {
                            //     let isMortgageFound = propertyData.mortgage.find((item) => item.application_id === this.internalApiRequest.requestBody["data"]["mortgageData"][mortgagePosition]?.record_id);
                            //     if(!isMortgageFound) {
                            //         newMortgageData.push(this.internalApiRequest.requestBody["data"]["mortgageData"]);
                            //     } else {
                            //         newMortgageData.forEach((element,index) => {
                            //             if(element.application_id === this.internalApiRequest.requestBody["data"]["mortgageData"][mortgagePosition]["record_id"]){
                            //                 newMortgageData[index] = this.internalApiRequest.requestBody["data"]["mortgageData"][mortgagePosition];
                            //             }
                            //         });
                            //     }
                            // } else {
                            //     if(newMortgageData.length > 0) {
                            //         newMortgageData.push(this.internalApiRequest.requestBody["data"]["mortgageData"][mortgagePosition]);
                            //     } else {
                            //         newMortgageData = [Object.assign({}, this.internalApiRequest.requestBody["data"]["mortgageData"][mortgagePosition])]
                            //     }
                            // }
                            // // this.internalApiRequest.requestBody["data"]["mortgageData"] = newMortgageData;
                            // this.internalApiRequest.requestBody["data"]["mortgageData"] = [newMortgageData[mortgagePosition]]
                            // To retrict the mortgage from other property 
                            this.internalApiRequest.requestBody["data"]["mortgageData"]?.forEach((element, index) => {
                                let mortgageID = element.record_id;
                                let isMortgageFound = propertyData.mortgage ? propertyData.mortgage.find((item) => item.application_id === mortgageID) : null;
                                if (!isMortgageFound && mortgageID !== "") {
                                    this.internalApiRequest.requestBody["data"]["mortgageData"].splice(index, 1);
                                }
                            });
                        }
                        // return;
                        // console.log("saveDealPropertiesBody: ",this.internalApiRequest.requestBody)
                    }
                    if (tableOperations === "delete" && tableOperationsBlock == "properties") {
                        this.internalApiRequest.requestBody = this.deleteCurrentproperty(this.internalApiRequest);
                    }
                    if ((tableOperations === "update") && tableOperationsBlock == "personal_info") {
                        this.internalApiRequest.requestBody = this.applicantInfoBody(this.internalApiRequest, primaryData.value.position);
                    }
                    if ((tableOperations === "update") && tableOperationsBlock == "deal_info") {
                        this.internalApiRequest.requestBody = this.dealinfoBody(this.internalApiRequest);
                    }
                    if ((tableOperations === "save" || tableOperations === "update") && tableOperationsBlock == "subject_property") {
                        this.internalApiRequest.requestBody = this.saveSubjectPropertyBody(this.internalApiRequest);
                    }
                    if ((tableOperations === "save") && tableOperationsBlock == "subject_property_mortgage") {
                        this.internalApiRequest.requestBody = this.newMortgage(this.internalApiRequest);
                    }
                    if ((tableOperations === "update") && tableOperationsBlock == "subject_property_mortgage") {
                        this.internalApiRequest.requestBody = this.updateNewMortgage(this.internalApiRequest);
                    }
                    if ((tableOperations === "save") && tableOperationsBlock == "mortgage") {
                        this.internalApiRequest.requestBody = this.newDealMortgage(this.internalApiRequest);
                    }
                    if ((tableOperations === "update") && tableOperationsBlock == "mortgage") {
                        this.internalApiRequest.requestBody = this.newDealMortgage(this.internalApiRequest);
                    }
                    if ((tableOperations === "update") && tableOperationsBlock == "update_subject_property") {
                        this.internalApiRequest.requestBody = this.newSubjectProperty(this.internalApiRequest);
                    }
                    if ((tableOperations === "delete") && tableOperationsBlock == "mortgagedelete") {
                        this.internalApiRequest.requestBody = this.deleteCurrentPropertyMortGage(this.internalApiRequest);
                    }
                    if (!this.internalApiRequest.requestBody["method"] || (this.internalApiRequest.requestBody["method"] && this.internalApiRequest.requestBody["method"] != "soft_delete")) {
                        this.sharedEventsService.oidcDataEmitter.emit(this.internalApiRequest);
                    }
                }
            }
            else {
                if (apiConfigObject.isExternal) {
                    this.externalApiRequest = {
                        handler,
                        urlParams,
                        headers,
                        queryParams,
                        requestBody,
                        primaryData
                    };
                    this.sharedEventsService.eventHandlerEmitter.emit(this.externalApiRequest);
                }
                else {
                    if (apiConfigObjectArr.length > 1) { // For Parallel API Integration
                        this.sharedEventsService.apiIntegrationParallelEventHandlerEmitter.emit(requestArr);
                    }
                    else {
                        this.sharedEventsService.apiIntegrationEventHandlerEmitter.emit(this.internalApiRequest);
                    }
                }
            }
        }
        else {
            this.externalApiRequest = {
                handler,
                urlParams,
                headers,
                queryParams,
                requestBody,
                primaryData
            };
            this.sharedEventsService.eventHandlerEmitter.emit(this.externalApiRequest);
        }
        this.showOrHideLoader(handler, true);
        // } catch (error) {
        //     throw new Error(`Error Occurred while fetching data from api_config for handler: ${handler}`);
        // }
    }
    getAkitaDataFromHandler(handler) {
        if (this.apiDataService.getApiDataByHandler(handler)) {
            return this.returnNestedData(this.apiDataService.getApiDataByHandler(handler).value);
        }
    }
    returnNestedData(data) {
        if (Object(data) !== data || Array.isArray(data)) {
            return data;
        }
        const regex = /\.?([^.\[\]]+)|\[(\d+)\]/g;
        const resultholder = {};
        // tslint:disable-next-line: forin
        for (const p in data) {
            let cur = resultholder;
            let prop = '';
            let m;
            while ((m = regex.exec(p))) {
                cur = cur[prop] || (cur[prop] = m[2] ? [] : {});
                prop = m[2] || m[1];
            }
            cur[prop] = data[p];
        }
        return resultholder[''] || resultholder;
    }
    deleteCurrentPropertyMortGage = (res) => {
        const parentIndex = res.primaryData?.value?.parentPosition ?? 0;
        const urlProperties = res.urlParams?.properties;
        const urlProperty = urlProperties[parentIndex];
        const childIndex = res.primaryData.value.position;
        const currentMortgage = urlProperties?.mortgage[childIndex];
        if (!currentMortgage.record_id) {
            this.sharedEventsService.eventDeleteRepeatedBlockSubscriber.emit(res);
            this.sharedEventsService.eventResponseSubscriber.emit({
                handler: res.handler,
                response: { status: true },
                event_success: true,
            });
            return { method: "soft_delete" };
        }
        return { ...res.requestBody, mortgage_application_id: currentMortgage?.record_id };
    };
    newMortgage(res) {
        const subPropBody = this.newDealSubjectProperty(res);
        const subData = subPropBody['data'];
        const property = subPropBody['subject_property_id'];
        var body = {
            ...res.queryParams,
            data: { property_id: property, include_in_mortgage: true },
        };
        if (res?.urlParams?.data?.transaction_type == "Purchase") {
            body.data = { ...body.data, property_value: subData.purchase_price };
        }
        return body;
    }
    updateNewMortgage(res) {
        const subPropBody = this.newDealSubjectProperty(res);
        const subData = subPropBody['data'];
        const property = subPropBody['subject_property_id'];
        var body = {
            ...res.queryParams,
            data: { property_id: property, include_in_mortgage: true },
        };
        if (res?.urlParams?.data?.transaction_type == "Purchase") {
            body.data = { ...body.data, property_value: subData.purchase_price };
        }
        if (res?.urlParams?.data?.record_id != '') {
            body.data = { ...body.data, record_id: res.urlParams?.data?.record_id };
        }
        return body;
    }
    newDealMortgage(res) {
        var path = this.extractPathParamsFromCurrentUrl();
        if (path[2]) {
            res.requestBody.loan_application_id = path[2];
        }
        const mortgageProp = res.requestBody.data;
        var loan_term = Number(res.requestBody.data.loan_term_year ?? 0) * 12 + Number(res.requestBody.data.loan_term_month ?? 0);
        var amortization_period = Number(res.requestBody.data.amortization_period_year ?? 0) * 12 + Number(res.requestBody.data.amortization_period_month ?? 0);
        if (res.requestBody.data.record_id !== '') {
            var mortgageBody = {
                ...res.queryParams,
                data: { ...mortgageProp, record_id: res.requestBody.data.record_id, loan_term, amortization_period },
            };
        }
        else {
            delete mortgageProp.record_id;
            var mortgageBody = {
                ...res.queryParams,
                data: { ...mortgageProp, loan_term, amortization_period },
            };
        }
        delete mortgageBody.data.loan_term_year;
        delete mortgageBody.data.loan_term_month;
        delete mortgageBody.data.amortization_period_year;
        delete mortgageBody.data.amortization_period_month;
        mortgageBody = this.setEmptyKeysToNull(mortgageBody);
        return mortgageBody;
    }
    setEmptyKeysToNull(obj) {
        if (Array.isArray(obj)) {
            return obj.map((item) => this.setEmptyKeysToNull(item)).filter((item) => item !== undefined && item !== 'Invalid date');
        }
        else if (typeof obj === 'object' && obj !== null) {
            return Object.fromEntries(Object.entries(obj).map(([key, value]) => [
                key,
                typeof value === 'object' && value !== null
                    ? this.setEmptyKeysToNull(value) // Recursively process nested objects/arrays
                    : value === null || value === undefined || value === '' || value === 'Invalid date'
                        ? null
                        : value, // Set to null if empty
            ]));
        }
        return obj;
    }
    newSubjectProperty = (res) => {
        var body = {
            ...res.queryParams,
            subject_property_id: res.urlParams.data?.property_id,
            data: { purchase_price: (res.requestBody.data.property_value ? +res.requestBody.data.property_value : 0), is_subject_property: true },
        };
        return body;
    };
    saveSubjectPropertyBody(res) {
        var path = this.extractPathParamsFromCurrentUrl();
        if (path[2]) {
            res.requestBody.data.loan_application_id = path[2];
        }
        const subPropBody = this.newDealSubjectProperty(res);
        return subPropBody;
    }
    newDealSubjectProperty(res) {
        const subProp = res.requestBody.data;
        res.requestBody.data.total_expenses = Number(res.requestBody.data?.monthly_heating_fees + res.requestBody.data?.monthly_hydro_costs + res.requestBody.data?.monthly_insurance_costs + res.requestBody.data?.monthly_management_costs + res.requestBody.data?.monthly_repairs_costs + res.requestBody.data?.monthly_interest_costs + res.requestBody.data?.monthly_other_costs + res.requestBody.data?.monthly_rental_income + res.requestBody.data?.monthly_condo_fees);
        if (res.queryParams.data?.subject_property_id !== '') {
            var subBody = {
                ...res.queryParams,
                data: { ...subProp, is_subject_property: true, property_related_to: res.queryParams.data?.property_related_to },
                subject_property_id: res.queryParams.data?.subject_property_id,
                record_id: res.queryParams.data?.record_id
            };
        }
        else {
            var subBody = {
                ...res.queryParams,
                data: { ...subProp, is_subject_property: true, property_related_to: res.queryParams.data?.property_related_to },
            };
        }
        return subBody;
    }
    dealinfoBody(res, related = {}) {
        if (related) {
            res.requestBody.deal_information.related_to = related['loan_application_id'];
        }
        const { closing_date, intended_use_of_funds } = res.requestBody.deal_information;
        const body = {
            ...res.urlParams,
            application_id: res.queryParams.deal_application_id,
            data: { ...res.requestBody.deal_information, intended_use_of_funds: Array.isArray(intended_use_of_funds) ? intended_use_of_funds : [], organization_id: res.queryParams.data.organization_id, closing_date: this.invalidDate(closing_date) },
        };
        return body;
    }
    applicantInfoBody(res, position) {
        const CurrentapplicantInfoBody = res.requestBody['borrowers'][position];
        const id = res.urlParams['borrowers'][position];
        const body = {
            data: { ...CurrentapplicantInfoBody, date_of_birth: this.invalidDate(CurrentapplicantInfoBody.date_of_birth), loan_application_id: res.urlParams.loan_application_id },
            ...res.queryParams,
            ...id
        };
        return body;
    }
    ;
    assetBody(res) {
        const body = {
            data: res.requestBody,
            ...res.queryParams,
        };
        return body;
    }
    ;
    saveDealPropertiesBody(res) {
        const index = res.primaryData?.value?.position;
        const properties = res.requestBody?.properties;
        // const current = properties[index];
        // if (!current) {
        //   throw new Error(`Property at parentIndex ${index} does not exist.`);
        // }
        const propertyData = { ...properties }; // Create a shallow copy
        delete propertyData['mortgage']; // Remove the `mortgage` key
        const length = properties?.mortgage ? Object.keys(properties.mortgage).length : 0;
        let mortgageArray = [];
        if (length > 0) {
            var mortgageDataArray = properties.mortgage;
            mortgageArray = Array.isArray(mortgageDataArray)
                ? mortgageDataArray
                : (mortgageDataArray && typeof mortgageDataArray === 'object' ? Object.values(mortgageDataArray) : []);
            mortgageArray.forEach((element) => {
                if (element && typeof element === 'object') {
                    element['maturity_date'] = this.invalidDate(element['maturity_date']);
                }
            });
        }
        let bodyObj = {
            ...res.queryParams,
            data: {
                propertyData: {
                    ...propertyData,
                    is_subject_property: false,
                    loan_application_id: res.urlParams?.deal_id,
                },
                mortgageData: mortgageArray ? mortgageArray : [],
            },
        };
        // bodyObj = removeEmptyKeys(bodyObj);
        const urlProperties = res.urlParams?.properties;
        // const urlProperty = urlProperties[index];
        if (urlProperties?.properties_application_id) {
            bodyObj = {
                ...bodyObj,
                properties_application_id: urlProperties.properties_application_id,
            };
        }
        return bodyObj;
    }
    ;
    liabilityBody = (res) => {
        const body = {
            data: res.requestBody,
            maturity_date: this.invalidDate(res.requestBody.maturity_date),
            ...res.queryParams,
        };
        return body;
    };
    deleteCurrentproperty(res) {
        const parentIndex = res.primaryData?.value?.position;
        const urlProperties = res.urlParams?.properties || [];
        const urlProperty = urlProperties[parentIndex];
        let propertyArr = this.getAkitaDataFromHandler("getFullDealDetails")['getFullDealDetails##data']['properties'];
        let propertyPosition = this.internalApiRequest.primaryData.value?.position ? this.internalApiRequest.primaryData.value?.position : 0;
        let propertyID = propertyArr[propertyPosition]?.application_id ? propertyArr[propertyPosition]?.application_id : res?.requestBody?.properties?.properties_application_id;
        if (!propertyID) {
            this.sharedEventsService.eventDeleteRepeatedBlockSubscriber.emit(res);
            this.sharedEventsService.eventResponseSubscriber.emit({
                handler: res.handler,
                response: { status: true },
                event_success: true,
            });
            return { method: "soft_delete" };
        }
        return { ...res.requestBody, properties_application_id: propertyID };
    }
    ;
    generateAdditionalIncomeBody(res, currPosition) {
        const position = currPosition;
        const index = currPosition;
        const income = res.requestBody?.income || [];
        const current = income[position];
        if (!current) {
            throw new Error(`income at parentIndex ${position} does not exist.`);
        }
        const borrowers = res.urlParams?.borrowers[position];
        let bodyObj = {
            ...res.queryParams,
            data: {
                ...current,
                payment_type: [current.payment_type],
                borrower_id: borrowers.applicant_application_id,
                employer_name: 'Additional Income',
                employment_type: 'Seasonal',
                start_date: this.invalidDate(current.start_date),
                end_date: this.invalidDate(current.end_date),
                is_salary_income: false,
            },
        };
        const urlincome = res.urlParams?.income[position];
        if (urlincome?.income_application_id != '') {
            bodyObj = {
                ...bodyObj,
                income_application_id: urlincome.income_application_id,
            };
        }
        return bodyObj;
    }
    ;
    generateLivingAddressBody(res, currPosition) {
        const index = currPosition;
        const address = res.requestBody?.address || [];
        const current = address[index];
        const urlAddresses = res.urlParams?.address[index];
        if (!current) {
            throw new Error(`address at parentIndex ${index} does not exist.`);
        }
        const borrowers = res.urlParams?.borrowers ? res.urlParams?.borrowers[index] : [];
        let bodyObj = {
            ...res.queryParams,
            data: {
                ...current,
                move_in_date: this.invalidDate(current.move_in_date),
                move_out_date: this.invalidDate(current.move_out_date),
                borrower_id: borrowers.applicant_application_id,
            },
        };
        if (urlAddresses?.address_application_id != '') {
            bodyObj = {
                ...bodyObj,
                ...urlAddresses
            };
        }
        return bodyObj;
    }
    ;
    exployeeSaveBody(res, currPosition, parentPosition) {
        const parentIndex = currPosition;
        const currentApplicant = res.requestBody?.applicant[parentIndex];
        const currentEmployee = currentApplicant.employment;
        const { payment_type } = currentEmployee;
        var bodyObj = { ...res.urlParams, data: { ...currentEmployee, start_date: this.invalidDate(currentEmployee.start_date), end_date: this.invalidDate(currentEmployee.end_date), payment_type: Array.isArray(payment_type) ? payment_type : [payment_type], borrower_id: res.queryParams.borrowers ? res.queryParams.borrowers[parentPosition].applicant_application_id : '' } };
        if (res && res.queryParams && res.queryParams.applicant && res.queryParams.applicant[parentIndex] && res.queryParams.applicant[parentIndex].employment['employment_application_id'] != '') {
            bodyObj = { ...bodyObj, employment_application_id: res.queryParams.applicant[parentIndex].employment['employment_application_id'] };
        }
        if (bodyObj.data['start_date'] === 'Invalid date') {
            bodyObj.data['start_date'] = '';
        }
        else if (bodyObj.data['end_date'] === 'Invalid date') {
            bodyObj.data['end_date'] = '';
        }
        return bodyObj;
    }
    ;
    invalidDate(date) {
        if (date?.toLowerCase() === 'invalid date' || date?.toLowerCase() === '') {
            date = "";
        }
        return date;
    }
    ;
    /**
     * function that forms the request object that takes in the
     * api config object and
     * returns the query param, header param, url param,
     * and request body as an object
     * @required @param apiConfigObject type is object
     * @returns an object that contains all the data that is required by the
     * API
     */
    formTheRequestObj(apiConfigObject, encriptedFileData = [], type = "") {
        return {
            requestBody: encriptedFileData.length > 0 ? { file: encriptedFileData } : (apiConfigObject.requestBody.length > 0 ? this.returnFormattedObject(apiConfigObject.requestBody, type, 'requestBody') : {}),
            headers: (apiConfigObject.headerParams && apiConfigObject.headerParams.length > 0) ?
                this.returnFormattedObject(apiConfigObject.headerParams, type) : {},
            queryParams: apiConfigObject.queryParams.length > 0 ?
                this.returnFormattedObject(apiConfigObject.queryParams, type) : {},
            urlParams: apiConfigObject.urlParams.length > 0 ?
                this.returnFormattedObject(apiConfigObject.urlParams, type) : {},
            url: this.getURL(apiConfigObject.url),
            methodType: apiConfigObject.methodType,
            requestType: apiConfigObject.requestType,
            isESB: apiConfigObject.isESB,
            hasAuthorisation: apiConfigObject.hasAuthorisation,
            storageType: apiConfigObject.storageType,
            useUID: apiConfigObject.useUID || false,
            esbRequestBody: (apiConfigObject.esbRequestBody && apiConfigObject.esbRequestBody.length > 0) ? this.returnFormattedObject(apiConfigObject.esbRequestBody) : {},
            isExternal: apiConfigObject.isExternal
        };
    }
    /**
     * method modifies the url of the api_config object
     * for example: url -> ${BASE_URL}/mocks/api
     * code matches the regex and finds the BASE_URL
     * then it checks the local storage for any
     * value for BASE_URL as it should be added in the app_config.json
     * if it is not added then the code will remove ${} from the url and
     * hit the api
     */
    getURL(url) {
        const dynamicPath = url.match(new RegExp(/\$\{(.*?)\}/g));
        if (dynamicPath) {
            for (const path of dynamicPath) {
                const p = path;
                const matchPath = p.match(new RegExp(/\w+/g));
                let apiPath = p;
                if (matchPath) {
                    apiPath = localStorage.getItem(matchPath[0]);
                    if (!apiPath) {
                        apiPath = matchPath[0];
                        console.warn(`Variable ${matchPath[0]} is not declared`);
                    }
                }
                url = url.split(path).join(apiPath);
            }
            return url;
        }
        return url;
    }
    /**
     * function returns an object which is the mapping of the  apiKey and the value in a field.
     */
    getAppData(onlyValues = true) {
        let obj = {};
        const appStoreData = this.appDataService.getAllAppStoreData().sort((a, b) => {
            if (a.updatedOn && a.updatedOn < b.updatedOn) {
                return -1;
            }
            if (a.updatedOn && a.updatedOn > b.updatedOn) {
                return 1;
            }
            return 0;
        });
        for (const data of appStoreData) {
            if (data.requestApiKey.length > 0) {
                for (const key of data.requestApiKey) {
                    if (data.dataFormatSeparator) {
                        // tslint:disable-next-line: no-unused-expression
                        (key && (key.includes(':::')) && (obj = {
                            ...this.checkForDateOrTimePicker(key.split(':::'), data.value.split(data.dataFormatSeparator)), ...obj
                        }));
                    }
                    obj[key] = onlyValues ? data.value : { value: data.value, updatedOn: data.updatedOn };
                }
            }
            else {
                obj[data.apiKey] = onlyValues ? data.value : { value: data.value, updatedOn: data.updatedOn };
            }
        }
        return obj;
    }
    checkForDateOrTimePicker(keys, apiValue) {
        const obj = {};
        for (const [index, value] of keys.entries()) {
            obj[value] = apiValue[index] || '';
        }
        return obj;
    }
    /**
     * function returns an array of objects in which the first one is the object with key
     * which the apiKey concatenated with the api url and second one is the object with the normal apiKey
     * which are basically the url parameters that does not have an endpoint
     */
    getApiData() {
        let endPointMappedObj = {}; // store all api key value mappings in which the keys are url hash mapped
        const obj = {}; // store all the api key value mappings in which the api keys are not hash mapped
        const apiStoreData = this.apiDataService.getAllApiStoreData();
        for (const data of apiStoreData) {
            if (data.apiUrl) {
                // keeping data.value at first because when the data is received in the
                // front end data is stored in the api data and only at that time
                // apiUrl is added so we need to update the data in the current api data with
                // the api data that comes from the api for example pagination data, primaryKey,
                // pre-defined global parameter
                endPointMappedObj = { ...data.value, ...endPointMappedObj };
            }
            else if (data.apiKey.includes('##')) {
                const apiObj = {};
                apiObj[data.apiKey] = data.value;
                endPointMappedObj = { ...endPointMappedObj, ...apiObj };
            }
            else {
                obj[data.apiKey] = data.value;
            }
        }
        return [endPointMappedObj, obj];
    }
    /**
     * function that returns the object mapped according to the given keys array
     * @param keys the array of ids that needs to be mapped
     */
    /* private returnFormattedObject(keys, type='') {
        const apiStoreData = this.getApiData();
        const appStoreData = this.getAppData();
        
        const obj = {};
        for (const key of keys) {
            const split = key.split('##');
            const configKeys = key.includes('##') ? split[0] + '##' + split[1] : key;
            const isOptional = split[3] == 'optional';
            if (configKeys.includes('((params))')) {
                let targetApiKey = ''
                let apiKey = ''
                if (configKeys.includes('||') && configKeys.split('||').length === 2) {
                    targetApiKey = configKeys.split('||')[0];
                    apiKey = configKeys.split('||')[1].substring(10);
                }
                else {
                    targetApiKey = apiKey = configKeys.substring(10);
                }
                obj[targetApiKey] = this.sharedEventsService.params[apiKey];
            } else if (configKeys.includes('[*]')) {
                const regex = configKeys.split('[*]').join('\\[\\d+\\]');
                // check for data in appData Store
                for (const dataKey of Object.keys(appStoreData)) {
                    const result = dataKey.match(new RegExp(regex));
                    if (result) {
                        obj[this.getKey(result[0])] = this.returnParsedValues(split[2], appStoreData[result[0]], isOptional);
                    }
                }

                // check for data in api data store
                for (const dataKey of Object.keys(apiStoreData[0])) {
                    const result = dataKey.match(new RegExp(regex));
                    if (result) {
                        // check if the configKeys that needs to be pushed already exits in the object
                        const apiKey = this.getKey(result[0]);
                        if (!Object.keys(obj).includes(apiKey)) {
                            obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[0][result[0]], isOptional);
                        }
                    }
                }
            } else if (configKeys.includes('{*}')) {
                const regex = configKeys.split('{*}').join('.+');
                // check for data in appData Store
                for (const dataKey of Object.keys(appStoreData)) {
                    const result = dataKey.match(new RegExp(regex));
                    if (result) {
                        obj[this.getKey(result[0])] = this.returnParsedValues(split[2], appStoreData[result[0]], isOptional);
                    }
                }

                // check for data in api data store
                for (const dataKey of Object.keys(apiStoreData[0])) {
                    const result = dataKey.match(new RegExp(regex));
                    if (result) {
                        // check if the configKeys that needs to be pushed already exits in the object
                        const apiKey = this.getKey(result[0]);
                        if (!Object.keys(obj).includes(apiKey)) {
                            obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[0][result[0]], isOptional);
                        }
                    }
                }
            } else {
                const apiKey = this.getKey(configKeys);
                // check if configKeys exists in the app data store
                if (Object.keys(appStoreData).includes(configKeys)) {
                    obj[apiKey] = this.returnParsedValues(split[2], appStoreData[configKeys], isOptional);
                } else if (Object.keys(apiStoreData[0]).includes(configKeys)) {
                    // check if configKeys exists in api data store where keys are has mapped
                    obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[0][configKeys], isOptional);
                } else if (Object.keys(apiStoreData[1]).includes(apiKey)) {
                    // check if configKeys exists in api data store where keys are not hash mapped
                    obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[1][apiKey], isOptional);
                }
                // for optional apikey
                if (obj[apiKey] === undefined) {
                    delete obj[apiKey];
                }
            }
        }
        let finalObj = this.flatAndNestUtil.createNestedObject(obj, type);
        return finalObj;
    } */
    removeEmptyKeys(obj) {
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) { // Ensure it's not from the prototype chain
                if (obj[key] === null || obj[key] === undefined) {
                    delete obj[key];
                }
            }
        }
        return obj;
    }
    // returns the object mapped according to the given keys array 
    getMultipleApisDataByKeys(storeData, keys) {
        const obj = {};
        for (const key of keys) {
            if (storeData[key]) {
                obj[key] = storeData[key];
            }
        }
        return obj;
    }
    /**
     * Gets the latest value from store data based on updatedOn timestamp
     */
    getLatestValue(storeData) {
        return Object.entries(storeData)
            .reduce((latest, [key, data]) => {
            if (!latest || data.updatedOn > latest.updatedOn) {
                return {
                    key,
                    value: data.value,
                    updatedOn: data.updatedOn
                };
            }
            return latest;
        }, null);
    }
    /**
     * function that returns the object mapped according to the given keys array
     * @param keys the array of ids that needs to be mapped
     */
    returnFormattedObject(keys, type = '', configType = '') {
        const obj = {};
        const apiStoreData = this.getApiData();
        const appStoreData = this.getAppData();
        // filtering and separating app config keys and api keys
        const [appConfigKeys, apiKeys] = keys.reduce((acc, key) => { acc[key.startsWith('%appconfig') ? 0 : 1].push(key); return acc; }, [[], []]);
        keys = apiKeys;
        // Process appConfigKeys if present
        if (appConfigKeys.length > 0) {
            // Handle app config keys logic here
            this.processAppConfigKeys(appConfigKeys, obj);
        }
        if (configType === 'requestBody') {
            const allAppStoreData = this.getAppData(false);
            for (const key of keys) {
                // Handle OR conditions in keys
                if (key.includes('||')) {
                    const orKeys = key.split('||').map(k => k.trim());
                    const orKeyData = this.getMultipleApisDataByKeys(allAppStoreData, orKeys);
                    const latestKeyData = this.getLatestValue(orKeyData);
                    if (latestKeyData) {
                        // If we have a latest key data, use it
                        const value = this.handleKey(latestKeyData.key, apiStoreData, appStoreData);
                        if (value && Object.keys(value).length > 0) {
                            Object.assign(obj, value);
                        }
                        continue; // Skip to next key since we found a value    
                    }
                }
                else {
                    const value = this.handleKey(key, apiStoreData, appStoreData);
                    if (value && Object.keys(value).length > 0) {
                        Object.assign(obj, value);
                    }
                }
            }
        }
        else {
            for (const key of keys) {
                const value = this.handleKey(key, apiStoreData, appStoreData);
                if (value && Object.keys(value).length > 0) {
                    Object.assign(obj, value);
                }
            }
        }
        return this.flatAndNestUtil.createNestedObject(obj, type);
    }
    processAppConfigKeys(appConfigKeys, obj) {
        for (const key of appConfigKeys) {
            // Extract the parts: %appconfig##app_name:application_name
            const configPart = key.replace('%appconfig##', '');
            const [storageKey, targetProperty] = configPart.split(':');
            // Get value from localStorage
            const value = localStorage.getItem(storageKey);
            if (storageKey && targetProperty) {
                obj[targetProperty] = value ? value : '';
            }
            else if (storageKey) {
                // If only storageKey is present, use it as the key
                obj[storageKey] = value ? value : '';
            }
        }
    }
    handleKey(key, apiStoreData, appStoreData) {
        const split = key.split('##');
        const configKeys = key.includes('##') ? split[0] + '##' + split[1] : key;
        const isOptional = (split && split.length > 3 && split[3] === 'optional');
        let obj = {};
        if (configKeys.includes('((params))')) {
            let targetApiKey = '';
            let apiKey = '';
            if (configKeys.includes('||') && configKeys.split('||').length === 2) {
                targetApiKey = configKeys.split('||')[0];
                apiKey = configKeys.split('||')[1].substring(10);
            }
            else {
                targetApiKey = apiKey = configKeys.substring(10);
            }
            obj[targetApiKey] = this.sharedEventsService.params[apiKey];
        }
        else if (configKeys.includes('[*]')) {
            const regex = configKeys.split('[*]').join('\\[\\d+\\]');
            // check for data in appData Store
            for (const dataKey of Object.keys(appStoreData)) {
                const result = dataKey.match(new RegExp(regex));
                if (result) {
                    obj[this.getKey(result[0])] = this.returnParsedValues(split[2], appStoreData[result[0]], isOptional);
                }
            }
            // check for data in api data store
            for (const dataKey of Object.keys(apiStoreData[0])) {
                const result = dataKey.match(new RegExp(regex));
                if (result) {
                    // check if the configKeys that needs to be pushed already exits in the object
                    const apiKey = this.getKey(result[0]);
                    if (!Object.keys(obj).includes(apiKey)) {
                        obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[0][result[0]], isOptional);
                    }
                }
            }
        }
        else if (configKeys.includes('{*}')) {
            const regex = configKeys.split('{*}').join('.+');
            // check for data in appData Store
            for (const dataKey of Object.keys(appStoreData)) {
                const result = dataKey.match(new RegExp(regex));
                if (result) {
                    obj[this.getKey(result[0])] = this.returnParsedValues(split[2], appStoreData[result[0]], isOptional);
                }
            }
            // check for data in api data store
            for (const dataKey of Object.keys(apiStoreData[0])) {
                const result = dataKey.match(new RegExp(regex));
                if (result) {
                    // check if the configKeys that needs to be pushed already exits in the object
                    const apiKey = this.getKey(result[0]);
                    if (!Object.keys(obj).includes(apiKey)) {
                        obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[0][result[0]], isOptional);
                    }
                }
            }
        }
        else {
            const apiKey = this.getKey(configKeys);
            // check if configKeys exists in the app data store
            if (Object.keys(appStoreData).includes(configKeys)) {
                obj[apiKey] = this.returnParsedValues(split[2], appStoreData[configKeys], isOptional);
            }
            else if (Object.keys(apiStoreData[0]).includes(configKeys)) {
                // check if configKeys exists in api data store where keys are has mapped
                obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[0][configKeys], isOptional);
            }
            else if (Object.keys(apiStoreData[1]).includes(apiKey)) {
                // check if configKeys exists in api data store where keys are not hash mapped
                obj[apiKey] = this.returnParsedValues(split[2], apiStoreData[1][apiKey], isOptional);
            }
            // for optional apikey
            if (obj[apiKey] === undefined) {
                delete obj[apiKey];
            }
        }
        return obj;
    }
    /**
     * function that takes in api response as an object of type External Response
     * and stores and returns the modified object that can then be sent to the
     * inner fields for consumption
     * @param res an object of type External Response
     */
    storeResponse(res) {
        try {
            const responseData = JSON.parse(JSON.stringify(res));
            const data = this.flatAndNestUtil.flattenJSON(responseData.response);
            const modifiedObject = {};
            modifiedObject.handler_name = responseData.handler;
            for (const key of Object.keys(data)) {
                const keyName = responseData.handler + '##' + key;
                let value = data[key];
                if (data[key] === null || data[key] === 'null') {
                    value = '';
                }
                else if (typeof (data[key]) === 'boolean') {
                    value = data[key] ? '1' : '0';
                }
                else if ((!Array.isArray(data[key]) || typeof (data[key]) !== 'object') && typeof (data[key]) !== 'string') {
                    value = String(data[key]);
                }
                modifiedObject[keyName] = value;
                // Uncomment if encoding decoding is required
                // modifiedObject[keyName] = typeof (value) === 'string' ? decodeURIComponent(value) : value;
            }
            this.joinResponse(modifiedObject);
            this.apiData.id = res.handler;
            this.apiData.apiUrl = res.handler;
            this.apiData.value = modifiedObject;
            let store = true;
            if (res.storageType && res.storageType !== 'persist') {
                store = false;
            }
            // if (store) {
            //     // if exists update else add api data
            //     const isPresent = this.apiDataService.getApiDataByHandler(res.handler);
            //     if (isPresent) {
            //         this.apiDataService.updateApiData(Object.assign({}, this.apiData));
            //     } else {
            //         this.apiDataService.addApiData(Object.assign({}, this.apiData));
            //     }
            // }
            if (store) {
                let urls = '';
                // if exists update else add api data
                const isPresent = this.apiDataService.getApiDataByHandler(res.handler);
                let isSessionStor = (!localStorage.getItem('CEE_STORE_LOCATION') || (localStorage.getItem('CEE_STORE_LOCATION') && localStorage.getItem('CEE_STORE_LOCATION').toLowerCase() != 'local_storage')) ? true : false;
                // var path = this.extractPathParamsFromCurrentUrl();
                // if (path[2] != urls) {
                if (isSessionStor) {
                    this.apiDataService.addApiData(Object.assign({}, this.apiData), isSessionStor);
                    // urls = path[2];
                }
                else {
                    if (isPresent) {
                        this.apiDataService.updateApiData(Object.assign({}, this.apiData));
                    }
                    else {
                        this.apiDataService.addApiData(Object.assign({}, this.apiData));
                    }
                }
            }
            const result = {
                response: modifiedObject,
                handler: responseData.handler,
                event_success: responseData.event_success
            };
            // result.response = modifiedObject;
            this.showOrHideLoader(responseData.handler, false);
            // check if res has status code
            let r = {};
            if (res.statusCode) {
                r.status = res.statusCode;
                r.body = data;
                // tslint:disable-next-line: no-unused-expression
                (res.logout !== undefined) && (r.logout = res.logout);
            }
            else {
                r = data;
            }
            return { formattedResponse: result, flattenResponse: r };
        }
        catch (error) {
            console.error(`Error Occurred. ${error}`);
        }
    }
    extractPathParamsFromCurrentUrl() {
        const path = window.location.pathname;
        const pathSegments = path.split('/').filter(Boolean);
        return pathSegments;
    }
    /**
     * function to join the response from the api data store
     * @param res the api response
     */
    joinResponse(res) {
        const apiConfig = JSON.parse(localStorage.getItem('API_CONFIG'));
        if (res && res.handler_name && apiConfig[res.handler_name] && apiConfig[res.handler_name].join) {
            for (const joinConfig of apiConfig[res.handler_name].join) {
                if (joinConfig.fromKey
                    && joinConfig.toKey
                    && joinConfig.fromKey.length === joinConfig.toKey.length
                    && joinConfig.fromKey.length === joinConfig.fromKey.filter((a) => {
                        return a.includes('[*]') && joinConfig.fromKey.length > 0 && this.commonUtil.getHandlerName(a) === this.commonUtil.getHandlerName(joinConfig.fromKey[0]);
                    }).length
                    && joinConfig.toKey.length === joinConfig.toKey.filter((a) => {
                        return a.includes('[*]') && this.commonUtil.getHandlerName(a) === res.handler_name;
                    }).length) {
                    const fData = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(joinConfig.fromKey[0]));
                    if (fData && fData.value) {
                        const fromData = this.flatAndNestUtil.createNestedObject(fData.value);
                        const fromDataKey = joinConfig.fromKey[0].split('[*]')[0];
                        const toData = this.flatAndNestUtil.createNestedObject(res);
                        const toDataKey = joinConfig.toKey[0].split('[*]')[0];
                        for (const [tIndex, tRow] of toData[toDataKey].entries()) {
                            let matchedFromRow;
                            for (const fRow of fromData[fromDataKey]) {
                                let matchedFlag = true;
                                for (let i = 0; i < joinConfig.toKey.length; i++) {
                                    const toKey = joinConfig.toKey[i].split('[*].')[1];
                                    const fromKey = joinConfig.fromKey[i].split('[*].')[1];
                                    if (tRow[toKey] !== fRow[fromKey]) {
                                        matchedFlag = false;
                                    }
                                }
                                if (matchedFlag) {
                                    matchedFromRow = JSON.parse(JSON.stringify(fRow));
                                }
                            }
                            for (const select of joinConfig.select) {
                                const toSelectKey = joinConfig.toKey[0].replace(joinConfig.toKey[0].split('[*].')[1], select).replace('*', tIndex);
                                res[toSelectKey] = matchedFromRow && Object.prototype.hasOwnProperty.call(matchedFromRow, select) ? matchedFromRow[select] : null;
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * function to filter Join Keys from the api data keys
     * @param JoinData the api data set
     * @param joinConfigKey the api key name of the join config
     */
    filterJoinKeys(JoinData, joinConfigKey) {
        const regex = joinConfigKey.replace('*', '\\d+')
            .replace(/\[/g, '\\[')
            .replace(/\]/g, '\\]');
        const dataJoinKey = Object.keys(JoinData).filter((key) => key.match(new RegExp(regex)))
            .reduce((cur, key) => { return Object.assign(cur, { [key]: JoinData[key] }); }, {});
        return dataJoinKey;
    }
    /**
     * function to fetch the response from the api data store
     * @param name the api key name of the field
     */
    fetchResponse(name) {
        const apiStoreData = this.getApiData();
        // check if the hashed key value store includes name
        if (Object.keys(apiStoreData[0]).includes(name)) {
            return apiStoreData[0][name];
        }
        else {
            // check if the name includes ## and
            // there is any data in the api data store that
            // matches with the handler name or the api key
            if (name.includes('##')) {
                const apiDataByApiKey = this.apiDataService.getApiDataByApiKey(name);
                return apiDataByApiKey ? apiDataByApiKey.value : undefined;
            }
            else {
                if (Object.keys(apiStoreData[1]).includes(name)) {
                    return apiStoreData[1][name];
                }
            }
        }
        return undefined;
    }
    /**
     * function that returns parsed values or undefined if value doesn't exist
     * @param type the type to which the value needs to be parsed
     * @param value the store value
     * @param isOptional indicates the result can be optional allowing to return undefined
     */
    returnParsedValues(type, value, isOptional = false) {
        switch (type) {
            case 'integer':
                return Number(value) || (isOptional ? undefined : 0);
            case 'number':
                const parsedValue = typeof value === 'string'
                    ? parseFloat(value.replace(/,/g, ''))
                    : parseFloat(value);
                return parsedValue || (isOptional ? undefined : 0);
            case 'boolean':
                value = (value && typeof value === 'string') ? value.toLowerCase() : '';
                return this.booleanValues[value] ?? (isOptional ? undefined : false); // ?? allows to preserve false as a valid value
            case 'optional':
                return value ? value : undefined;
            default:
                return value;
            // Uncomment when encoding code is required
            // if (!Array.isArray(value) && typeof (value) === 'string') {
            //     return encodeURIComponent(value);
            // } else {
            //     return value;
            // }
        }
    }
    /**
     * function to emit the if the loading is needed to not
     * @param handlerName event handler or external api or api_information
     * @param loading true or false
     */
    showOrHideLoader(handlerName, loading) {
        this.sharedEventsService.customSectionLoaderEmitter.emit({
            handlerName,
            loading
        });
    }
    /**
     * normal function to get the api value
     * @param name the parameter
     */
    getKey(name) {
        return this.commonUtil.getAPIKey(name);
    }
    /**
     * normal function to get the handler name
     * @param name the parameter
     */
    getHandler(name) {
        return this.commonUtil.getHandlerName(name);
    }
    // getter setters
    get config() {
        return this.apiConfig;
    }
    set config(value) {
        this.apiConfig = value;
    }
    static ɵfac = function ExternalRequestResponseUtil_Factory(t) { return new (t || ExternalRequestResponseUtil)(i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(AppDataService), i0.ɵɵinject(ApiDataService), i0.ɵɵinject(SharedEventsServiceService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ExternalRequestResponseUtil, factory: ExternalRequestResponseUtil.ɵfac, providedIn: 'any' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ExternalRequestResponseUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'any',
            }]
    }], () => [{ type: i9.HttpClient }, { type: AppDataService }, { type: ApiDataService }, { type: SharedEventsServiceService }], null); })();

class EventResponseHandlerService {
    appDataService;
    apiDataService;
    http;
    sharedEventsService;
    externalRequestResponse;
    constructor(appDataService, apiDataService, http, sharedEventsService) {
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.http = http;
        this.sharedEventsService = sharedEventsService;
        this.externalRequestResponse = new ExternalRequestResponseUtil(http, appDataService, apiDataService, sharedEventsService);
        this.sharedEventsService.oidcApiEmitter.subscribe((apiData) => {
            // this.externalRequestResponse.storeResponse(apiData);
            this.emitAPIDATA(apiData);
        });
    }
    emitAPIDATA = (response) => {
        if (this.hash_api_key) {
            try {
                const { formattedResponse } = this.externalRequestResponse.storeResponse(response);
                const result = formattedResponse;
                if (result.event_success) {
                    this.sharedEventsService.emitApiSuccessResponse.emit(result.response);
                }
                else {
                    this.sharedEventsService.emitApiErrorResponse.emit(result.response);
                }
            }
            catch (error) {
                console.error(`Error Occurred. ${error}`);
            }
        }
        else {
            if (response['event_sucess']) {
                if (response['listResult']) {
                    this.sharedEventsService.emitApiSuccessResponse.emit(response['listResult']);
                }
                else {
                    this.sharedEventsService.emitApiSuccessResponse.emit(response);
                }
            }
            else {
                this.sharedEventsService.emitApiErrorResponse.emit(response);
            }
        }
    };
    get hash_api_key() {
        return localStorage.getItem('hash_api_key') === 'true' ? true : false;
    }
    static ɵfac = function EventResponseHandlerService_Factory(t) { return new (t || EventResponseHandlerService)(i0.ɵɵinject(AppDataService), i0.ɵɵinject(ApiDataService), i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(SharedEventsServiceService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: EventResponseHandlerService, factory: EventResponseHandlerService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(EventResponseHandlerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: AppDataService }, { type: ApiDataService }, { type: i9.HttpClient }, { type: SharedEventsServiceService }], null); })();

class ConditionalValidator {
    appDataService;
    commonUtils;
    constructor(appDataService) {
        this.appDataService = appDataService;
        this.commonUtils = new CommonUtil();
    }
    removeNonNumeric(str) {
        const input = String(str || "").trim();
        if (input === "") {
            return "0";
        }
        return (str ?? "").toString().replace(/[^0-9.]/g, "");
    }
    checkConditionalValidation(val1, val2, operator) {
        let val11 = this.appDataService.getFieldDataByFieldId(val1);
        let val22 = this.appDataService.getFieldDataByFieldId(val2);
        val1 = val11 && val11 != undefined ? val11 : this.commonUtils.getID(val1);
        val2 = val22 && val22 != undefined ? val22 : this.commonUtils.getID(val2);
        const op = operator.trim().toUpperCase();
        if (op == "GT" || op == "LT" || op == "GTE" || op == "LTE") {
            val1 = this.removeNonNumeric(val1);
            val2 = this.removeNonNumeric(val2);
        }
        switch (op) {
            case 'E':
                // removing type checking
                // and making all the values to lowercase
                // according to the meeting on 31/08/2020
                // tslint:disable-next-line: triple-equals
                // Commented the lowercase of all values as discussed with Abhishek on CI-708
                // val1 = typeof (val1) === 'string' ? val1.toLowerCase() : val1;
                // val2 = typeof (val2) === 'string' ? val2.toLowerCase() : val2;
                if (val1 == val2) {
                    return true;
                }
                else {
                    return false;
                }
            case 'NE':
                // removing type checking
                // and making all the values to lowercase
                // according to the meeting on 31/08/2020
                // tslint:disable-next-line: triple-equals
                // Commented the lowercase of all values as discussed with Abhishek on CI-708
                // val1 = typeof (val1) === 'string' ? val1.toLowerCase() : val1;
                // val2 = typeof (val2) === 'string' ? val2.toLowerCase() : val2;
                if (val1 != val2) {
                    return true;
                }
                else {
                    return false;
                }
            case 'GT':
                if (Number(val1) < Number(val2)) {
                    return true;
                }
                else {
                    return false;
                }
            case 'LT':
                if (Number(val1) > Number(val2)) {
                    return true;
                }
                else {
                    return false;
                }
            case 'GTE':
                if (Number(val1) <= Number(val2)) {
                    return true;
                }
                else {
                    return false;
                }
            case 'LTE':
                if (Number(val1) >= Number(val2)) {
                    return true;
                }
                else {
                    return false;
                }
            case 'NOT IN':
            case 'IN':
                if (val2 !== undefined) {
                    if (val2.includes(val1)) {
                        return op === 'NOT IN' ? false : true;
                    }
                    else {
                        return op === 'NOT IN' ? true : false;
                    }
                }
                else {
                    return false;
                }
            case 'FLGT':
                if (val2 !== undefined) {
                    if (val2.length > val1) {
                        return true;
                    }
                }
                return false;
            case 'FLLT':
                if (val2 && val2.length < val1) {
                    return true;
                }
                else {
                    return false;
                }
            case 'FLE':
                if (val2 !== undefined) {
                    if (val2.length == val1) {
                        return true;
                    }
                }
                return false;
            case 'FLGTE':
                if (val2 && val2.length >= val1) {
                    return true;
                }
                else {
                    return false;
                }
            case 'FLLTE':
                if (val2 && val2.length <= val1) {
                    return true;
                }
                else {
                    return false;
                }
            case 'REGEX':
                if (val2 !== undefined) {
                    const regex = val2.match(new RegExp(val1));
                    if (regex !== null) {
                        return true;
                    }
                }
                return false;
            case 'CONTAINS':
                if (val2 && val1.some(v => val2.includes(v))) {
                    return true;
                }
                else {
                    return false;
                }
            case 'NOT CONTAINS':
                let check = false;
                for (const i of val1) {
                    const valArr = val2.toLowerCase().split(' ');
                    if (valArr.includes(i.toLowerCase())) {
                        check = true;
                        break;
                    }
                }
                return check;
            default:
                return false;
        }
    }
}

class WFEConditionalExecuter {
    appDataService;
    apiDataService;
    fieldId = {};
    repeatedFieldId = '';
    responseData;
    conditionalValidatorUtil;
    commonUtil;
    constructor(appDataService, apiDataService) {
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.conditionalValidatorUtil = new ConditionalValidator(appDataService);
        this.commonUtil = new CommonUtil();
    }
    evaluateConditionQuery(query, conditionArr, repeatedId = '', responseData = {}, key) {
        // evaluate condition query
        if (query.trim() === '') {
            return true;
        }
        this.repeatedFieldId = repeatedId;
        this.fieldId = key;
        this.responseData = responseData;
        // const eliminatorArray = ['(', ')', '', 'AND', 'OR'];
        // const finalArr = [];
        // const queryArr = query.split(' ');
        // // console.log(queryArr);
        // if (queryArr.length > 3) {
        //     for (const index of queryArr) {
        //         if (eliminatorArray.includes(index)) {
        //             finalArr.push(index);
        //         } else {
        //             finalArr.push(this.evaluateSingleCondition(this.returnSingleCondition(index, conditionArr)));
        //         }
        //     }
        //     // console.log(finalArr);
        //     let finalQuery = finalArr.join(' ');
        //     finalQuery = (finalQuery.replace(/AND/g, '&&')).replace(/OR/g, '||');
        //     return eval(finalQuery);
        // } else {
        //     return true;
        // }
        let finalQuery = query;
        if (!conditionArr || !Array.isArray(conditionArr)) {
            console.error('conditionArr not define: ', conditionArr);
            return false;
        }
        for (let i = 0; i < conditionArr.length; i++) {
            const cArr = conditionArr[i];
            if (finalQuery.includes(cArr.id)) {
                const conResult = this.evaluateSingleCondition(cArr);
                finalQuery = finalQuery.split(' ' + cArr.id + ' ').join(' ' + conResult + ' ');
            }
        }
        finalQuery = (finalQuery.replace(/AND/g, '&&')).replace(/OR/g, '||');
        try {
            return eval(finalQuery);
        }
        catch (error) {
            console.error(error);
            return false;
        }
    }
    returnSingleCondition(conditionId, conditionArr) {
        // return single condition
        return conditionArr.find(obj => obj.id === conditionId);
    }
    /**
     * Generates a field ID for a repeatable block and retrieves its associated value.
     *
     * This function constructs a unique field ID based on the provided `stepOrBlockId`, `fieldUniqueId`,
     * and `words` array. It supports both non-nested and nested repeatable blocks by appending
     * additional identifiers from the `words` array. The generated field ID is then used to fetch
     * the corresponding field data from the `AppDataService`.
     *
     * @param stepOrBlockId - The ID of the step or block to which the field belongs.
     * @param fieldUniqueId - The unique identifier of the field.
     * @param words - An array of strings used to construct the field ID.
     *                The third element is required for non-nested blocks, and the fourth element is used for nested blocks.
     * @returns The value associated with the generated field ID, retrieved from the `AppDataService`.
     */
    getValueForFieldIdWithRepeatableWords(stepOrBlockId, fieldUniqueId, words) {
        // non-nested repeatable block (it is prefixed by stepOrBlockId)            
        var generatedFieldID = stepOrBlockId + '$' + fieldUniqueId + '$' + words[2];
        // nested repeatable block (it is prefixed by stepOrBlockId)
        if (words.length === 4) {
            const nestedGeneratedFieldID = generatedFieldID + '$' + words[3];
            const fdata = this.appDataService.getFieldDataByFieldId(nestedGeneratedFieldID);
            if (fdata !== undefined) {
                return fdata;
            }
        }
        // console.log('generated Field ID', generatedFieldID);
        return this.appDataService.getFieldDataByFieldId(generatedFieldID);
    }
    /**
     * Retrieves the value for a field ID in a repeatable block, handling both nested and non-nested scenarios.
     *
     * This function processes the `repeatedFieldId` to determine the appropriate field ID for fetching data.
     * It first attempts to retrieve the value using the `repeatedFieldId` and falls back to the `block` property
     * if necessary. If no value is found, it defaults to fetching the field data using the bare field ID.
     *
     * @param fieldUniqueId - The unique identifier of the field.
     * @param condition - An optional condition object containing details such as `block` and `field`.
     * @returns The value associated with the field ID, or `undefined` if no value is found.
     */
    checkRepeatableFieldIdAndGetValueForFieldId(fieldUniqueId, condition = null) {
        // console.log('this.repeatedFieldId', this.repeatedFieldId, condition.step, condition.field);        
        var words = this.repeatedFieldId?.split('$');
        if (words?.length === 3 || words?.length === 4) {
            const fdata = this.getValueForFieldIdWithRepeatableWords(words[0], fieldUniqueId, words);
            if (fdata !== undefined) {
                return fdata;
            }
            // fallback to block (it is prefixed by block)
            if (condition?.block) {
                const fdata = this.getValueForFieldIdWithRepeatableWords(condition.block, fieldUniqueId, words);
                if (fdata !== undefined) {
                    return fdata;
                }
            }
        }
        // fallback to bare field id        
        if (condition?.field) {
            return this.appDataService.getFieldDataByFieldId(condition.field);
        }
        if (fieldUniqueId) {
            return this.appDataService.getFieldDataByFieldId(fieldUniqueId);
        }
        return undefined;
    }
    // Extracts the indexed entries in an object based on a specified API key.
    // This function extracts the numeric indices from the keys of the object that match the API key
    // pattern and returns them as an array of numbers.
    //
    // @param obj - The object containing the data to be indexed.
    // @param apiKey - The API key used to identify the entries in the object.
    // @returns An array of numbers representing the indices of the entries that match the API key pattern.
    //
    // Example: If the object contains keys like "data[0]", "data[1]", "data[2]", and the apiKey is "data[*]",
    // the function will return [0, 1, 2]. 
    extractIndexedEntries(obj, apiKey) {
        const indexSet = new Set();
        let keyPrefix = apiKey.split('[*]')[0];
        const regex = new RegExp(`^${keyPrefix}\\[(\\d+)\\]`);
        for (const k of Object.keys(obj)) {
            const match = k.match(regex);
            if (match) {
                indexSet.add(Number(match[1]));
            }
        }
        return Array.from(indexSet);
    }
    // Extracts a list of values from an object based on a specified API key.
    // This function uses a regular expression to match keys in the object that correspond to the API key pattern.
    // It returns an array of values associated with those keys.
    //
    // @param obj - The object containing the data to be extracted.
    // @param apiKey - The API key used to identify the entries in the object.
    // @returns An array of values extracted from the object that match the API key pattern.
    //
    // Example: If the object contains keys like "data[0].key", "data[1].key", "data[2].key", and the apiKey is "data[*]",
    // the function will return an array of values corresponding to those keys.
    // [value0, value1, value2]
    extractList(obj, apiKey) {
        const regex = new RegExp(apiKey.split('[*]').join('\\[\\d+\\]'));
        let keys = [];
        // check for data in api data store
        for (const dataKey of Object.keys(obj)) {
            const result = dataKey.match(regex);
            if (result) {
                keys.push(obj[result[0]]);
            }
        }
        return keys;
    }
    evaluateSingleCondition(condition) {
        if (!condition) {
            return false;
        }
        // evaluate single condition
        let key;
        let dynamicValue = '';
        let value = null;
        let data;
        if (condition.field === '(this)') {
            condition.field = this.fieldId['unique_id'];
        }
        if (Object.keys(this.responseData).length && condition && condition.field) {
            data = this.responseData[condition.field];
        }
        if (data !== undefined) {
            key = data;
        }
        else {
            if (condition.compare_by && condition.compare_by === 'API_KEY') {
                // get the field data by api key
                key = this.appDataService.getFieldDataByApiKey(condition.field);
            }
            else if (!condition.field && condition.api_key) {
                if (condition.api_key.includes('##')) {
                    const conditionApiKeyObj = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(condition.api_key));
                    if (conditionApiKeyObj) {
                        if (condition.api_key.includes('[*]')) {
                            if (condition.comparision_operator.toUpperCase().startsWith('FL')) {
                                key = this.extractIndexedEntries(conditionApiKeyObj['value'], condition.api_key);
                            }
                            else {
                                key = this.extractList(conditionApiKeyObj['value'], condition.api_key);
                            }
                        }
                        else {
                            key = conditionApiKeyObj['value'][condition.api_key] || '';
                        }
                    }
                    else {
                        // if handler data not found in the store
                        return false;
                    }
                }
                else {
                    const apiDataValue = this.apiDataService.getApiDataByApiKey(condition.api_key);
                    if (apiDataValue && apiDataValue.hasOwnProperty('value')) {
                        key = apiDataValue.value;
                    }
                }
            }
            else {
                // check if the fieldId is a repeatable block field id
                key = this.checkRepeatableFieldIdAndGetValueForFieldId(condition.field, condition);
            }
        }
        // checking for fieldValues if dynamic
        const compare = condition.comparison ? condition.comparison : condition.comparision_operator;
        if (typeof condition.field_values === 'string' && condition.field_values.includes('##')) {
            let response = this.apiDataService.getApiDataByHandler(condition.field_values.split('##')[0]);
            if (response && response.value) {
                let newresponse = response.value[condition.field_values];
                condition.field_values = newresponse;
            }
        }
        if (condition.field && condition.field_values === 'DYNAMIC') {
            value = this.checkRepeatableFieldIdAndGetValueForFieldId(this.fieldId['unique_id']);
            if (value === undefined) {
                value = this.appDataService.getFieldDataByFieldId(this.fieldId['html_id']);
            }
        }
        else if (condition.field && condition.field_values === 'DYNAMIC_CASE_INSENSITIVE') {
            value = this.checkRepeatableFieldIdAndGetValueForFieldId(this.fieldId['unique_id']) || "";
            value = value.toLowerCase();
            key = key.toLowerCase();
        }
        else {
            if (compare.toUpperCase() === 'CONTAINS' || compare.toUpperCase() === 'NOT CONTAINS') {
                value = condition.field_values.split('||');
            }
            else {
                value = condition.field_values;
            }
        }
        return this.conditionalValidatorUtil.checkConditionalValidation(value, key, compare);
    }
    static ɵfac = function WFEConditionalExecuter_Factory(t) { return new (t || WFEConditionalExecuter)(i0.ɵɵinject(AppDataService), i0.ɵɵinject(ApiDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WFEConditionalExecuter, factory: WFEConditionalExecuter.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WFEConditionalExecuter, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], () => [{ type: AppDataService }, { type: ApiDataService }], null); })();

class ConditionalUtil {
    appDataService;
    commonUtils;
    wfeConditionalExecuter;
    conditionalValidator;
    isSingleCondition = false;
    constructor(isSingleCondition, appDataService, apiDataService) {
        this.appDataService = appDataService;
        this.commonUtils = new CommonUtil();
        this.wfeConditionalExecuter = new WFEConditionalExecuter(appDataService, apiDataService);
        this.conditionalValidator = new ConditionalValidator(appDataService);
        this.isSingleCondition = isSingleCondition;
    }
    checkCustomClass(fieldData, apiKey, value, data = {}) {
        // conditional custom class checking for fields
        if (fieldData.custom_class_condition && fieldData.custom_class_condition.length > 0) {
            let customClassValue = false;
            for (const customClassCondition of fieldData.custom_class_condition) {
                customClassValue = this.wfeConditionalExecuter.evaluateConditionQuery(customClassCondition.query, customClassCondition.condition, '', {}, fieldData);
                if (customClassValue) {
                    break;
                }
            }
            return customClassValue;
        }
        // conditional custom class checking for fields
        if (fieldData.custom_class_condition) {
            if (this.isSingleCondition) {
                if (fieldData.custom_class_condition.field === apiKey) {
                    return this.conditionalValidator.checkConditionalValidation(this.commonUtils.getID(fieldData.custom_class_condition.field_values), value, fieldData.custom_class_condition.comparision_operator);
                }
            }
            else {
                return this.wfeConditionalExecuter.evaluateConditionQuery(fieldData.custom_class_condition.query, fieldData.custom_class_condition.condition, apiKey, data, fieldData);
            }
        }
        return undefined;
    }
    checkBootstrapClass(fieldData, apiKey, value, data = {}) {
        // conditional Bootstrap class checking for fields
        if (fieldData.bootstrap_class_condition && fieldData.bootstrap_class_condition.length > 0) {
            let customClassValue = false;
            for (const customClassCondition of fieldData.bootstrap_class_condition) {
                customClassValue = this.wfeConditionalExecuter.evaluateConditionQuery(customClassCondition.query, customClassCondition.condition, '', {}, fieldData);
                if (customClassValue) {
                    break;
                }
            }
            return customClassValue;
        }
        // conditional Bootstrap class checking for fields
        if (fieldData.bootstrap_class_condition) {
            if (this.isSingleCondition) {
                if (fieldData.bootstrap_class_condition.field === apiKey) {
                    return this.conditionalValidator.checkConditionalValidation(this.commonUtils.getID(fieldData.bootstrap_class_condition.field_values), value, fieldData.bootstrap_class_condition.comparision_operator);
                }
            }
            else {
                return this.wfeConditionalExecuter.evaluateConditionQuery(fieldData.bootstrap_class_condition.query, fieldData.bootstrap_class_condition.condition, apiKey, data, fieldData);
            }
        }
        return undefined;
    }
    checkMandatory(fieldData, apiKey, value, data = {}) {
        // conditional mandatory checking for section or blocks
        if (fieldData && fieldData.conditional_mandatory && fieldData.conditional_mandatory.length > 0) {
            let mandatoryValue;
            for (const mandatoryCondition of fieldData.conditional_mandatory) {
                if (!mandatoryCondition.query.trim()) {
                    continue;
                }
                mandatoryValue = this.wfeConditionalExecuter.evaluateConditionQuery(mandatoryCondition.query, mandatoryCondition.condition);
                if (mandatoryValue) {
                    break;
                }
            }
            return mandatoryValue;
        }
        // conditional mandatory checking for fields
        if (fieldData?.is_mandatory === 2) {
            if (fieldData.mandatory_condition) {
                if (this.isSingleCondition) {
                    if (fieldData.mandatory_condition.field === apiKey) {
                        return this.conditionalValidator.checkConditionalValidation(this.commonUtils.getID(fieldData.mandatory_condition.field_values), value, fieldData.mandatory_condition.comparision_operator);
                    }
                }
                else {
                    return this.wfeConditionalExecuter.evaluateConditionQuery(fieldData.mandatory_condition.query, fieldData.mandatory_condition.condition, apiKey, data);
                }
            }
        }
        return undefined;
    }
    checkStepDependency(dependencyCondition) {
        return this.wfeConditionalExecuter.evaluateConditionQuery(dependencyCondition.query, dependencyCondition.condition);
    }
    checkEditable(fieldData, apiKey, value, data = {}) {
        // conditional editable checking for section or blocks
        if (fieldData.conditional_editable && fieldData.conditional_editable.length > 0) {
            let editableValue;
            for (const editableCondition of fieldData.conditional_editable) {
                if (!editableCondition.query.trim()) {
                    continue;
                }
                editableValue = this.wfeConditionalExecuter.evaluateConditionQuery(editableCondition.query, editableCondition.condition);
                if (editableValue) {
                    break;
                }
            }
            return editableValue;
        }
        // conditional editable checking for fields
        if (fieldData.is_editable === 2) {
            if (fieldData.editable_condition) {
                if (this.isSingleCondition) {
                    if (fieldData.editable_condition.field === apiKey) {
                        return this.conditionalValidator.checkConditionalValidation(this.commonUtils.getID(fieldData.editable_condition.field_values), value, fieldData.editable_condition.comparision_operator);
                    }
                }
                else {
                    return this.wfeConditionalExecuter.evaluateConditionQuery(fieldData.editable_condition.query, fieldData.editable_condition.condition, apiKey, data);
                }
            }
        }
        return undefined;
    }
    checkVisibility(fieldData, apiKey, value, data = {}) {
        // conditional visible checking for section or blocks
        if (fieldData.conditional_visible && fieldData.conditional_visible.length > 0) {
            let visibleValue;
            for (const visibleCondition of fieldData.conditional_visible) {
                if (!visibleCondition.query.trim()) {
                    continue;
                }
                visibleValue = this.wfeConditionalExecuter.evaluateConditionQuery(visibleCondition.query, visibleCondition.condition);
                if (visibleValue) {
                    break;
                }
            }
            return visibleValue;
        }
        // conditional visible checking for fields
        if (fieldData.is_display === 2) {
            if (fieldData.display_condition) {
                if (this.isSingleCondition) {
                    if (fieldData.display_condition.field === apiKey) {
                        return this.conditionalValidator.checkConditionalValidation(this.commonUtils.getID(fieldData.display_condition.field_values), value, fieldData.display_condition.comparision_operator);
                    }
                }
                else {
                    return this.wfeConditionalExecuter.evaluateConditionQuery(fieldData.display_condition.query, fieldData.display_condition.condition, apiKey, data);
                }
            }
        }
        return undefined;
    }
    conditionalValue(fieldData, apiKey, value, currentValue) {
        const { is_conditional_value, conditional_value } = fieldData;
        let fieldValue = currentValue;
        if (is_conditional_value && is_conditional_value === 1
            && conditional_value && Array.isArray(conditional_value)) {
            for (const conditionalValue of conditional_value) {
                const { 
                // step,
                field, field_values, comparision_operator, value_option, value_option_value, value_other, value_other_value, value_step, value_step_id, value_step_field, value_step_field_value } = conditionalValue;
                if (field === apiKey) {
                    const checkCondition = this.conditionalValidator.checkConditionalValidation(field_values, value, comparision_operator);
                    if (checkCondition) {
                        if (value_option === 1) {
                            fieldValue = value_option_value;
                        }
                        else if (value_other === 1) {
                            fieldValue = value_other_value;
                        }
                        else {
                            fieldValue = value_step_field_value;
                        }
                    }
                }
                if (value_step === 1) {
                    const conditionFieldVal = this.appDataService.getFieldDataByFieldId(field);
                    const checkCondition = this.conditionalValidator.checkConditionalValidation(field_values, conditionFieldVal, comparision_operator);
                    if (checkCondition && value_step_field_value == 'DYNAMIC') {
                        const valueFieldVal = this.appDataService.getFieldDataByFieldId(value_step_field);
                        fieldValue = valueFieldVal;
                    }
                }
            }
        }
        return fieldValue;
    }
    checkClass(data, blockData) {
        // conditional class checking for section or blocks
        if (blockData.custom_class_condition && blockData.custom_class_condition.condition.length > 0) {
            let classValue = false;
            classValue = this.wfeConditionalExecuter.evaluateConditionQuery(blockData.custom_class_condition.query, blockData.custom_class_condition.condition, '', data);
            return classValue;
        }
    }
    evaluteBootstrapCondition(field) {
        let bootstrapClassCondition = field && field.hasOwnProperty('bootstrap_class_condition') && field['bootstrap_class_condition'] ? field['bootstrap_class_condition'] : {};
        let isConditionValid = true;
        if (bootstrapClassCondition && bootstrapClassCondition.hasOwnProperty('query') && bootstrapClassCondition['query'] != '') {
            isConditionValid = this.checkBootstrapClass(field, String(field.unique_id), '');
        }
        return isConditionValid;
    }
    static ɵfac = function ConditionalUtil_Factory(t) { return new (t || ConditionalUtil)(i0.ɵɵinject('isSingleCondition'), i0.ɵɵinject(AppDataService), i0.ɵɵinject(ApiDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ConditionalUtil, factory: ConditionalUtil.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ConditionalUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], () => [{ type: undefined, decorators: [{
                type: Inject,
                args: ['isSingleCondition']
            }] }, { type: AppDataService }, { type: ApiDataService }], null); })();

class DynamicRendererComponent {
    appDataService;
    apiDataService;
    sharedEventsService;
    dynamicHandlerService;
    moduleName;
    fieldData;
    stepId;
    apiKeyUtil;
    store = {};
    fieldData$;
    appData = {
        id: '',
        stepId: '',
        apiKey: '',
        fieldLabel: '',
        linkedBlockId: '',
        isRepeatedField: false,
        repeatedBlockFieldId: '',
        requestApiKey: [],
        responseApiKey: [],
        dataFormatSeparator: '',
        mandatory: false,
        editable: false,
        visible: false,
        value: '',
        isValid: true
    };
    variableObject = {}; // variable object
    setAPIKeyUtil;
    commonUtil;
    conditionalUtil;
    constructor(appDataService, apiDataService, sharedEventsService, dynamicHandlerService, viewContainerRef) {
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.sharedEventsService = sharedEventsService;
        this.dynamicHandlerService = dynamicHandlerService;
        this.apiKeyUtil = new APIKeyUtil();
        this.commonUtil = new CommonUtil();
        this.setAPIKeyUtil = new SetAPICallbackData(apiDataService);
        this.dynamicHandlerService.setRootViewContainerRef(viewContainerRef);
        this.conditionalUtil = new ConditionalUtil(this.singleCondition, appDataService, apiDataService);
    }
    ngOnInit() {
        this.processFieldData();
        this.dynamicHandlerService.addDynamicComponent(this.moduleName, {
            fieldData: this.fieldData,
            stepId: this.stepId,
            store: this.store
        });
    }
    processFieldData() {
        this.store['value'] = '';
        this.store['setValue'] = () => { };
        this.store['onAPICallback'] = new EventEmitter();
        this.store['showMandatoryErrorMsg'] = new EventEmitter();
        if (this.fieldData && this.fieldData.unique_id) {
            this.appData.id = this.fieldData.unique_id;
            this.appData.stepId = this.stepId;
            if (this.isSingleApiKey) {
                this.appData.apiKey = this.fieldData.api_key;
            }
            else {
                this.appData.requestApiKey = this.apiKeyUtil.getMultipleApiKeys(this.fieldData.request_api_key);
                this.appData.responseApiKey =
                    this.apiKeyUtil.getMultipleApiKeys(this.apiKeyUtil.getConcatenatedApiKeys(this.fieldData.response_api_key));
            }
            const fieldUniqueId = this.fieldData.unique_id;
            if (this.fieldData.is_mandatory === 1) {
                this.appData.mandatory = true;
            }
            this.fieldData$ = this.appDataService.getAppDataByFieldId(fieldUniqueId);
            this.fieldData$
                .pipe(take(1))
                .subscribe(val => {
                if (val) {
                    this.store['value'] = val.value;
                }
                else {
                    this.appDataService.addAppData(this.appData);
                }
            }, err => {
                console.error(err);
            });
            const apiValue = this.setFieldValue();
            if (apiValue) {
                this.appData.value = apiValue;
                this.appDataService.updateAppData(Object.assign({}, this.appData));
                this.store['value'] = apiValue;
            }
            this.store['setValue'] = (v) => {
                this.appData.value = v;
                this.appDataService.setAppData(Object.assign({}, this.appData));
            };
            this.variableObject['emitApiSuccessResponse_' + this.appData.id] =
                this.sharedEventsService.emitApiSuccessResponse.subscribe(res => {
                    if (res) {
                        const result = this.setAPIKeyUtil.setApiCallBackData(this.fieldData, res);
                        if (result) {
                            this.store['onAPICallback'].emit(result);
                        }
                    }
                });
            this.variableObject['emitOnDataSetOrUpdated_' + this.appData.id] = this.sharedEventsService.emitOnDataSetOrUpdated.subscribe(res => {
                if (res.index) {
                }
                else {
                    this.onSetSessionData(res.apiKey, res.value);
                }
            });
            this.variableObject['showMandatoryErrorMsg_' + this.appData.id] = this.sharedEventsService.showMandatoryErrorMsg.subscribe((res) => {
                if (res && Array.isArray(res.fields) && res.fields.includes(this.appData.id)) {
                    this.store['showMandatoryErrorMsg'].emit(true);
                }
                else {
                    this.store['showMandatoryErrorMsg'].emit(false);
                }
            });
            this.onSetSessionData(this.fieldData.unique_id, this.store['value']);
        }
    }
    onSetSessionData(apiKey, value) {
        let mandatoryCondition = this.conditionalUtil.checkMandatory(this.fieldData, String(this.appData.id), value);
        if (mandatoryCondition !== undefined) {
            this.appData.mandatory = mandatoryCondition;
        }
        if (this.fieldData.is_mandatory === 2) {
            this.appDataService.updateAppData(Object.assign({}, this.appData));
        }
    }
    setFieldValue() {
        let value;
        // TODO: check functionality
        if (this.fieldData.response_api_key && this.fieldData.response_api_key.includes('|')) {
            // set concatenated field values
            const apiKeys = this.apiKeyUtil.getMultipleApiKeys(this.apiKeyUtil.getConcatenatedApiKeys(this.fieldData.response_api_key));
            for (const key of apiKeys) {
                const apiCallbackData = this.returnValueFromCallback(key);
                if (apiCallbackData !== null && apiCallbackData !== undefined) {
                    value = apiCallbackData;
                }
            }
        }
        else {
            value = this.returnValueFromCallback(this.fieldData.response_api_key);
        }
        return value;
    }
    /**
     * function that returns value from set api callback util
     * @param keyName the api key name
     */
    returnValueFromCallback(keyName) {
        const handlerValue = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(keyName)) ?
            this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(keyName)).value : {};
        return this.setAPIKeyUtil.setApiCallBackData(keyName, handlerValue);
    }
    // all getter and setters go here
    get singleCondition() {
        return localStorage.getItem('isSingleCondition') === 'true' ? true : false;
    }
    get isSingleApiKey() {
        return localStorage.getItem('singleApiKey') === 'true' ? true : false;
    }
    ngOnDestroy() {
        for (const key in this.variableObject) {
            if (this.variableObject[key]) {
                this.variableObject[key].unsubscribe();
            }
        }
    }
    static ɵfac = function DynamicRendererComponent_Factory(t) { return new (t || DynamicRendererComponent)(i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(DynamicComponentHandlerService), i0.ɵɵdirectiveInject(ViewContainerRef)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DynamicRendererComponent, selectors: [["app-dynamic-renderer"]], inputs: { moduleName: "moduleName", fieldData: "fieldData", stepId: "stepId" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 0, vars: 0, template: function DynamicRendererComponent_Template(rf, ctx) { }, dependencies: [CommonModule] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DynamicRendererComponent, [{
        type: Component,
        args: [{ selector: 'app-dynamic-renderer', standalone: true, imports: [CommonModule], template: "<!-- <p>dynamic-renderer works!</p> -->\r\n" }]
    }], () => [{ type: AppDataService }, { type: ApiDataService }, { type: SharedEventsServiceService }, { type: DynamicComponentHandlerService }, { type: undefined, decorators: [{
                type: Inject,
                args: [ViewContainerRef]
            }] }], { moduleName: [{
            type: Input
        }], fieldData: [{
            type: Input
        }], stepId: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(DynamicRendererComponent, { className: "DynamicRendererComponent", filePath: "lib\\components\\dynamic-renderer\\dynamic-renderer.component.ts", lineNumber: 21 }); })();

class RepeatableworkflowHandler {
    initConfig(workflowId, currentIndex, repeatLength, parentWorkflowId) {
        this.updateConfig(workflowId, currentIndex, repeatLength, parentWorkflowId);
    }
    /**
     * to update the configuration
     * param workflowId
     * param currentIndex
     * param repeatLength
     * param parentWorkflowId
     * **/
    updateConfig(workflowId, currentIndex = 0, repeatLength = null, parentWorkflowId = null) {
        let repeatWorkflowMasterData = {};
        const config = this.getAllConfig();
        if (config) {
            repeatWorkflowMasterData = config;
        }
        if (!repeatWorkflowMasterData[workflowId]) {
            repeatWorkflowMasterData[workflowId] = {};
        }
        repeatWorkflowMasterData[workflowId]['count'] = currentIndex;
        if (repeatLength) {
            repeatWorkflowMasterData[workflowId]['length'] = repeatLength;
        }
        if (parentWorkflowId) {
            repeatWorkflowMasterData[workflowId]['parentworkFlow'] = parentWorkflowId;
        }
        window.localStorage.setItem('REPEAT_WORKFLOW_CONFIG', JSON.stringify(repeatWorkflowMasterData));
    }
    getAllConfig() {
        let config = window.localStorage.getItem('REPEAT_WORKFLOW_CONFIG');
        if (config) {
            config = JSON.parse(config);
            return config;
        }
        return null;
    }
    getConfigByWorkflowId(workflowId) {
        const config = this.getAllConfig();
        return ((config && config[workflowId])) ? config[workflowId] : null;
    }
    incriseConfigCount(workflowId) {
        const config = this.getAllConfig();
        if (config && config[workflowId]) {
            let count = config[workflowId]['count'];
            count += 1;
            this.updateConfig(workflowId, count);
        }
        return;
    }
    removeWorkflowFromConfig(workflowId) {
        const config = this.getAllConfig();
        if (config && config[workflowId]) {
            delete config[workflowId];
            window.localStorage.setItem('REPEAT_WORKFLOW_CONFIG', JSON.stringify(config));
        }
    }
}

class GenerateFieldRow {
    appDataService;
    workflowUtil;
    apiKeyUtil;
    stepId = window['currentStepId'];
    isApiResponse = false;
    responseMap = {};
    counter = 0;
    constructor(appDataService) {
        this.appDataService = appDataService;
        this.workflowUtil = new RepeatableworkflowHandler();
        this.apiKeyUtil = new APIKeyUtil();
    }
    get isSingleAPIKey() {
        return localStorage.getItem('singleApiKey') === 'true' ? true : false;
    }
    generateRowData(field) {
        const currentWorkflow = window['currentWorkflowId'];
        const workflowDetails = this.workflowUtil.getConfigByWorkflowId(currentWorkflow);
        if (workflowDetails) {
            this.counter = workflowDetails.length;
            const currentIndex = workflowDetails.count;
            const value = '[' + currentIndex + ']';
            const apiKey = field.api_key.replace('[*]', value);
            const id = this.stepId + '$' + field.unique_id + '$' + currentIndex;
            const formattedVal = {
                api_key: this.isSingleAPIKey ? apiKey : '',
                unique_id: id,
                html_id: field.unique_id + '-' + currentIndex,
                mandatory: field.is_mandatory === 1 ? true : false,
                editable: field.is_editable === 1 ? true : false,
                response_api_key: this.returnRequestOrResponseApiKeys('response', field.response_api_key, value),
                request_api_key: this.returnRequestOrResponseApiKeys('request', field.request_api_key, value),
                // linkedBlockId: this.blockId,
                repeatedBlockFieldId: field.unique_id,
                isApiResponse: this.isApiResponse,
                value: this.returnFieldDataForLabel(field, this.isSingleAPIKey ? apiKey :
                    this.returnRequestOrResponseApiKeys('response', field.response_api_key, value), id)
            };
            return formattedVal;
        }
        return null;
    }
    returnRequestOrResponseApiKeys(type, key, position) {
        if (!this.isSingleAPIKey) {
            key = key.split('[*]').join(position); // change [*] with [ index ]
            return this.apiKeyUtil.getMultipleApiKeys(type === 'response' ?
                this.apiKeyUtil.getConcatenatedApiKeys(key) : key);
        }
        else {
            return [];
        }
    }
    returnFieldDataForLabel(fieldTemp, apiKey, id) {
        let returnValue;
        if (fieldTemp.field_type === 'label' && !(this.isSingleAPIKey ? fieldTemp.api_key : fieldTemp.response_api_key)) {
            returnValue = fieldTemp.field_label;
        }
        else {
            returnValue = this.returnFieldValue(apiKey, id);
        }
        return returnValue;
    }
    returnFieldValue(apiKey, id) {
        // TODO: Check functionality
        let value;
        if (this.isSingleAPIKey) {
            value = this.responseMap[apiKey];
        }
        else {
            for (const key of apiKey) {
                if (key.includes('+')) {
                    let val;
                    const concatKeys = key.split('+');
                    for (const singleKey of concatKeys) {
                        val = concatKeys.indexOf(singleKey) === 0 ? this.responseMap[singleKey] : value + ' ' + this.responseMap[singleKey];
                    }
                    value = val;
                }
                else {
                    value = this.responseMap[apiKey];
                }
            }
        }
        if (!value) {
            value = this.appDataService.getFieldDataByFieldId(id);
        }
        return value ? value : '';
    }
    static ɵfac = function GenerateFieldRow_Factory(t) { return new (t || GenerateFieldRow)(i0.ɵɵinject(AppDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: GenerateFieldRow, factory: GenerateFieldRow.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(GenerateFieldRow, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], () => [{ type: AppDataService }], null); })();

const _c0$7 = () => ["List", "List-Single-Select", "List-Multi-Select", "List-Expandable"];
const _c1$6 = () => ["List-V2", "List-Single-Select-V2", "List-Multi-Select-V2", "List-Expandable-V2"];
const _c2$1 = () => ["Table", "Table-Single-Select", "Table-Multi-Select", "Table-Expandable"];
const _c3$1 = () => ["Table-V2", "Table-Single-Select-V2", "Table-Multi-Select-V2", "Table-Expandable-V2"];
const _c4 = (a0, a1, a2, a3, a4, a5, a6) => ({ stepId: a0, rootData: a1, rowData: a2, fieldData: a3, keepState: true, mandatoryCondition: a4, editableCondition: a5, visibleCondition: a6 });
const _c5 = (a0, a1, a2, a3, a4, a5, a6) => ({ stepId: a0, rootData: a1, rowData: a2, fieldData: a3, mandatoryCondition: a4, editableCondition: a5, visibleCondition: a6 });
const _c6 = (a0, a1, a2, a3) => ({ stepId: a0, rootData: a1, rowData: a2, fieldData: a3 });
const _c7 = (a0, a1, a2, a3) => ({ stepId: a0, rootData: a1, rowData: a2, fieldData: a3, keepState: true });
const _c8 = (a0, a1, a2) => ({ stepId: a0, rootData: a1, fieldData: a2 });
const _c9 = (a0, a1, a2, a3, a4, a5, a6) => ({ stepId: a0, templateId: a1, rootData: a2, fieldData: a3, blockPosition: "0", mandatoryCondition: a4, editableCondition: a5, visibleCondition: a6 });
const _c10 = (a0, a1) => ({ stepId: a0, fieldData: a1 });
const _c11 = (a0, a1, a2, a3, a4, a5, a6) => ({ stepId: a0, templateId: a1, rootData: a2, fieldData: a3, mandatoryCondition: a4, editableCondition: a5, visibleCondition: a6 });
const _c12 = (a0, a1, a2, a3, a4) => ({ stepId: a0, templateId: a1, rootData: a2, sectionData: a3, type: a4 });
const _c13 = (a0, a1, a2, a3) => ({ stepId: a0, templateId: a1, rootData: a2, fieldData: a3 });
const _c14 = (a0, a1, a2, a3) => ({ stepId: a0, templateId: a1, rootData: a2, sectionData: a3 });
const _c15 = (a0, a1, a2, a3) => ({ stepId: a0, rootData: a1, sectionData: a2, type: a3, paginateValue: "", fieldData: "" });
const _c16 = (a0, a1, a2, a3, a4) => ({ stepId: a0, rootData: a1, rowData: a2, fieldData: a3, visibleCondition: a4 });
const _c17 = (a0, a1, a2, a3, a4, a5, a6) => ({ stepId: a0, templateId: a1, rootData: a2, fieldData: a3, isAttachmentBlock: "true", mandatoryCondition: a4, editableCondition: a5, visibleCondition: a6, blockPosition: "0" });
function ViewRendererComponent_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_2_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c5, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_3_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c5, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_4_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_5_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_5_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_6_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_7_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_7_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c6, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_8_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_8_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c6, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_9_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_9_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap["Textfield"]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_10_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_10_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_11_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_11_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_12_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_12_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_13_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_13_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c6, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_14_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_14_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_15_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_15_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_16_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_16_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_16_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_17_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_17_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_18_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_18_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_19_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_19_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c5, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_20_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_20_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap["Button"]))("ngComponentOutletInputs", i0.ɵɵpureFunction3(7, _c8, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_21_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_21_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction3(7, _c8, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_22_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_22_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_22_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction3(7, _c8, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_23_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_23_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_24_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ViewRendererComponent_ng_container_24_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 2, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(4, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_25_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_25_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c9, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_26_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_26_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_26_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction2(7, _c10, ctx_r0.stepId, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_27_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_27_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ViewRendererComponent_ng_container_27_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 2, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(4, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_28_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_28_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_28_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c11, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_29_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_29_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_29_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c11, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_30_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_30_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_30_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate2("field-", ctx_r0.position, " ", ctx_r0.field.field_style ? ctx_r0.field.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 6, ctx_r0.componentMap["List"]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(8, _c12, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.field.field_type));
} }
function ViewRendererComponent_ng_container_31_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_31_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_31_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate2("field-", ctx_r0.position, " ", ctx_r0.field.field_style ? ctx_r0.field.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 6, ctx_r0.componentMap["List-V2"]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(8, _c12, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.field.field_type));
} }
function ViewRendererComponent_ng_container_32_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_32_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_32_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate2("field-", ctx_r0.position, " ", ctx_r0.field.field_style ? ctx_r0.field.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 6, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(8, _c12, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.field.field_type));
} }
function ViewRendererComponent_ng_container_33_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_33_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_33_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate2("field-", ctx_r0.position, " ", ctx_r0.field.field_style ? ctx_r0.field.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 6, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(8, _c12, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.field.field_type));
} }
function ViewRendererComponent_ng_container_34_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_34_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_34_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c13, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_35_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_35_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_35_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c14, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_36_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_36_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_36_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate2("field-", ctx_r0.position, " ", ctx_r0.field.field_style ? ctx_r0.field.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 6, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction2(8, _c10, ctx_r0.stepId, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_37_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_37_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_37_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap["Table"]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c15, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.field, ctx_r0.field.field_type));
} }
function ViewRendererComponent_ng_container_38_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_38_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_38_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap["Table-V2"]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c15, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.field, ctx_r0.field.field_type));
} }
function ViewRendererComponent_ng_container_39_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_39_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ViewRendererComponent_ng_container_39_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 2, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(4, _c16, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_40_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_40_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ViewRendererComponent_ng_container_40_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 2, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(4, _c6, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_41_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_41_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ViewRendererComponent_ng_container_41_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 2, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(4, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_42_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_42_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ViewRendererComponent_ng_container_42_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 2, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(4, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_43_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_43_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_43_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_44_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_44_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_44_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_45_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_45_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_45_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_46_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_46_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_46_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_47_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_47_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_47_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c4, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_48_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_48_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_48_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap["Generic Block"]))("ngComponentOutletInputs", i0.ɵɵpureFunction7(7, _c17, ctx_r0.stepId, ctx_r0.templateId, ctx_r0.rootData, ctx_r0.field, ctx_r0.mandatoryCondition, ctx_r0.editableCondition, ctx_r0.visibleCondition));
} }
function ViewRendererComponent_ng_container_49_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_49_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_49_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate2("field-", ctx_r0.position, " ", ctx_r0.field.field_style ? ctx_r0.field.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 6, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction3(8, _c8, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_50_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_50_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_50_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate2("field-", ctx_r0.position, " ", ctx_r0.field.field_style ? ctx_r0.field.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 6, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(8, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_51_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_51_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_51_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
function ViewRendererComponent_ng_container_52_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ViewRendererComponent_ng_container_52_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, ViewRendererComponent_ng_container_52_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", ctx_r0.position, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap[ctx_r0.field.field_type]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c7, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.rowData, ctx_r0.field));
} }
class ViewRendererComponent {
    stepId;
    field;
    position;
    templateId;
    rowData;
    rootData;
    mandatoryCondition;
    editableCondition;
    visibleCondition;
    is_bootstrap;
    componentMap = {
        Tag: defer(() => {
            return import('./ng-cee-core-cee-tag.component-DkhMBgMj.mjs').then(m => m.CeeTagComponent);
        }),
        label: defer(() => {
            return import('./ng-cee-core-cee-label.component-3Du0Wv_U.mjs').then(m => m.CeeLabelComponent);
        }),
        APIValidations: defer(() => {
            return import('./ng-cee-core-cee-api-validation.component-BNoK7ukE.mjs').then(m => m.CeeApiValidationComponent);
        }),
        ticker: defer(() => {
            return import('./ng-cee-core-cee-ticker.component-mdNev-Pb.mjs').then(m => m.CeeTickerComponent);
        }),
        Textarea: defer(() => {
            return import('./ng-cee-core-cee-textarea.component-CPdSKLMX.mjs').then(m => m.CeeTextareaComponent);
        }),
        Textfield: defer(() => {
            return import('./ng-cee-core-cee-textfield.component-ddq1tk4O.mjs').then(m => m.CeeTextfieldComponent);
        }),
        Link: defer(() => {
            return import('./ng-cee-core-cee-link.component-LAUdVFMh.mjs').then(m => m.CeeLinkComponent);
        }),
        Video: defer(() => {
            return import('./ng-cee-core-cee-video.component-Bvg3K2NA.mjs').then(m => m.CeeVideoComponent);
        }),
        Switch: defer(() => {
            return import('./ng-cee-core-cee-switch.component-CfZ5e9ds.mjs').then(m => m.CeeSwitchComponent);
        }),
        Camera: defer(() => {
            return import('./ng-cee-core-cee-camera.component-C-fmiSMu.mjs').then(m => m.CeeCameraComponent);
        }),
        Date: defer(() => {
            return import('./ng-cee-core-cee-date.component-BEfJDC8g.mjs').then(m => m.CeeDateComponent);
        }),
        Image: defer(() => {
            return import('./ng-cee-core-cee-image.component-DItsEZaO.mjs').then(m => m.CeeImageComponent);
        }),
        radio: defer(() => {
            return import('./ng-cee-core-cee-radio.component-DMT3QXZY.mjs').then(m => m.CeeRadioComponent);
        }),
        StarRating: defer(() => {
            return import('./ng-cee-core-cee-star.component-B5ngvXwn.mjs').then(m => m.CeeStarComponent);
        }),
        Checkbox: defer(() => {
            return import('./ng-cee-core-cee-checkbox.component-CzuWvf1D.mjs').then(m => m.CeeCheckboxComponent);
        }),
        Picker: defer(() => {
            return import('./ng-cee-core-cee-picker.component-DQznZ6Qo.mjs').then(m => m.CeePickerComponent);
        }),
        Menu: defer(() => {
            return import('./ng-cee-core-cee-menu.component-DrjJlxBz.mjs').then(m => m.CeeMenuComponent);
        }),
        Button: defer(() => {
            return Promise.resolve().then(function () { return ceeButton_component; }).then(m => m.CeeButtonComponent);
        }),
        Timepicker: defer(() => {
            return import('./ng-cee-core-cee-time-picker.component-6Ms8Loh5.mjs').then(m => m.CeeTimePickerComponent);
        }),
        PhoneNumber: defer(() => {
            return import('./ng-cee-core-cee-phone-number.component-Dnx-BmXC.mjs').then(m => m.CeePhoneNumberComponent);
        }),
        ToggleButton: defer(() => {
            return import('./ng-cee-core-cee-toggle-button.component-EBCs3K3e.mjs').then(m => m.CeeToggleButtonComponent);
        }),
        Carousel: defer(() => {
            return import('./ng-cee-core-cee-carousel.component-Dimvmcl3.mjs').then(m => m.CeeCarouselComponent);
        }),
        Editor: defer(() => {
            return import('./ng-cee-core-cee-editor.component-BCar5kMU.mjs').then(m => m.CeeEditorComponent);
        }),
        Map: defer(() => {
            return import('./ng-cee-core-cee-map.component-CmiEuarW.mjs').then(m => m.CeeMapComponent);
        }),
        Chart: defer(() => {
            return import('./ng-cee-core-cee-chart.component-D--yUxsm.mjs').then(m => m.CeeChartComponent);
        }),
        Captcha: defer(() => {
            return import('./ng-cee-core-cee-captcha.component-CBG5R6P9.mjs').then(m => m.CeeCaptchaComponent);
        }),
        'Autocomplete Textfield': defer(() => {
            return import('./ng-cee-core-cee-auto-complete.component-B9_cS21z.mjs').then(m => m.CeeAutoCompleteComponent);
        }),
        Attachments: defer(() => {
            return import('./ng-cee-core-cee-attachments.component-DaZytsS9.mjs').then(m => m.CeeAttachmentsComponent);
        }),
        TimeSlots: defer(() => {
            return import('./ng-cee-core-cee-time-slots.component-katvb2F1.mjs').then(m => m.CeeTimeSlotsComponent);
        }),
        Calendar: defer(() => {
            return import('./ng-cee-core-cee-calendar.component-C2COH-bY.mjs').then(m => m.CeeCalendarComponent);
        }),
        Number: defer(() => {
            return import('./ng-cee-core-cee-number.component-BBnOui2F.mjs').then(m => m.CeeNumberComponent);
        }),
        'Generic Block': defer(() => {
            return import('./ng-cee-core-generic-block-renderer.component-BWLqu5NL.mjs').then(m => m.GenericBlockRendererComponent);
        }),
        'Breadcrumb View': defer(() => {
            return import('./ng-cee-core-breadcrumb-renderer.component-CXwxUzPM.mjs').then(m => m.BreadcrumbRendererComponent);
        }),
        'Repeatable Block': defer(() => {
            return import('./ng-cee-core-repeatable-block-renderer.component-DK7V4sDx.mjs').then(m => m.RepeatableBlockRendererComponent);
        }),
        'RBLite': defer(() => {
            return import('./ng-cee-core-rb-renderer.component-Dt38iAoc.mjs').then(m => m.RBRendererComponent);
        }),
        List: defer(() => {
            return import('./ng-cee-core-list-renderer.component-nDakO_mU.mjs').then(m => m.ListRendererComponent);
        }),
        'List-V2': defer(() => {
            return import('./ng-cee-core-list-renderer-v2.component-CKgP0fZf.mjs').then(m => m.ListRendererComponentV2);
        }),
        DynamicForm: defer(() => {
            return import('./ng-cee-core-dynamic-form.component-Cm25oDxC.mjs').then(m => m.DynamicFormComponent);
        }),
        TreeView: defer(() => {
            return import('./ng-cee-core-tree-renderer.component-W51n06MU.mjs').then(m => m.TreeRendererComponent);
        }),
        Tab: defer(() => {
            return import('./ng-cee-core-tab-renderer.component-BklfHVWJ.mjs').then(m => m.TabRendererComponent);
        }),
        Accordion: defer(() => {
            return import('./ng-cee-core-accordion-renderer.component-Dktp3JsQ.mjs').then(m => m.AccordionRendererComponent);
        }),
        Table: defer(() => {
            return import('./ng-cee-core-cee-table.component-Dj5GWWHv.mjs').then(m => m.CeeTableComponent);
        }),
        'Table-V2': defer(() => {
            return import('./ng-cee-core-cee-table-v2.component-DJIUef9R.mjs').then(m => m.CeeTableV2Component);
        }),
        DragAndDropList: defer(() => {
            return import('./ng-cee-core-drag-and-drop-list.component-BJ70Mxn_.mjs').then(m => m.DragAndDropListComponent);
        }),
        profileImage: defer(() => {
            return import('./ng-cee-core-cee-profile-image.component-RXkFPn1m.mjs').then(m => m.CeeProfileImageComponent);
        }),
        Popover: defer(() => {
            return import('./ng-cee-core-Popover.component-CWyWSpsO.mjs').then(m => m.SelectComponent);
        }),
        GlobalSearch: defer(() => {
            return import('./ng-cee-core-global-search.component-DNILzKdk.mjs').then(m => m.GlobalSearchComponent);
        })
    };
    constructor() {
        if (localStorage.getItem('is_bootstrap') === 'true') {
            this.is_bootstrap = true;
        }
    }
    static ɵfac = function ViewRendererComponent_Factory(t) { return new (t || ViewRendererComponent)(); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ViewRendererComponent, selectors: [["app-view-renderer"]], inputs: { stepId: "stepId", field: "field", position: "position", templateId: "templateId", rowData: "rowData", rootData: "rootData", mandatoryCondition: "mandatoryCondition", editableCondition: "editableCondition", visibleCondition: "visibleCondition" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 53, vars: 57, consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngComponentOutlet", "ngComponentOutletInputs"]], template: function ViewRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementContainerStart(0, 0);
            i0.ɵɵtemplate(1, ViewRendererComponent_ng_container_1_Template, 4, 15, "ng-container", 1)(2, ViewRendererComponent_ng_container_2_Template, 4, 15, "ng-container", 1)(3, ViewRendererComponent_ng_container_3_Template, 4, 15, "ng-container", 1)(4, ViewRendererComponent_ng_container_4_Template, 4, 15, "ng-container", 1)(5, ViewRendererComponent_ng_container_5_Template, 4, 15, "ng-container", 1)(6, ViewRendererComponent_ng_container_6_Template, 4, 15, "ng-container", 1)(7, ViewRendererComponent_ng_container_7_Template, 4, 12, "ng-container", 1)(8, ViewRendererComponent_ng_container_8_Template, 4, 12, "ng-container", 1)(9, ViewRendererComponent_ng_container_9_Template, 4, 15, "ng-container", 1)(10, ViewRendererComponent_ng_container_10_Template, 4, 12, "ng-container", 1)(11, ViewRendererComponent_ng_container_11_Template, 4, 12, "ng-container", 1)(12, ViewRendererComponent_ng_container_12_Template, 4, 15, "ng-container", 1)(13, ViewRendererComponent_ng_container_13_Template, 4, 12, "ng-container", 1)(14, ViewRendererComponent_ng_container_14_Template, 4, 15, "ng-container", 1)(15, ViewRendererComponent_ng_container_15_Template, 4, 15, "ng-container", 1)(16, ViewRendererComponent_ng_container_16_Template, 4, 15, "ng-container", 1)(17, ViewRendererComponent_ng_container_17_Template, 4, 15, "ng-container", 1)(18, ViewRendererComponent_ng_container_18_Template, 4, 12, "ng-container", 1)(19, ViewRendererComponent_ng_container_19_Template, 4, 15, "ng-container", 1)(20, ViewRendererComponent_ng_container_20_Template, 4, 11, "ng-container", 1)(21, ViewRendererComponent_ng_container_21_Template, 4, 11, "ng-container", 1)(22, ViewRendererComponent_ng_container_22_Template, 4, 11, "ng-container", 1)(23, ViewRendererComponent_ng_container_23_Template, 4, 12, "ng-container", 1)(24, ViewRendererComponent_ng_container_24_Template, 3, 9, "ng-container", 1)(25, ViewRendererComponent_ng_container_25_Template, 4, 15, "ng-container", 1)(26, ViewRendererComponent_ng_container_26_Template, 4, 10, "ng-container", 1)(27, ViewRendererComponent_ng_container_27_Template, 3, 9, "ng-container", 1)(28, ViewRendererComponent_ng_container_28_Template, 4, 15, "ng-container", 1)(29, ViewRendererComponent_ng_container_29_Template, 4, 15, "ng-container", 1)(30, ViewRendererComponent_ng_container_30_Template, 4, 14, "ng-container", 1)(31, ViewRendererComponent_ng_container_31_Template, 4, 14, "ng-container", 1)(32, ViewRendererComponent_ng_container_32_Template, 4, 14, "ng-container", 1)(33, ViewRendererComponent_ng_container_33_Template, 4, 14, "ng-container", 1)(34, ViewRendererComponent_ng_container_34_Template, 4, 12, "ng-container", 1)(35, ViewRendererComponent_ng_container_35_Template, 4, 12, "ng-container", 1)(36, ViewRendererComponent_ng_container_36_Template, 4, 11, "ng-container", 1)(37, ViewRendererComponent_ng_container_37_Template, 4, 12, "ng-container", 1)(38, ViewRendererComponent_ng_container_38_Template, 4, 12, "ng-container", 1)(39, ViewRendererComponent_ng_container_39_Template, 3, 10, "ng-container", 1)(40, ViewRendererComponent_ng_container_40_Template, 3, 9, "ng-container", 1)(41, ViewRendererComponent_ng_container_41_Template, 3, 9, "ng-container", 1)(42, ViewRendererComponent_ng_container_42_Template, 3, 12, "ng-container", 1)(43, ViewRendererComponent_ng_container_43_Template, 4, 15, "ng-container", 1)(44, ViewRendererComponent_ng_container_44_Template, 4, 15, "ng-container", 1)(45, ViewRendererComponent_ng_container_45_Template, 4, 15, "ng-container", 1)(46, ViewRendererComponent_ng_container_46_Template, 4, 15, "ng-container", 1)(47, ViewRendererComponent_ng_container_47_Template, 4, 15, "ng-container", 1)(48, ViewRendererComponent_ng_container_48_Template, 4, 15, "ng-container", 1)(49, ViewRendererComponent_ng_container_49_Template, 4, 12, "ng-container", 1)(50, ViewRendererComponent_ng_container_50_Template, 4, 13, "ng-container", 1)(51, ViewRendererComponent_ng_container_51_Template, 4, 12, "ng-container", 1)(52, ViewRendererComponent_ng_container_52_Template, 4, 12, "ng-container", 1);
            i0.ɵɵelementContainerEnd();
        } if (rf & 2) {
            i0.ɵɵproperty("ngSwitch", ctx.field.field_type);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Tag");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "label");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "APIValidations");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "ticker");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Textarea");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Textfield");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Link");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Video");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Password");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Switch");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Camera");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Date");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Image");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "radio");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "StarRating");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Checkbox");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Picker");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Menu");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Button");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Previous");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Submit");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Next");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Timepicker");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "PhoneNumber");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Generic Block");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Breadcrumb View");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "ToggleButton");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Repeatable Block");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "RBLite");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", i0.ɵɵpureFunction0(53, _c0$7).includes(ctx.field.field_type) ? ctx.field.field_type : "");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", i0.ɵɵpureFunction0(54, _c1$6).includes(ctx.field.field_type) ? ctx.field.field_type : "");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "DynamicForm");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "TreeView");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Tab");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Accordion");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Carousel");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", i0.ɵɵpureFunction0(55, _c2$1).includes(ctx.field.field_type) ? ctx.field.field_type : "");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", i0.ɵɵpureFunction0(56, _c3$1).includes(ctx.field.field_type) ? ctx.field.field_type : "");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Map");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Chart");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Captcha");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Autocomplete Textfield");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Attachments");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Editor");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "TimeSlots");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Calendar");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Number");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Attachment Block");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "DragAndDropList");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "profileImage");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "Popover");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", "GlobalSearch");
        } }, dependencies: [NgSwitch, CommonModule, i13.NgComponentOutlet, i13.NgSwitchCase, i13.AsyncPipe, FormsModule] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ViewRendererComponent, [{
        type: Component,
        args: [{ selector: 'app-view-renderer', standalone: true, imports: [NgSwitch, CommonModule, FormsModule], template: "<ng-container [ngSwitch]=\"field.field_type\">\r\n    <ng-container *ngSwitchCase=\"'Tag'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-tag [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-tag> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'label'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-label [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n            [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-label> -->\r\n    </ng-container> \r\n\r\n    <ng-container *ngSwitchCase=\"'APIValidations'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-label [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n            [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-label> -->\r\n    </ng-container> \r\n\r\n\r\n    <ng-container *ngSwitchCase=\"'ticker'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-ticker [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n            [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-ticker> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Textarea'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-textarea [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-textarea> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Textfield'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-textfield [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-textfield> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Link'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-link [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\">\r\n        </app-cee-link> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Video'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-video [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\">\r\n        </app-cee-video> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Password'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap['Textfield'] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-textfield [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-textfield> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Switch'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-switch [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [keepState]=\"true\">\r\n        </app-cee-switch> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Camera'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-camera [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [keepState]=\"true\">\r\n        </app-cee-camera> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Date'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-date [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-date> -->\r\n    </ng-container>\r\n\r\n    <!-- <ng-container *ngSwitchCase=\"'slider'\">\r\n        <app-cee-slider [stepId]=\"stepId\" [fieldData]=\"field\" class=\"field-{{ position }}\" [rowData]=\"rowData\"></app-cee-slider>\r\n    </ng-container> -->\r\n\r\n    <ng-container *ngSwitchCase=\"'Image'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-image [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\">\r\n        </app-cee-image> -->\r\n    </ng-container>\r\n\r\n    <!-- <ng-container *ngSwitchCase=\"'Signature'\">\r\n                <app-cee-signature  [fieldData]=\"field\" class=\"field-{{position}}\" [rowData]=\"rowData\"></app-cee-signature>\r\n            </ng-container>   -->\r\n\r\n    <ng-container *ngSwitchCase=\"'radio'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-radio [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-radio> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'StarRating'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Checkbox'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-checkbox [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-checkbox> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Picker'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-picker [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-picker> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Menu'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-menu [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\">\r\n        </app-cee-menu> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Button'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-button [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n            [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-button> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Previous'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap['Button'] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-button [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\">\r\n        </app-cee-button> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Submit'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-button [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\">\r\n        </app-cee-button> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Next'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-button [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\">\r\n        </app-cee-button> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Timepicker'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-time-picker [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [keepState]=\"true\" [rowData]=\"rowData\"></app-cee-time-picker> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'PhoneNumber'\">\r\n        <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n        inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n        }\"\r\n        ></ng-container>\r\n        <!-- <app-cee-phone-number [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [keepState]=\"true\" [rowData]=\"rowData\"></app-cee-phone-number> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Generic Block'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, fieldData: field, blockPosition: '0',\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <generic-block-renderer [stepId]=\"stepId\" [templateId]=\"templateId\" [fieldData]=\"field\" [rootData]=\"rootData\"\r\n            [blockPosition]=\"0\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n            [visibleCondition]=\"visibleCondition\">\r\n        </generic-block-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Breadcrumb View'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-breadcrumb-renderer [stepId]=\"stepId\" [fieldData]=\"field\" class=\"field-{{ position }}\">\r\n        </app-breadcrumb-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'ToggleButton'\">\r\n        <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n        inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n        }\"\r\n        ></ng-container>\r\n        <!-- <app-cee-toggle-button [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\">\r\n        </app-cee-toggle-button> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Repeatable Block'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, fieldData: field,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'RBLite'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, fieldData: field,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n    </ng-container>\r\n\r\n    <ng-container\r\n        *ngSwitchCase=\"['List', 'List-Single-Select', 'List-Multi-Select', 'List-Expandable'].includes(field.field_type) ? field.field_type : ''\">\r\n        <div class=\"field-{{ position }} {{field.field_style?field.field_style.custom_class_name:''}}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap['List'] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, sectionData: field, type: field.field_type\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-list-renderer [sectionData]=\"field\" [stepId]=\"stepId\" [templateId]=\"templateId\" [type]=\"field.field_type\"\r\n            class=\"{{field.field_style?field.field_style.custom_class_name:''}}\" [rootData]=\"rootData\">\r\n        </app-list-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container\r\n        *ngSwitchCase=\"['List-V2', 'List-Single-Select-V2', 'List-Multi-Select-V2', 'List-Expandable-V2'].includes(field.field_type) ? field.field_type : ''\">\r\n        <div class=\"field-{{ position }} {{field.field_style?field.field_style.custom_class_name:''}}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap['List-V2'] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, sectionData: field, type: field.field_type\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-list-renderer-v2 [sectionData]=\"field\" [stepId]=\"stepId\" [templateId]=\"templateId\" [type]=\"field.field_type\"\r\n            class=\"{{field.field_style?field.field_style.custom_class_name:''}}\" [rootData]=\"rootData\">\r\n        </app-list-renderer-v2> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'DynamicForm'\">\r\n        <div class=\"field-{{ position }} {{field.field_style?field.field_style.custom_class_name:''}}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, sectionData: field, type: field.field_type\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-dynamic-form [sectionData]=\"field\" [stepId]=\"stepId\" [templateId]=\"templateId\" [type]=\"field.field_type\"\r\n            class=\"{{field.field_style?field.field_style.custom_class_name:''}}\" [rootData]=\"rootData\">\r\n        </app-dynamic-form> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'TreeView'\">\r\n        <div class=\"field-{{ position }} {{field.field_style?field.field_style.custom_class_name:''}}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, sectionData: field, type: field.field_type\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-tree-renderer [sectionData]=\"field\" [stepId]=\"stepId\" [templateId]=\"templateId\" [type]=\"field.field_type\"\r\n            class=\"{{field.field_style?field.field_style.custom_class_name:''}}\" [rootData]=\"rootData\">\r\n        </app-tree-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Tab'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-tab-renderer [fieldData]=\"field\" [stepId]=\"stepId\" [templateId]=\"templateId\" [rootData]=\"rootData\">\r\n        </app-tab-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Accordion'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, sectionData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-accordion-renderer [sectionData]=\"field\" [stepId]=\"stepId\" [templateId]=\"templateId\" [rootData]=\"rootData\">\r\n        </app-accordion-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Carousel'\">\r\n        <div class=\"field-{{ position }} {{field.field_style?field.field_style.custom_class_name:''}}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-carousel [fieldData]=\"field\" [stepId]=\"stepId\">\r\n        </app-cee-carousel> -->\r\n    </ng-container>\r\n\r\n    <ng-container\r\n        *ngSwitchCase=\"['Table', 'Table-Single-Select', 'Table-Multi-Select', 'Table-Expandable'].includes(field.field_type) ? field.field_type : ''\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap['Table'] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, sectionData: field, type: field.field_type,\r\n                paginateValue: '', fieldData: ''\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-table [stepId]=\"stepId\" [paginateValue]=\"\" [fieldData]=\"\" [sectionData]=\"field\"\r\n            [type]=\"field.field_type\" [rootData]=\"rootData\">\r\n        </app-cee-table> -->\r\n    </ng-container>\r\n\r\n    <ng-container\r\n        *ngSwitchCase=\"['Table-V2', 'Table-Single-Select-V2', 'Table-Multi-Select-V2', 'Table-Expandable-V2'].includes(field.field_type) ? field.field_type : ''\">\r\n        <div class=\"field-{{ position }} \">\r\n            <ng-container *ngComponentOutlet=\"componentMap['Table-V2'] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, sectionData: field, type: field.field_type,\r\n                paginateValue: '', fieldData: ''\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-table-v2 [stepId]=\"stepId\" [paginateValue]=\"\" [fieldData]=\"\" [sectionData]=\"field\"\r\n            [type]=\"field.field_type\" [rootData]=\"rootData\">\r\n        </app-cee-table-v2> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'Map'\">\r\n        <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n        inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, visibleCondition: visibleCondition\r\n        }\"\r\n        ></ng-container>\r\n        <!-- <app-cee-map [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-map> -->\r\n    </ng-container>\r\n    <ng-container *ngSwitchCase=\"'Chart'\">\r\n        <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n        inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field\r\n        }\"\r\n        ></ng-container>\r\n        <!-- <app-cee-chart [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\">\r\n        </app-cee-chart> -->\r\n    </ng-container>\r\n    <ng-container *ngSwitchCase=\"'Captcha'\">\r\n        <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n        inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n        }\"\r\n        ></ng-container>\r\n        <!-- <app-cee-captcha [stepId]=\"stepId\" [fieldData]=\"field\" [keepState]=\"true\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [rootData]=\"rootData\">\r\n        </app-cee-captcha> -->\r\n    </ng-container>\r\n    <ng-container *ngSwitchCase=\"'Autocomplete Textfield'\">\r\n        <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n        inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n            mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n        }\"\r\n        ></ng-container>\r\n        <!-- <app-cee-auto-complete [stepId]=\"stepId\" [fieldData]=\"field\" [keepState]=\"true\" class=\"field-{{ position }}\"\r\n            [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n            [visibleCondition]=\"visibleCondition\" [rootData]=\"rootData\">\r\n        </app-cee-auto-complete> -->\r\n    </ng-container>\r\n\r\n    <!-- Attachments -->\r\n    <ng-container *ngSwitchCase=\"'Attachments'\">\r\n        <div class=\"field-{{ position }} \">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-attachments [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-attachments> -->\r\n    </ng-container>\r\n\r\n       <!-- Editor -->\r\n       <ng-container *ngSwitchCase=\"'Editor'\">\r\n        <div class=\"field-{{ position }} \">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n    </ng-container>\r\n\r\n    <!-- TimeSlots -->\r\n    <ng-container *ngSwitchCase=\"'TimeSlots'\">\r\n        <div class=\"field-{{ position }} \">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-time-slots [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-time-slots> -->\r\n    </ng-container>\r\n\r\n    <!-- Calendar -->\r\n    <ng-container *ngSwitchCase=\"'Calendar'\">\r\n        <div class=\"field-{{ position }} \">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-calendar [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-calendar> -->\r\n    </ng-container>\r\n\r\n    <!-- Number textbox -->\r\n    <ng-container *ngSwitchCase=\"'Number'\">\r\n        <div class=\"field-{{ position }} \">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true,\r\n                mandatoryCondition: mandatoryCondition, editableCondition: editableCondition, visibleCondition: visibleCondition\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-cee-number [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n            class=\"field-{{ position }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\"\r\n            [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n        </app-cee-number> -->\r\n    </ng-container>\r\n\r\n\r\n    <ng-container *ngSwitchCase=\"'Attachment Block'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap['Generic Block'] | async; \r\n            inputs: {stepId: stepId, templateId: templateId, rootData: rootData, fieldData: field,\r\n                isAttachmentBlock: 'true', mandatoryCondition: mandatoryCondition, editableCondition: editableCondition,\r\n                visibleCondition: visibleCondition, blockPosition: '0'\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <generic-block-renderer [stepId]=\"stepId\" [templateId]=\"templateId\" [fieldData]=\"field\" [rootData]=\"rootData\"\r\n            [blockPosition]=\"0\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n            [visibleCondition]=\"visibleCondition\" [rootData]=\"rootData\" [isAttachmentBlock]=\"true\">\r\n        </generic-block-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'DragAndDropList'\">\r\n        <div class=\"field-{{ position }} {{field.field_style?field.field_style.custom_class_name:''}}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, fieldData: field\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n        <!-- <app-drag-and-drop-list [fieldData]=\"field\" [stepId]=\"stepId\"\r\n            class=\"{{field.field_style?field.field_style.custom_class_name:''}}\" [rootData]=\"rootData\">\r\n        </app-drag-and-drop-list> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"'profileImage'\">\r\n        <div class=\"field-{{ position }} {{field.field_style?field.field_style.custom_class_name:''}}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n            }; \"\r\n            ></ng-container>\r\n        </div>\r\n    </ng-container>\r\n    <ng-container *ngSwitchCase=\"'Popover'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n    </ng-container>\r\n    <ng-container *ngSwitchCase=\"'GlobalSearch'\">\r\n        <div class=\"field-{{ position }}\">\r\n            <ng-container *ngComponentOutlet=\"componentMap[field.field_type] | async; \r\n            inputs: {stepId: stepId, rootData: rootData, rowData: rowData, fieldData: field, keepState: true\r\n            }\"\r\n            ></ng-container>\r\n        </div>\r\n    </ng-container>\r\n</ng-container>\r\n" }]
    }], () => [], { stepId: [{
            type: Input
        }], field: [{
            type: Input
        }], position: [{
            type: Input
        }], templateId: [{
            type: Input
        }], rowData: [{
            type: Input
        }], rootData: [{
            type: Input
        }], mandatoryCondition: [{
            type: Input
        }], editableCondition: [{
            type: Input
        }], visibleCondition: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(ViewRendererComponent, { className: "ViewRendererComponent", filePath: "lib\\components\\view-renderer\\view-renderer.component.ts", lineNumber: 13 }); })();

function BlockRendererComponent_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelement(1, "app-dynamic-renderer", 5);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("cee_loader cee_loader_", ctx_r0.blockRenderedData.block_id, "");
} }
function BlockRendererComponent_ng_container_0_ng_container_3_header_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-view-renderer", 9);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r2 = ctx.$implicit;
    const pos_r3 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate3("app-view-renderer-", ctx_r0.blockRenderedData.block_id, "-", pos_r3, " ", field_r2.field_style ? ctx_r0.commonUtil.bootstrapColClass(field_r2.field_style.bootstrap_class_name, ctx_r0.is_bootstrap, "", ctx_r0.conditionalUtil.evaluteBootstrapCondition(field_r2)) : "", "");
    i0.ɵɵproperty("stepId", ctx_r0.stepId)("field", field_r2)("position", pos_r3)("templateId", ctx_r0.templateId)("rootData", ctx_r0.rootData)("mandatoryCondition", ctx_r0.mandatoryCondition)("editableCondition", ctx_r0.editableCondition)("visibleCondition", ctx_r0.visibleCondition);
} }
function BlockRendererComponent_ng_container_0_ng_container_3_header_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "header", 7);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_ng_container_3_header_1_ng_container_1_Template, 2, 13, "ng-container", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate5("cee-block block-header  template-", ctx_r0.templateId, " block-", ctx_r0.blockRenderedData.block_id, "  block-", ctx_r0.blockPosition, " ", ctx_r0.blockRenderedData.block_style ? ctx_r0.blockRenderedData.block_style.custom_class_name : "", " ", ctx_r0.is_bootstrap ? "row" : "", "");
    i0.ɵɵpropertyInterpolate("id", ctx_r0.blockRenderedData.block_id);
    i0.ɵɵproperty("hidden", ctx_r0.loader.showSection || !ctx_r0.isVisible);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.blockRenderedData.block_fields)("ngForTrackBy", ctx_r0.trackById);
} }
function BlockRendererComponent_ng_container_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_ng_container_3_header_1_Template, 2, 11, "header", 6);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.blockRenderedData);
} }
function BlockRendererComponent_ng_container_0_ng_container_4_div_1_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "li", 12);
    i0.ɵɵelement(2, "app-view-renderer", 9);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r5 = ctx.$implicit;
    const pos_r6 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate4("app-view-renderer-", ctx_r0.blockRenderedData.block_id, "-", pos_r6, " ", field_r5.field_style ? ctx_r0.commonUtil.bootstrapColClass(field_r5.field_style.bootstrap_class_name, ctx_r0.is_bootstrap, "", ctx_r0.conditionalUtil.evaluteBootstrapCondition(field_r5)) : "", " ", ctx_r0.setActiveItem(field_r5), "");
    i0.ɵɵproperty("stepId", ctx_r0.stepId)("field", field_r5)("position", pos_r6)("templateId", ctx_r0.templateId)("rootData", ctx_r0.rootData)("mandatoryCondition", ctx_r0.mandatoryCondition)("editableCondition", ctx_r0.editableCondition)("visibleCondition", ctx_r0.visibleCondition);
} }
function BlockRendererComponent_ng_container_0_ng_container_4_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 7)(1, "button", 10);
    i0.ɵɵlistener("click", function BlockRendererComponent_ng_container_0_ng_container_4_div_1_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r4); const ctx_r0 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r0.toggleNav()); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(2, "nav")(3, "ul", 11);
    i0.ɵɵtemplate(4, BlockRendererComponent_ng_container_0_ng_container_4_div_1_ng_container_4_Template, 3, 14, "ng-container", 8);
    i0.ɵɵelementEnd()()();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate5("cee-block block-navbar   template-", ctx_r0.templateId, " block-", ctx_r0.blockRenderedData.block_id, "  block-", ctx_r0.blockPosition, " ", ctx_r0.blockRenderedData.block_style ? ctx_r0.blockRenderedData.block_style.custom_class_name : "", "  ", ctx_r0.hiddennavContainerCssClass, "");
    i0.ɵɵpropertyInterpolate("id", ctx_r0.blockRenderedData.block_id);
    i0.ɵɵproperty("hidden", ctx_r0.loader.showSection || !ctx_r0.isVisible);
    i0.ɵɵattribute("aria-label", ctx_r0.additionalParameter["Aria-Label"] ? ctx_r0.additionalParameter["Aria-Label"] : undefined)("role", ctx_r0.additionalParameter["Aria-Role"]);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate2("nav-container ", ctx_r0.hiddenNavCssClass, "  ", ctx_r0.additionalParameter["slidePosition"] || "top", "");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r0.blockRenderedData.block_fields)("ngForTrackBy", ctx_r0.trackById);
} }
function BlockRendererComponent_ng_container_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_ng_container_4_div_1_Template, 5, 17, "div", 6);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.blockRenderedData);
} }
function BlockRendererComponent_ng_container_0_ng_container_5_footer_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-view-renderer", 13);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r7 = ctx.$implicit;
    const pos_r8 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate3("app-view-renderer-", ctx_r0.blockRenderedData.block_id, "-", pos_r8, " ", field_r7.field_style ? ctx_r0.commonUtil.bootstrapColClass(field_r7.field_style.bootstrap_class_name, ctx_r0.is_bootstrap, "", ctx_r0.conditionalUtil.evaluteBootstrapCondition(field_r7)) : "", "");
    i0.ɵɵproperty("stepId", ctx_r0.stepId)("field", field_r7)("position", pos_r8)("templateId", ctx_r0.templateId)("rootData", ctx_r0.rootData)("mandatoryCondition", ctx_r0.mandatoryCondition)("editableCondition", ctx_r0.editableCondition)("visibleCondition", ctx_r0.visibleCondition)("rowData", ctx_r0.generateRowData(field_r7));
} }
function BlockRendererComponent_ng_container_0_ng_container_5_footer_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "footer", 7);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_ng_container_5_footer_1_ng_container_1_Template, 2, 14, "ng-container", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate5("cee-block block-footer template-", ctx_r0.templateId, " block-", ctx_r0.blockRenderedData.block_id, "  block-", ctx_r0.blockPosition, " ", ctx_r0.blockRenderedData.block_style ? ctx_r0.blockRenderedData.block_style.custom_class_name : "", " ", ctx_r0.is_bootstrap ? "row" : "", "");
    i0.ɵɵpropertyInterpolate("id", ctx_r0.blockRenderedData.block_id);
    i0.ɵɵproperty("hidden", ctx_r0.loader.showSection || !ctx_r0.isVisible);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.blockRenderedData.block_fields)("ngForTrackBy", ctx_r0.trackById);
} }
function BlockRendererComponent_ng_container_0_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_ng_container_5_footer_1_Template, 2, 11, "footer", 6);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.blockRenderedData);
} }
function BlockRendererComponent_ng_container_0_ng_container_6_section_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-view-renderer", 13);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r9 = ctx.$implicit;
    const pos_r10 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate3("app-view-renderer-", ctx_r0.blockRenderedData.block_id, "-", pos_r10, " ", field_r9.field_style ? ctx_r0.commonUtil.bootstrapColClass(field_r9.field_style.bootstrap_class_name, ctx_r0.is_bootstrap, ctx_r0.rootData.templateClass, ctx_r0.conditionalUtil.evaluteBootstrapCondition(field_r9)) : "", "");
    i0.ɵɵproperty("stepId", ctx_r0.stepId)("field", field_r9)("position", pos_r10)("templateId", ctx_r0.templateId)("rootData", ctx_r0.rootData)("mandatoryCondition", ctx_r0.mandatoryCondition)("editableCondition", ctx_r0.editableCondition)("visibleCondition", ctx_r0.visibleCondition)("rowData", ctx_r0.generateRowData(field_r9));
} }
function BlockRendererComponent_ng_container_0_ng_container_6_section_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "section", 15);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_ng_container_6_section_1_ng_container_1_Template, 2, 14, "ng-container", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate5("cee-block template-", ctx_r0.templateId, " block-", ctx_r0.blockRenderedData.block_id, "  block-", ctx_r0.blockPosition, " ", ctx_r0.blockRenderedData.block_style ? ctx_r0.blockRenderedData.block_style.custom_class_name : "", " ", ctx_r0.is_bootstrap ? "row" : "", "");
    i0.ɵɵpropertyInterpolate("id", ctx_r0.blockRenderedData.block_id);
    i0.ɵɵproperty("hidden", ctx_r0.loader.showSection || !ctx_r0.isVisible);
    i0.ɵɵattribute("aria-label", ctx_r0.additionalParameter["Aria-Label"] ? ctx_r0.additionalParameter["Aria-Label"] : undefined)("role", ctx_r0.additionalParameter["Aria-Role"]);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.blockRenderedData.block_fields)("ngForTrackBy", ctx_r0.trackById);
} }
function BlockRendererComponent_ng_container_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_ng_container_6_section_1_Template, 2, 13, "section", 14);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.blockRenderedData);
} }
function BlockRendererComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, BlockRendererComponent_ng_container_0_div_1_Template, 2, 3, "div", 1);
    i0.ɵɵelementContainerStart(2, 2);
    i0.ɵɵtemplate(3, BlockRendererComponent_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 3)(4, BlockRendererComponent_ng_container_0_ng_container_4_Template, 2, 1, "ng-container", 3)(5, BlockRendererComponent_ng_container_0_ng_container_5_Template, 2, 1, "ng-container", 3)(6, BlockRendererComponent_ng_container_0_ng_container_6_Template, 2, 1, "ng-container", 4);
    i0.ɵɵelementContainerEnd()();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.loader.showSection);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngSwitch", ctx_r0.blockRenderedData.block_name);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngSwitchCase", "Header");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngSwitchCase", "Hamburgermenu");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngSwitchCase", "Footer");
} }
class BlockRendererComponent {
    http;
    router;
    sharedEventsService;
    appDataService;
    apiDataService;
    wfeStepLoaderService;
    cdRef;
    autoPreviewConfigPath = localStorage.getItem('ENABLE_AUTO_PREVIEW')?.toLowerCase() == "true" && localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') ? localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') : 'assets/config';
    configBlockPath = this.autoPreviewConfigPath + '/application_blocks/application_blocks_';
    stepId;
    blockId;
    blockPosition;
    templateId;
    rootData;
    blockRenderedData;
    emitterObj = {};
    isVisible = true;
    additionalParameter = {};
    is_bootstrap = false;
    commonUtil;
    conditionalUtil;
    generateUtil;
    loader = {
        name: 'CEE_LOADER',
        showSection: false
    };
    mandatoryCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    editableCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    visibleCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    hiddenNavCssClass = '';
    hiddennavContainerCssClass = '';
    constructor(http, router, sharedEventsService, appDataService, apiDataService, wfeStepLoaderService, cdRef) {
        this.http = http;
        this.router = router;
        this.sharedEventsService = sharedEventsService;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.wfeStepLoaderService = wfeStepLoaderService;
        this.cdRef = cdRef;
        this.commonUtil = new CommonUtil();
        this.conditionalUtil = new ConditionalUtil(false, appDataService, apiDataService);
        this.generateUtil = new GenerateFieldRow(this.appDataService);
        if (localStorage.getItem('is_bootstrap') === 'true') {
            this.is_bootstrap = true;
        }
    }
    trackById(index, item) {
        return item.unique_id;
    }
    async ngOnInit() {
        let data = this.wfeStepLoaderService.searchBlockDataFromCache(this.blockId);
        if (!data) {
            data = typeof (this.blockId) === 'string' ?
                await this.wfeStepLoaderService.loadBlockByName(this.blockId).toPromise() : this.blockId;
        }
        this.blockRenderedData = this.commonUtil.blockBootstrapProcess(data);
        this.cdRef.detectChanges();
        this.toggleNav();
        this.emitterObj[this.blockRenderedData.block_id + '_toggle_nav'] = this.sharedEventsService.hamburgermenuEmitter.subscribe((res) => {
            this.toggleNav();
        });
        if (this.blockRenderedData.additional_parameters && this.blockRenderedData.additional_parameters.length > 0) {
            for (const paramter of this.blockRenderedData.additional_parameters) {
                this.additionalParameter[paramter.parameter_type] = paramter.value;
                switch (paramter.parameter_type) {
                    case 'Loader Handler name':
                        this.emitterObj[this.blockRenderedData.block_id + '_customSectionLoaderEmitter'] =
                            this.sharedEventsService.customSectionLoaderEmitter.subscribe((res) => {
                                if (this.additionalParameter['Loader Handler name'].split('|').map(str => str.trim()).includes(res.handlerName)) {
                                    this.loader.showSection = res.loading;
                                }
                            });
                        break;
                    case 'OverrideConditions':
                        if (paramter.value && paramter.value !== 'NONE' && paramter.value !== 'ALL') {
                            const fields = paramter.value.split('|').map(val => val.trim());
                            this.mandatoryCondition.fields = fields;
                            this.editableCondition.fields = fields;
                            this.visibleCondition.fields = fields;
                        }
                        break;
                    case 'ExceptionConditions':
                        const fields = paramter.value.split('|').map(val => val.trim());
                        this.mandatoryCondition.exceptionFields = fields;
                        this.editableCondition.exceptionFields = fields;
                        this.visibleCondition.exceptionFields = fields;
                        break;
                    case 'expand':
                        this.toggleNav();
                        break;
                    default:
                }
            }
        }
        // subscribe to field changes
        if (this.blockRenderedData.conditional_visible) {
            if (this.blockRenderedData.conditional_visible.length > 0 ||
                this.blockRenderedData.conditional_editable.length > 0 ||
                this.blockRenderedData.conditional_mandatory.length > 0) {
                this.emitterObj[this.blockRenderedData.block_id + '_emitOnDataSetOrUpdatedForBlock'] =
                    this.sharedEventsService.emitOnDataSetOrUpdatedForBlock.subscribe((res) => {
                        this.onFieldDataUpdated(res.apiKey, res.value);
                    });
            }
            if (this.blockRenderedData.conditional_visible.length > 0) {
                this.visibleCondition.isActive = true;
            }
        }
        if (this.blockRenderedData.conditional_editable && this.blockRenderedData.conditional_editable.length > 0) {
            this.editableCondition.isActive = true;
        }
        if (this.blockRenderedData.conditional_mandatory && this.blockRenderedData.conditional_mandatory.length > 0) {
            this.mandatoryCondition.isActive = true;
        }
        if (!this.rootData && Object.keys(this.rootData).length) {
            if (this.wfeStepLoaderService.rootData && Object.keys(this.wfeStepLoaderService.rootData).length) {
                this.rootData = this.wfeStepLoaderService.rootData;
            }
            else {
                this.rootData = {};
                this.rootData['blockFields'] = {};
            }
        }
        this.rootData['blockFields'][this.blockRenderedData.block_id] = [];
        for (let field of this.blockRenderedData.block_fields) {
            this.rootData['blockFields'][this.blockRenderedData.block_id].push(field.unique_id);
        }
    }
    // Uses cases for the following function
    // 1: override NONE child can override r override all false;
    // 2: override ALL child cannot override;
    // 3: when value is false child cannot override
    // 4: when value is true and override condition is not NONE or ALL and override condition
    // has pipe separated field values then only those fields will be overridden set override to true
    onFieldDataUpdated(fieldId, value) {
        if (this.additionalParameter.OverrideConditions !== 'NONE') {
            const display = this.conditionalUtil.checkVisibility(this.blockRenderedData, fieldId, value);
            if (display !== undefined) {
                this.isVisible = display;
                this.visibleCondition.value = display;
                this.setOverride(display, 'visibleCondition');
            }
            const editable = this.conditionalUtil.checkEditable(this.blockRenderedData, fieldId, value);
            if (editable !== undefined) {
                this.editableCondition.value = editable;
                this.setOverride(editable, 'editableCondition');
            }
            const mandatory = this.conditionalUtil.checkMandatory(this.blockRenderedData, fieldId, value);
            if (mandatory !== undefined) {
                this.mandatoryCondition.value = mandatory;
                this.setOverride(mandatory, 'mandatoryCondition');
            }
            this.visibleCondition = JSON.parse(JSON.stringify(this.visibleCondition));
            this.editableCondition = JSON.parse(JSON.stringify(this.editableCondition));
            this.mandatoryCondition = JSON.parse(JSON.stringify(this.mandatoryCondition));
        }
    }
    setOverride(property, value) {
        if (!this.additionalParameter.hasOwnProperty('OverrideConditions')) {
            return;
        }
        // use case 1
        if (this.additionalParameter.OverrideConditions === 'NONE') {
            this[value].overrideAll = false;
            this[value].override = false;
        }
        // use case 2 and 3
        if (!property || this.additionalParameter.OverrideConditions === 'ALL') {
            this[value].overrideAll = true;
            this[value].override = true;
        }
        // use case 4
        if (property && this.additionalParameter.OverrideConditions !== 'NONE' &&
            this.additionalParameter.OverrideConditions !== 'ALL' &&
            this[value].fields.length > 0) {
            this[value].overrideAll = false;
            this[value].override = true;
        }
    }
    ngOnDestroy() {
        for (const key in this.emitterObj) {
            if (this.emitterObj[key]) {
                this.emitterObj[key].unsubscribe();
            }
        }
    }
    generateRowData(field) {
        return this.generateUtil.generateRowData(field);
    }
    toggleNav() {
        this.hiddennavContainerCssClass = (this.hiddennavContainerCssClass) ? '' : 'hidden-nav-container';
        this.hiddenNavCssClass = (this.hiddenNavCssClass) ? '' : 'hidden-nav';
        window['navOpenStaus'] = (this.hiddenNavCssClass) ? false : true;
    }
    setActiveItem(field) {
        const activeItem = window.localStorage.getItem('active_item');
        if (activeItem && field.unique_id === activeItem) {
            return 'active-item';
        }
        return '';
    }
    onDocumentClick(event) {
        const clickedElement = event.target;
        // Check if SidebarCloseConfig is enabled
        if (this.additionalParameter['SidebarCloseConfig']) {
            const configValues = this.additionalParameter['SidebarCloseConfig'].split('|');
            const isEnabled = configValues[0]?.trim().toLowerCase() === 'true';
            const ctrlName = configValues[1]?.trim();
            if (isEnabled && ctrlName) {
                // Target the specific sidebar by ID
                const sidebarElement = document.getElementById(this?.blockId?.block_id);
                const hamburgerBtn = document.querySelector('[class*="hamburger"]');
                // Only proceed if the sidebar exists
                if (sidebarElement) {
                    const clickedInsideSidebar = sidebarElement.contains(clickedElement);
                    const clickedOnHamburger = hamburgerBtn && hamburgerBtn.contains(clickedElement);
                    // Check if clicked element is a navigation element (link, button with navigation)
                    const isNavigationElement = this.isNavigationElement(clickedElement);
                    // Close sidebar if:
                    // 1. Clicked outside both sidebar and hamburger, OR
                    // 2. Clicked inside sidebar on a navigation element
                    if (!clickedInsideSidebar && !clickedOnHamburger) {
                        this.closeNav(ctrlName);
                    }
                    else if (clickedInsideSidebar && isNavigationElement) {
                        // Close sidebar on navigation elements inside sidebar
                        setTimeout(() => this.closeNav(ctrlName), 100); // Small delay to ensure navigation starts
                    }
                }
            }
        }
    }
    isNavigationElement(element) {
        // Check if element or its parents are navigation elements
        let currentElement = element;
        while (currentElement && currentElement !== document.body) {
            // Check for links
            if (currentElement.tagName.toLowerCase() === 'a') {
                const href = currentElement.href;
                return href && href !== '#' && href !== 'javascript:void(0)';
            }
            // Check for buttons with navigation attributes
            if (currentElement.tagName.toLowerCase() === 'button' || currentElement.getAttribute('role') === 'button') {
                const hasNavAttributes = currentElement.hasAttribute('routerLink') ||
                    currentElement.hasAttribute('ng-reflect-router-link') ||
                    currentElement.getAttribute('data-navigate') ||
                    currentElement.classList.contains('nav-link') ||
                    currentElement.classList.contains('navigation') ||
                    currentElement.classList.contains('menu-btn') ||
                    currentElement.classList.contains('menu-item') ||
                    currentElement.getAttribute('aria-label')?.toLowerCase().includes('click on');
                if (hasNavAttributes)
                    return true;
            }
            // Check for elements with navigation classes or attributes
            if (currentElement.classList.contains('menu-item') ||
                currentElement.classList.contains('nav-item') ||
                currentElement.classList.contains('menu-btn') ||
                currentElement.hasAttribute('routerLink') ||
                currentElement.hasAttribute('ng-reflect-router-link') ||
                currentElement.getAttribute('aria-label')?.toLowerCase().includes('click on')) {
                return true;
            }
            currentElement = currentElement.parentElement;
        }
        return false;
    }
    closeNav(ctrlName) {
        const selector = `input[id*="${ctrlName}"]`;
        const checkbox = document.querySelector(selector);
        if (checkbox && checkbox.type === 'checkbox') {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }
    static ɵfac = function BlockRendererComponent_Factory(t) { return new (t || BlockRendererComponent)(i0.ɵɵdirectiveInject(i9.HttpClient), i0.ɵɵdirectiveInject(i11.Router), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(WfeStepLoaderService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: BlockRendererComponent, selectors: [["app-block-renderer"]], hostBindings: function BlockRendererComponent_HostBindings(rf, ctx) { if (rf & 1) {
            i0.ɵɵlistener("click", function BlockRendererComponent_click_HostBindingHandler($event) { return ctx.onDocumentClick($event); }, false, i0.ɵɵresolveDocument);
        } }, inputs: { stepId: "stepId", blockId: "blockId", blockPosition: "blockPosition", templateId: "templateId", rootData: "rootData" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], [3, "class", 4, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], ["moduleName", "CEE_LOADER"], [3, "hidden", "id", "class", 4, "ngIf"], [3, "hidden", "id"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "stepId", "field", "position", "templateId", "rootData", "mandatoryCondition", "editableCondition", "visibleCondition"], [1, "navbar-toggler", "toggle-btn", 3, "click"], [1, "navbar-nav", "mr-auto"], [1, "nav-item"], [3, "stepId", "field", "position", "templateId", "rootData", "mandatoryCondition", "editableCondition", "visibleCondition", "rowData"], [3, "id", "class", "hidden", 4, "ngIf"], [3, "id", "hidden"]], template: function BlockRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, BlockRendererComponent_ng_container_0_Template, 7, 5, "ng-container", 0);
        } if (rf & 2) {
            i0.ɵɵproperty("ngIf", ctx.blockRenderedData);
        } }, dependencies: [DynamicRendererComponent, NgSwitch, ViewRendererComponent, CommonModule, i13.NgForOf, i13.NgIf, i13.NgSwitchCase, i13.NgSwitchDefault], styles: [".block-header[_ngcontent-%COMP%]{grid-area:header}.nav-container[_ngcontent-%COMP%]{transform:translate(0)}.nav-container.right[_ngcontent-%COMP%]{transform:translate(0) scaleX(1);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.right.hidden-nav[_ngcontent-%COMP%]{transform:translate(100%) scaleX(0);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.left[_ngcontent-%COMP%]{transform:translate(0) scaleX(1);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.left.hidden-nav[_ngcontent-%COMP%]{transform:translate(-100%) scaleX(0);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.top[_ngcontent-%COMP%]{-webkit-transform:translateY(0px) scaleY(1);-moz-transform:translateY(0px) scaleY(1);transform:translateY(0) scaleY(1);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.top.hidden-nav[_ngcontent-%COMP%]{-webkit-transform:translateY(-200%) scaleY(0);-moz-transform:translateY(-200%) scaleY(0);transform:translateY(-100%) scaleY(0);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.ham-backpop[_ngcontent-%COMP%]{background:#f4f4f480;width:100vw;height:100vh;position:absolute}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(BlockRendererComponent, [{
        type: Component,
        args: [{ selector: 'app-block-renderer', standalone: true, imports: [DynamicRendererComponent, NgSwitch, ViewRendererComponent, CommonModule], template: "<!-- <section id=\"{{ blockRenderedData.block_id }}\"\r\n    class=\"cee-block template-{{templateId}} block-{{ blockRenderedData.block_id }}  block-{{blockPosition}}\" *ngIf=\"blockRenderedData\"\r\n    [ngClass]=\"{ 'Header':'block-header', 'Footer':'block-footer', 'menu':'block-menu'}[blockRenderedData.block_name]\">\r\n    <ng-container *ngFor=\"let field of blockRenderedData.block_fields; index as pos\">\r\n        <app-view-renderer [stepId]=\"stepId\" [field]=\"field\" [position]=\"pos\" [templateId]=\"templateId\"></app-view-renderer>\r\n    </ng-container>\r\n</section> -->\r\n<ng-container *ngIf=\"blockRenderedData\">\r\n    <div *ngIf=\"loader.showSection\" class=\"cee_loader cee_loader_{{blockRenderedData.block_id}}\">\r\n        <app-dynamic-renderer moduleName=\"CEE_LOADER\"></app-dynamic-renderer>\r\n    </div>\r\n    <ng-container [ngSwitch]=\"blockRenderedData.block_name\">\r\n        <ng-container *ngSwitchCase=\"'Header'\">\r\n            <header [hidden]=\"loader.showSection || !isVisible\" id=\"{{ blockRenderedData.block_id }}\" class=\"cee-block block-header  template-{{templateId}} block-{{ blockRenderedData.block_id }}  block-{{blockPosition}} {{blockRenderedData.block_style?blockRenderedData.block_style.custom_class_name:''}} {{is_bootstrap?'row':''}}\"\r\n                *ngIf=\"blockRenderedData\">\r\n\r\n                <ng-container *ngFor=\"let field of blockRenderedData.block_fields; index as pos; trackBy: trackById\">\r\n                    <app-view-renderer class=\"app-view-renderer-{{ blockRenderedData.block_id }}-{{pos}} {{field.field_style?commonUtil.bootstrapColClass(field.field_style.bootstrap_class_name, is_bootstrap, '', conditionalUtil.evaluteBootstrapCondition(field)):''}}\" [stepId]=\"stepId\" [field]=\"field\" [position]=\"pos\" [templateId]=\"templateId\"\r\n                        [rootData]=\"rootData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n                    </app-view-renderer>\r\n                </ng-container>\r\n            </header>\r\n        </ng-container>\r\n        <!-- Hamburgermenu  -->\r\n        <ng-container *ngSwitchCase=\"'Hamburgermenu'\">\r\n            <div [hidden]=\"loader.showSection || !isVisible\" id=\"{{ blockRenderedData.block_id }}\" class=\"cee-block block-navbar   template-{{templateId}} block-{{ blockRenderedData.block_id }}  block-{{blockPosition}} {{blockRenderedData.block_style?blockRenderedData.block_style.custom_class_name:''}}  {{hiddennavContainerCssClass}}\"\r\n                *ngIf=\"blockRenderedData\" [attr.aria-label]=\"additionalParameter['Aria-Label'] ? additionalParameter['Aria-Label'] : undefined\" [attr.role]=\"additionalParameter['Aria-Role']\">\r\n\r\n                <button class=\"navbar-toggler toggle-btn\" (click)=\"toggleNav()\"></button>\r\n\r\n                <nav class=\"nav-container {{ hiddenNavCssClass }}  {{additionalParameter['slidePosition']||'top'}}\">\r\n                    <!-- <div class=\"ham-backpop\" (click)=\"toggleNav()\"></div> -->\r\n                    <ul class=\"navbar-nav mr-auto\">\r\n\r\n                        <ng-container *ngFor=\"let field of blockRenderedData.block_fields; index as pos; trackBy: trackById\">\r\n                            <li class=\"nav-item\">\r\n\r\n                                <app-view-renderer class=\"app-view-renderer-{{ blockRenderedData.block_id }}-{{pos}} {{field.field_style?commonUtil.bootstrapColClass(field.field_style.bootstrap_class_name, is_bootstrap, '', conditionalUtil.evaluteBootstrapCondition(field)):''}} {{setActiveItem(field)}}\" [stepId]=\"stepId\" [field]=\"field\"\r\n                                    [position]=\"pos\" [templateId]=\"templateId\" [rootData]=\"rootData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n                                </app-view-renderer>\r\n                            </li>\r\n                        </ng-container>\r\n                    </ul>\r\n                </nav>\r\n            </div>\r\n        </ng-container>\r\n        <!-- Hamburgermenu End -->\r\n        <ng-container *ngSwitchCase=\"'Footer'\">\r\n            <footer [hidden]=\"loader.showSection || !isVisible\" id=\"{{ blockRenderedData.block_id }}\" class=\"cee-block block-footer template-{{templateId}} block-{{ blockRenderedData.block_id }}  block-{{blockPosition}} {{blockRenderedData.block_style?blockRenderedData.block_style.custom_class_name:''}} {{is_bootstrap?'row':''}}\"\r\n                *ngIf=\"blockRenderedData\">\r\n\r\n                <ng-container *ngFor=\"let field of blockRenderedData.block_fields; index as pos; trackBy: trackById\">\r\n                    <app-view-renderer class=\"app-view-renderer-{{ blockRenderedData.block_id }}-{{pos}} {{field.field_style?commonUtil.bootstrapColClass(field.field_style.bootstrap_class_name, is_bootstrap, '', conditionalUtil.evaluteBootstrapCondition(field)):''}}\" [stepId]=\"stepId\" [field]=\"field\" [position]=\"pos\" [templateId]=\"templateId\"\r\n                        [rootData]=\"rootData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\" [rowData]=\"generateRowData(field)\">\r\n                    </app-view-renderer>\r\n                </ng-container>\r\n            </footer>\r\n        </ng-container>\r\n        <ng-container *ngSwitchDefault>\r\n            <section id=\"{{ blockRenderedData.block_id }}\" [attr.aria-label]=\"additionalParameter['Aria-Label'] ? additionalParameter['Aria-Label'] : undefined\" [attr.role]=\"additionalParameter['Aria-Role']\" class=\"cee-block template-{{templateId}} block-{{ blockRenderedData.block_id }}  block-{{blockPosition}} {{blockRenderedData.block_style?blockRenderedData.block_style.custom_class_name:''}} {{is_bootstrap?'row':''}}\"\r\n                *ngIf=\"blockRenderedData\" [hidden]=\"loader.showSection || !isVisible\">\r\n\r\n                <ng-container *ngFor=\"let field of blockRenderedData.block_fields; index as pos; trackBy: trackById\">\r\n                    <app-view-renderer class=\"app-view-renderer-{{ blockRenderedData.block_id }}-{{pos}} {{field.field_style?commonUtil.bootstrapColClass(field.field_style.bootstrap_class_name, is_bootstrap, rootData.templateClass, conditionalUtil.evaluteBootstrapCondition(field)):''}}\" [stepId]=\"stepId\" [field]=\"field\"\r\n                        [position]=\"pos\" [templateId]=\"templateId\" [rootData]=\"rootData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\" [rowData]=\"generateRowData(field)\">\r\n                    </app-view-renderer>\r\n                </ng-container>\r\n            </section>\r\n        </ng-container>\r\n    </ng-container>\r\n</ng-container>", styles: [".block-header{grid-area:header}.nav-container{transform:translate(0)}.nav-container.right{transform:translate(0) scaleX(1);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.right.hidden-nav{transform:translate(100%) scaleX(0);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.left{transform:translate(0) scaleX(1);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.left.hidden-nav{transform:translate(-100%) scaleX(0);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.top{-webkit-transform:translateY(0px) scaleY(1);-moz-transform:translateY(0px) scaleY(1);transform:translateY(0) scaleY(1);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.nav-container.top.hidden-nav{-webkit-transform:translateY(-200%) scaleY(0);-moz-transform:translateY(-200%) scaleY(0);transform:translateY(-100%) scaleY(0);-webkit-transition:all .5s ease-in-out;-moz-transition:all .5s ease-in-out;transition:all .5s ease-in-out}.ham-backpop{background:#f4f4f480;width:100vw;height:100vh;position:absolute}\n"] }]
    }], () => [{ type: i9.HttpClient }, { type: i11.Router }, { type: SharedEventsServiceService }, { type: AppDataService }, { type: ApiDataService }, { type: WfeStepLoaderService }, { type: i0.ChangeDetectorRef }], { stepId: [{
            type: Input
        }], blockId: [{
            type: Input
        }], blockPosition: [{
            type: Input
        }], templateId: [{
            type: Input
        }], rootData: [{
            type: Input
        }], onDocumentClick: [{
            type: HostListener,
            args: ['document:click', ['$event']]
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(BlockRendererComponent, { className: "BlockRendererComponent", filePath: "lib\\components\\block-renderer\\block-renderer.component.ts", lineNumber: 23 }); })();

class SessionKeyUtil {
    constructor() { }
    generateSessionKey(fieldData) {
        return fieldData.unique_id + ':::' + fieldData.api_key;
    }
    getFieldNameFromSessionKey(key) {
        const value = key.split(':::');
        if (value.length > 1) {
            return value[0];
        }
        else {
            return key;
        }
    }
    getApiKeyFromSessionKey(key) {
        const value = key.split(':::');
        if (value.length > 1) {
            return value[1];
        }
        else {
            return key;
        }
    }
    getApiKeyValueFromSession(key) {
        const session = window.sessionStorage;
        for (const data in session) {
            if (key === this.getApiKeyFromSessionKey(data)) {
                return { key, value: session[data] };
            }
        }
    }
    getSessionKeyUsingUniqueId(key) {
        const session = window.sessionStorage;
        // tslint:disable-next-line: forin
        for (const data in session) {
            if (key === this.getFieldNameFromSessionKey(data)) {
                return data;
            }
        }
    }
    getSessionKeyFromApiKey(key) {
        const session = window.sessionStorage;
        for (const data in session) {
            if (this.getApiKeyFromSessionKey(data) === key) {
                return data;
            }
        }
        return key;
    }
}

class ESBRequestBodyUtil {
    apiDataService;
    constructor(apiDataService) {
        this.apiDataService = apiDataService;
        this.sessionKeyUtil = new SessionKeyUtil();
    }
    getESBRequestBody() {
        const bodyObj = {};
        const sessionData = sessionStorage;
        for (const key in sessionData) {
            if (typeof (sessionData[key]) !== 'function') {
                bodyObj[this.sessionKeyUtil.getApiKeyFromSessionKey(key)] = sessionData[key];
            }
        }
        /** store the api data in the request body */
        this.apiDataService.getAllApiData().subscribe(results => {
            for (const data of results) {
                bodyObj[data.apiKey] = data.value;
            }
        });
        return bodyObj;
    }
}

class SaveFieldValueUtil {
    constructor() { }
    saveListofFieldValues(apiKey, fieldValue, fieldData) {
        const fieldTypeList = [
            'Checkbox',
            'radio',
            'Switch'
        ];
        if (fieldData.additional_parameters && fieldData.unique_id === apiKey && fieldTypeList.includes(fieldData.field_type)) {
            for (const addParam of fieldData.additional_parameters) {
                const { parameter_type, value } = addParam;
                if (parameter_type && parameter_type === 'SaveFields') {
                    if (fieldValue === '1' || fieldValue === 'true') {
                        // go ahead and save it to the local storage
                        localStorage.setItem('saveFieldList', value);
                        return true;
                    }
                    else {
                        // check if there is any unique id to saved in local storgae
                        // then clean it
                        localStorage.removeItem('saveFieldList');
                        return false;
                    }
                }
            }
        }
    }
}

class DomSanitizePipe {
    sanitizer;
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * Transform
     *
     * @param value: string
     * @param type: string
     */
    transform(value, type) {
        switch (type) {
            case 'html':
                return this.sanitizer.bypassSecurityTrustHtml(value);
            case 'style':
                return this.sanitizer.bypassSecurityTrustStyle(value);
            case 'script':
                return this.sanitizer.bypassSecurityTrustScript(value);
            case 'url':
                return this.sanitizer.bypassSecurityTrustUrl(value);
            case 'resourceUrl':
                return this.sanitizer.bypassSecurityTrustResourceUrl(value);
            default:
                return this.sanitizer.bypassSecurityTrustHtml(value);
        }
    }
    static ɵfac = function DomSanitizePipe_Factory(t) { return new (t || DomSanitizePipe)(i0.ɵɵdirectiveInject(i1.DomSanitizer, 16)); };
    static ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "domSanitize", type: DomSanitizePipe, pure: true, standalone: true });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DomSanitizePipe, [{
        type: Pipe,
        args: [{
                name: 'domSanitize',
                standalone: true,
            }]
    }], () => [{ type: i1.DomSanitizer }], null); })();

function AlertModalComponent_ng_container_0_ng_container_2_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 10)(1, "span");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "button", 11);
    i0.ɵɵlistener("click", function AlertModalComponent_ng_container_0_ng_container_2_div_1_Template_button_click_3_listener() { i0.ɵɵrestoreView(_r2); const ctx_r2 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r2.onNegativeClick()); });
    i0.ɵɵtext(4, "\u00D7");
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r2.data.title);
} }
function AlertModalComponent_ng_container_0_ng_container_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "img", 12);
    i0.ɵɵpipe(2, "domSanitize");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance();
    i0.ɵɵproperty("src", i0.ɵɵpipeBind2(2, 1, ctx_r2.data.value, "resourceUrl"), i0.ɵɵsanitizeUrl);
} }
function AlertModalComponent_ng_container_0_ng_container_2_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "iframe", 13);
    i0.ɵɵpipe(2, "domSanitize");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("preview preview-", ctx_r2.data.config.id, "");
    i0.ɵɵproperty("src", i0.ɵɵpipeBind2(2, 4, ctx_r2.data.value, "resourceUrl"), i0.ɵɵsanitizeResourceUrl);
} }
function AlertModalComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, AlertModalComponent_ng_container_0_ng_container_2_div_1_Template, 5, 1, "div", 6);
    i0.ɵɵelementStart(2, "div");
    i0.ɵɵtemplate(3, AlertModalComponent_ng_container_0_ng_container_2_ng_container_3_Template, 3, 4, "ng-container", 7)(4, AlertModalComponent_ng_container_0_ng_container_2_ng_container_4_Template, 3, 7, "ng-container", 7);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(5, "div", 8)(6, "button", 9);
    i0.ɵɵlistener("click", function AlertModalComponent_ng_container_0_ng_container_2_Template_button_click_6_listener() { i0.ɵɵrestoreView(_r1); const ctx_r2 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r2.onNegativeClick()); });
    i0.ɵɵtext(7, "Close");
    i0.ɵɵelementEnd()();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r2.data.title);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("mat-dialog-content previewContent previewContent-", ctx_r2.data.config.id, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r2.data.fileType == "image");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r2.data.fileType == "doc");
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("previewClose preview-", ctx_r2.data.config.id, "");
} }
function AlertModalComponent_ng_container_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div", 14)(2, "mat-form-field")(3, "input", 15, 1);
    i0.ɵɵtwoWayListener("ngModelChange", function AlertModalComponent_ng_container_0_ng_container_3_Template_input_ngModelChange_3_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r2 = i0.ɵɵnextContext(2); i0.ɵɵtwoWayBindingSet(ctx_r2.data.attachmentName, $event) || (ctx_r2.data.attachmentName = $event); return i0.ɵɵresetView($event); });
    i0.ɵɵelementEnd()()();
    i0.ɵɵelementStart(5, "div", 8)(6, "button", 16);
    i0.ɵɵtext(7, "Save");
    i0.ɵɵelementEnd()();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵpropertyInterpolate("placeholder", ctx_r2.data.value);
    i0.ɵɵtwoWayProperty("ngModel", ctx_r2.data.attachmentName);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("mat-dialog-close", ctx_r2.data.attachmentName);
} }
function AlertModalComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0)(1, 4);
    i0.ɵɵtemplate(2, AlertModalComponent_ng_container_0_ng_container_2_Template, 8, 9, "ng-container", 5)(3, AlertModalComponent_ng_container_0_ng_container_3_Template, 8, 3, "ng-container", 5);
    i0.ɵɵelementContainerEnd()();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngSwitch", ctx_r2.data.type);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngSwitchCase", "PreviewModal");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngSwitchCase", "AttachmentNameModal");
} }
function AlertModalComponent_ng_template_1_ng_container_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "mat-label", 22);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r6 = ctx.$implicit;
    i0.ɵɵadvance();
    i0.ɵɵattribute("aria-label", field_r6);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(field_r6);
} }
function AlertModalComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div", 17)(2, "p", 18);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(4, AlertModalComponent_ng_template_1_ng_container_0_ng_container_4_Template, 3, 2, "ng-container", 19);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(5, "div", 20)(6, "button", 21);
    i0.ɵɵlistener("click", function AlertModalComponent_ng_template_1_ng_container_0_Template_button_click_6_listener() { i0.ɵɵrestoreView(_r5); const ctx_r2 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r2.onPostiveClick()); });
    i0.ɵɵtext(7, "OK");
    i0.ɵɵelementEnd()();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("aria-label", ctx_r2.data.message.heading);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(ctx_r2.data.message.heading);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r2.data.message.fields);
} }
function AlertModalComponent_ng_template_1_ng_template_1_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 10)(1, "span");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "button", 25);
    i0.ɵɵlistener("click", function AlertModalComponent_ng_template_1_ng_template_1_div_0_Template_button_click_3_listener() { i0.ɵɵrestoreView(_r7); const ctx_r2 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r2.onNegativeClick()); });
    i0.ɵɵtext(4, "\u00D7");
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r2.data.title);
} }
function AlertModalComponent_ng_template_1_ng_template_1_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 26)(1, "p");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r2.data.message);
} }
function AlertModalComponent_ng_template_1_ng_template_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelement(1, "lib-ngx-image-zoom", 27);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance();
    i0.ɵɵproperty("thumbImage", ctx_r2.data.message.image.image)("fullImage", ctx_r2.data.message.image.highres)("magnification", 2)("enableScrollZoom", true)("zoomMode", ctx_r2.data.message.zoomInEventType)("enableLens", false)("altText", ctx_r2.data.message.image.text)("titleText", ctx_r2.data.message.image.text)("circularLens", true);
} }
function AlertModalComponent_ng_template_1_ng_template_1_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 28)(1, "button", 29);
    i0.ɵɵlistener("click", function AlertModalComponent_ng_template_1_ng_template_1_div_3_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r8); const ctx_r2 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r2.onPostiveClick()); });
    i0.ɵɵtext(2, "Yes");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "button", 30);
    i0.ɵɵlistener("click", function AlertModalComponent_ng_template_1_ng_template_1_div_3_Template_button_click_3_listener() { i0.ɵɵrestoreView(_r8); const ctx_r2 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r2.onNegativeClick()); });
    i0.ɵɵtext(4, "No");
    i0.ɵɵelementEnd()();
} }
function AlertModalComponent_ng_template_1_ng_template_1_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 28)(1, "button", 31);
    i0.ɵɵlistener("click", function AlertModalComponent_ng_template_1_ng_template_1_div_4_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r9); const ctx_r2 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r2.onNegativeClick()); });
    i0.ɵɵtext(2, "Close");
    i0.ɵɵelementEnd()();
} }
function AlertModalComponent_ng_template_1_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, AlertModalComponent_ng_template_1_ng_template_1_div_0_Template, 5, 1, "div", 6)(1, AlertModalComponent_ng_template_1_ng_template_1_div_1_Template, 3, 1, "div", 23)(2, AlertModalComponent_ng_template_1_ng_template_1_div_2_Template, 2, 9, "div", 7)(3, AlertModalComponent_ng_template_1_ng_template_1_div_3_Template, 5, 0, "div", 24)(4, AlertModalComponent_ng_template_1_ng_template_1_div_4_Template, 3, 0, "div", 24);
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngIf", ctx_r2.data.title);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r2.data && ctx_r2.data.message && !ctx_r2.data.message.zoomImg);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r2.data && ctx_r2.data.message && ctx_r2.data.message.zoomImg);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r2.data && ctx_r2.data.message && !ctx_r2.data.message.zoomImg);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r2.data && ctx_r2.data.message && ctx_r2.data.message.zoomImg);
} }
function AlertModalComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, AlertModalComponent_ng_template_1_ng_container_0_Template, 8, 3, "ng-container", 3)(1, AlertModalComponent_ng_template_1_ng_template_1_Template, 5, 5, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
} if (rf & 2) {
    const elseBlock_r10 = i0.ɵɵreference(2);
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", ctx_r2.data.message.showMandateFields)("ngIfElse", elseBlock_r10);
} }
class AlertModalComponent {
    dialogRef;
    data;
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
        // console.log(data);
        if (data.config && data.config.disableClose) {
            dialogRef.disableClose = data.config.disableClose;
        }
    }
    ngAfterViewInit() {
        if (this.data?.class) {
            const dialogContainer = document.querySelector('.mat-mdc-dialog-container');
            dialogContainer?.classList.add(this.data.class);
        }
    }
    onPostiveClick() {
        this.dialogRef.close(true);
    }
    onNegativeClick() {
        this.dialogRef.close(false);
    }
    static ɵfac = function AlertModalComponent_Factory(t) { return new (t || AlertModalComponent)(i0.ɵɵdirectiveInject(i7$1.MatDialogRef), i0.ɵɵdirectiveInject(MAT_DIALOG_DATA)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AlertModalComponent, selectors: [["lib-alert-modal"]], standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 3, vars: 2, consts: [["showAlert", ""], ["attachmentNameField", ""], ["elseBlock", ""], [4, "ngIf", "ngIfElse"], [3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "dialog-title d-flex justify-content-between", "mat-dialog-title", "", 4, "ngIf"], [4, "ngIf"], ["mat-dialog-actions", ""], ["mat-button", "", "cdkFocusInitial", "", 3, "click"], ["mat-dialog-title", "", 1, "dialog-title", "d-flex", "justify-content-between"], ["mat-button", "", "aria-label", "Close Modal", 1, "alert-modal-no", "float-right", 3, "click"], ["alt", "Image", 3, "src"], ["title", "iframe-content", "name", "iframe-content", 3, "src"], ["mat-dialog-content", ""], ["matInput", "", 3, "ngModelChange", "placeholder", "ngModel"], ["mat-button", "", "cdkFocusInitial", "", 3, "mat-dialog-close"], ["mat-dialog-content", "", 1, "mandatory-fields-modal"], [1, "heading"], [4, "ngFor", "ngForOf"], ["mat-dialog-actions", "", 1, "mandatory-fields-modal-button"], ["mat-button", "", "aria-label", "Select Ok", 1, "mandatory-fields-modal-ok", 3, "click"], [1, "field_label"], ["mat-dialog-content", "", "class", "alert-modal", 4, "ngIf"], ["mat-dialog-actions", "", "class", "alert-modal-button", 4, "ngIf"], ["mat-button", "", "aria-label", "Select No", 1, "alert-modal-no", "float-right", 3, "click"], ["mat-dialog-content", "", 1, "alert-modal"], ["ngClass", "image image_active", 3, "thumbImage", "fullImage", "magnification", "enableScrollZoom", "zoomMode", "enableLens", "altText", "titleText", "circularLens"], ["mat-dialog-actions", "", 1, "alert-modal-button"], ["mat-button", "", "aria-label", "Select Yes", "cdkFocusInitial", "", 1, "alert-modal-yes", 3, "click"], ["mat-button", "", "aria-label", "Select No", 1, "alert-modal-no", 3, "click"], ["mat-button", "", "aria-label", "Close", "cdkFocusInitial", "", 1, "alert-modal-close", 3, "click"]], template: function AlertModalComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, AlertModalComponent_ng_container_0_Template, 4, 3, "ng-container", 3)(1, AlertModalComponent_ng_template_1_Template, 3, 2, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        } if (rf & 2) {
            const showAlert_r11 = i0.ɵɵreference(2);
            i0.ɵɵproperty("ngIf", !ctx.data.message && ctx.data.config)("ngIfElse", showAlert_r11);
        } }, dependencies: [NgSwitch, MatFormFieldModule, i12.MatFormField, i12.MatLabel, MatInputModule, i12$1.MatInput, CommonModule, i13.NgClass, i13.NgForOf, i13.NgIf, i13.NgSwitchCase, MatDialogModule, i7$1.MatDialogClose, i7$1.MatDialogTitle, i7$1.MatDialogActions, i7$1.MatDialogContent, NgxImageZoomModule, i5.NgxImageZoomComponent, DomSanitizePipe, FormsModule, i14.DefaultValueAccessor, i14.NgControlStatus, i14.NgModel] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AlertModalComponent, [{
        type: Component,
        args: [{ selector: 'lib-alert-modal', standalone: true, imports: [NgSwitch, MatFormFieldModule, MatInputModule, CommonModule, MatDialogModule, NgxImageZoomModule, DomSanitizePipe, FormsModule], template: "<!-- Config and type is passed through attachments for the preview and attachment -->\r\n<ng-container *ngIf=\"!data.message && data.config; else showAlert\">\r\n    <ng-container [ngSwitch]=\"data.type\">\r\n        <ng-container *ngSwitchCase=\"'PreviewModal'\">\r\n            <div class=\"dialog-title d-flex justify-content-between\" mat-dialog-title *ngIf=\"data.title\">\r\n                <span>{{ data.title }}</span>\r\n                <button mat-button class=\"alert-modal-no float-right\" (click)=\"onNegativeClick()\" aria-label=\"Close Modal\">&times;</button>\r\n            </div>\r\n            <div class=\"mat-dialog-content previewContent previewContent-{{data.config.id}}\">\r\n                <ng-container *ngIf=\"data.fileType == 'image'\">\r\n                    <img [src]=\"data.value | domSanitize:'resourceUrl'\" alt=\"Image\"/>\r\n                </ng-container>\r\n                <ng-container *ngIf=\"data.fileType == 'doc'\">\r\n                    <iframe title=\"iframe-content\" name=\"iframe-content\" class=\"preview preview-{{data.config.id}}\" [src]=\"data.value | domSanitize:'resourceUrl'\"></iframe>\r\n                </ng-container>\r\n            </div>\r\n            <div mat-dialog-actions>\r\n                <button mat-button class=\"previewClose preview-{{data.config.id}}\" (click)=\"onNegativeClick()\" cdkFocusInitial>Close</button>\r\n            </div>\r\n        </ng-container>\r\n        <ng-container *ngSwitchCase=\"'AttachmentNameModal'\">\r\n            <div mat-dialog-content>\r\n                <mat-form-field>\r\n                    <input matInput placeholder=\"{{data.value}}\" [(ngModel)]=\"data.attachmentName\" #attachmentNameField>\r\n                </mat-form-field>\r\n            </div>\r\n            <div mat-dialog-actions>\r\n                <button mat-button [mat-dialog-close]=\"data.attachmentName\" cdkFocusInitial>Save</button>\r\n            </div>\r\n        </ng-container>\r\n    </ng-container>\r\n</ng-container>\r\n<!-- Else always show alert modal -->\r\n<ng-template #showAlert>\r\n    <!-- Checks for the mandatory fields and data.message.showMandateFields is passed from event list handler util -->\r\n    <ng-container *ngIf=\"data.message.showMandateFields; else elseBlock\">\r\n        <!-- <h1 mat-dialog-title>{{data.message.heading}}</h1> -->\r\n        <div mat-dialog-content class=\"mandatory-fields-modal\">\r\n            <p class=\"heading\" [attr.aria-label]=\"data.message.heading\">{{data.message.heading}}</p>\r\n            <ng-container *ngFor=\"let field of data.message.fields\">\r\n                <mat-label class=\"field_label\" [attr.aria-label]=\"field\">{{field}}</mat-label>\r\n            </ng-container>\r\n        </div>\r\n        <div mat-dialog-actions class=\"mandatory-fields-modal-button\">\r\n            <button mat-button class=\"mandatory-fields-modal-ok\" (click)=\"onPostiveClick()\" aria-label=\"Select Ok\">OK</button>\r\n        </div>\r\n    </ng-container>\r\n    <!-- Else display the alert messages -->\r\n    <ng-template #elseBlock>\r\n        <div class=\"dialog-title d-flex justify-content-between\" mat-dialog-title *ngIf=\"data.title\">\r\n            <span>{{ data.title }}</span>\r\n            <button mat-button class=\"alert-modal-no float-right\" (click)=\"onNegativeClick()\" aria-label=\"Select No\">&times;</button>\r\n        </div>\r\n        <div mat-dialog-content class=\"alert-modal\" *ngIf=\"data && data.message && !data.message.zoomImg\">\r\n            <p>{{data.message}}</p>\r\n        </div>\r\n        <div *ngIf=\"data && data.message && data.message.zoomImg\">\r\n            <lib-ngx-image-zoom\r\n                [thumbImage]=\"data.message.image.image\"\r\n                [fullImage]=\"data.message.image.highres\"\r\n                [magnification]=\"2\"\r\n                [enableScrollZoom]=\"true\"\r\n                [zoomMode]=\"data.message.zoomInEventType\"\r\n                [enableLens]=\"false\"\r\n                ngClass=\"image image_active\"\r\n                [altText]=\"data.message.image.text\"\r\n                [titleText]=\"data.message.image.text\"\r\n                [circularLens]=\"true\">\r\n            </lib-ngx-image-zoom>\r\n        </div>\r\n        <div mat-dialog-actions class=\"alert-modal-button\" *ngIf=\"data && data.message && !data.message.zoomImg\">\r\n            <!-- yes no button for delete passing value -->\r\n            <button mat-button class=\"alert-modal-yes\" (click)=\"onPostiveClick()\" aria-label=\"Select Yes\" cdkFocusInitial>Yes</button>\r\n            <button mat-button class=\"alert-modal-no\" (click)=\"onNegativeClick()\" aria-label=\"Select No\">No</button>\r\n        </div>\r\n        <div mat-dialog-actions class=\"alert-modal-button\" *ngIf=\"data && data.message && data.message.zoomImg\">\r\n            <button mat-button class=\"alert-modal-close\" (click)=\"onNegativeClick()\" aria-label=\"Close\" cdkFocusInitial>Close</button>\r\n        </div>\r\n    </ng-template>\r\n</ng-template>" }]
    }], () => [{ type: i7$1.MatDialogRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }], null); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(AlertModalComponent, { className: "AlertModalComponent", filePath: "lib\\components\\alert-modal\\alert-modal.component.ts", lineNumber: 18 }); })();

class EmptyUtil {
    /**
     * This function checks empty be it array, string , null ,undefined
     * add or remove cases if needed
     * @param value any
     */
    isEmpty(value) {
        if (Array.isArray(value)) {
            if (value.length > 0) {
                return false;
            }
            else {
                return true;
            }
        }
        else {
            switch (value) {
                case '':
                case null:
                case false:
                case undefined:
                case typeof (value) == 'undefined':
                    return true;
                default:
                    return false;
            }
        }
    }
}

class DynamicLabelUtil {
    apiDataService;
    appDataService;
    setAPIKeyUtil;
    commonUtil;
    constructor(apiDataService, appDataService) {
        this.apiDataService = apiDataService;
        this.appDataService = appDataService;
        this.setAPIKeyUtil = new SetAPICallbackData(apiDataService);
        this.commonUtil = new CommonUtil();
    }
    extractApiKeys(sentence) {
        const keys = sentence.match(new RegExp(/\%(.*?)\%/g));
        return keys;
    }
    /**
     * function that returns the proper value of the text that is set to dynamic
     * @param values the field data
     * @param data the api calling data
     */
    getDynamicValue(values, data, useSecondaryApiKey = false) {
        let obj = values;
        for (const key of ['field_label', 'tooltip', 'placeholder_text', 'possible_values', 'expandTitle', 'collapseTitle', 'additional_parameters']) {
            if (!obj[key] && !obj[key + '_config']) {
                continue;
            }
            const dynamicData = this.checkIfDynamic(key, obj, data, useSecondaryApiKey);
            obj = { ...obj, ...dynamicData };
        }
        // ABSOLUTE FINAL CLEANUP: Remove ALL || delimiters AND convert newlines for ALL processed fields
        for (const key of ['field_label', 'tooltip', 'placeholder_text', 'possible_values', 'expandTitle', 'collapseTitle']) {
            if (obj[key] && typeof obj[key] === 'string') {
                // Remove || delimiters
                if (obj[key].includes('||')) {
                    //console.log('🔥 ABSOLUTE FINAL CLEANUP - Found || in', key, ':', obj[key].substring(0, 100) + (obj[key].length > 100 ? '...' : ''));
                    obj[key] = obj[key].replaceAll('||', '');
                    //console.log('🔥 ABSOLUTE FINAL CLEANUP - Cleaned', key, ':', obj[key].substring(0, 100) + (obj[key].length > 100 ? '...' : ''));
                }
                // ENSURE NEWLINES ARE CONVERTED - This is a safety net for ALL dynamic content
                if (obj[key].includes('\\n') || obj[key].includes('\n')) {
                    //console.log('🔄 ABSOLUTE FINAL NEWLINE CONVERSION - Found newlines in', key, ':', obj[key].substring(0, 100) + (obj[key].length > 100 ? '...' : ''));
                    obj[key] = this.convertNewlinesToBreaks(obj[key]);
                    //console.log('🔄 ABSOLUTE FINAL NEWLINE CONVERSION - Result:', obj[key].substring(0, 100) + (obj[key].length > 100 ? '...' : ''));
                    // Add visual marker to help debug
                    obj[key] = '🔄NEWLINES_CONVERTED: ' + obj[key];
                }
            }
        }
        return obj;
    }
    checkIfDynamic(key, fieldObj, apiData, useSecondaryApiKey = false) {
        // check for config key
        const configKey = key + '_config';
        fieldObj = {
            ...fieldObj, ...{
                [configKey]: fieldObj[configKey] || fieldObj[key]
            }
        };
        if (key === "additional_parameters" && fieldObj[key].length > 0) {
            let dynamicValue;
            fieldObj[key].forEach(x => {
                if (x.parameter_type === "CEE_table_cell_values") {
                    dynamicValue = x.value;
                    if (dynamicValue?.includes('((dynamic))')) {
                        dynamicValue = this.setDynamicKeysValue(dynamicValue, apiData);
                    }
                    if (dynamicValue.includes('?') && dynamicValue.includes(':') && !dynamicValue.includes('https://') && !dynamicValue.includes('http://')) {
                        if (dynamicValue.includes('||')) {
                            const regex = /\|\|/g;
                            dynamicValue = dynamicValue.replace(regex, '|-|');
                        }
                        const dynamicValueArr = dynamicValue.split('||');
                        let evauatedValArr = [];
                        dynamicValueArr.forEach((val) => {
                            val = this.recursiveFunc(val).split("\n").join("<br/>");
                            evauatedValArr.push((val.includes('?') && val.includes(':')) ? eval(val) : val);
                        });
                        dynamicValue = evauatedValArr.join('');
                    }
                }
            });
            // GLOBAL CLEANUP: Remove ALL || delimiters from the final result regardless of source
            if (dynamicValue && typeof dynamicValue === 'string' && dynamicValue.includes('||')) {
                //console.log('🧽 GLOBAL CLEANUP (additional_parameters) - Before removing ALL || delimiters:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
                dynamicValue = dynamicValue.replaceAll('||', '');
                //console.log('🧽 GLOBAL CLEANUP (additional_parameters) - After removing ALL || delimiters:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
            }
            //dynamicValue = dynamicValue.replaceAll('||','');
            return { [key]: fieldObj[configKey], [configKey]: dynamicValue };
        }
        else {
            let dynamicValue = fieldObj[key];
            // configKey = fieldObj[configKey] ? configKey : key;
            if ((Array.isArray(fieldObj[configKey]) &&
                fieldObj[configKey].join('').includes('((dynamic))')) ||
                (fieldObj[configKey] && fieldObj[configKey].includes('((dynamic))'))) {
                dynamicValue = this.setDynamicKeysValue(fieldObj[configKey], apiData);
                // ALWAYS CONVERT NEWLINES - This should happen for ALL dynamic content, not just ternary
                dynamicValue = this.convertNewlinesToBreaks(dynamicValue);
                // console.log('🔄 MAIN PATH NEWLINE CONVERSION - Result:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
                // console.log('🔄 MAIN PATH - Contains <br>:', dynamicValue.includes('<br>'));
                // console.log('🔍 DYNAMIC VALUE DEBUG - After setDynamicKeysValue:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
                // console.log('🔍 CONDITION CHECK - Contains ||:', dynamicValue.includes('||'));
                // console.log('🔍 CONDITION CHECK - Contains ?:', dynamicValue.includes('?'));
                // console.log('🔍 CONDITION CHECK - Contains ::', dynamicValue.includes(':'));
                // && !dynamicValue.includes('https://') && !dynamicValue.includes('http://')
                if (dynamicValue.includes('||') && dynamicValue.includes('?') && dynamicValue.includes(':')) {
                    // console.log('🎯 ENTERING TERNARY PROCESSING BLOCK');
                    // console.log(dynamicValue);
                    const dynamicValueArr = dynamicValue.split('||');
                    let evauatedValArr = [];
                    dynamicValueArr.forEach((val, i) => {
                        if (useSecondaryApiKey && i === 0) {
                            return;
                        }
                        // Normalize the string - replace any line breaks with <br> and &nbsp;
                        val = this.convertNewlinesToBreaks(val.trim());
                        // CRITICAL: Remove delimiters from the ENTIRE expression first
                        // console.log('🧹 BEFORE delimiter cleanup:', val.substring(0, 100) + (val.length > 100 ? '...' : ''));
                        val = this.cleanAllDelimiters(val);
                        // console.log('🧹 AFTER delimiter cleanup:', val.substring(0, 100) + (val.length > 100 ? '...' : ''));
                        try {
                            // Check if this is a conditional expression that needs evaluation
                            // console.log('🔍 Checking if ternary:', val.substring(0, 100) + (val.length > 100 ? '...' : ''));
                            // console.log('   Has ?:', val.includes('?'));
                            // console.log('   Has ::', val.includes(':'));
                            // console.log('   Has ? with spaces:', val.includes(' ? '));
                            // console.log('   Has : with spaces:', val.includes(' : '));
                            if (val.includes('?') && val.includes(':')) {
                                // console.log('🔧 Processing ternary expression (flexible matching):', val.substring(0, 100) + (val.length > 100 ? '...' : ''));
                                const result = this.evaluateTernaryExpression(val);
                                // console.log('✅ Ternary result:', result);
                                evauatedValArr.push(result);
                            }
                            else {
                                // console.log('➡️ Not a ternary, adding as-is');
                                evauatedValArr.push(val);
                            }
                        }
                        catch (error) {
                            console.error("Error evaluating expression:", val, error);
                            // Fall back to the original value if evaluation fails
                            evauatedValArr.push(val);
                        }
                    });
                    dynamicValue = evauatedValArr.join('');
                    // FINAL CLEANUP: Remove any remaining delimiters from the final result
                    // console.log('🧽 FINAL CLEANUP - Before removing delimiters:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
                    dynamicValue = dynamicValue.replaceAll('||', '');
                    // console.log('🧽 FINAL CLEANUP - After removing delimiters:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
                }
                // console.log(dynamicValue);
            }
            // GLOBAL CLEANUP: Remove ALL || delimiters from the final result regardless of source
            if (dynamicValue && typeof dynamicValue === 'string' && dynamicValue.includes('||')) {
                // console.log('🧽 GLOBAL CLEANUP - Before removing ALL || delimiters:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
                dynamicValue = dynamicValue.replaceAll('||', '');
                // console.log('🧽 GLOBAL CLEANUP - After removing ALL || delimiters:', dynamicValue.substring(0, 100) + (dynamicValue.length > 100 ? '...' : ''));
            }
            //dynamicValue = dynamicValue.replaceAll('||','');
            return { [key]: dynamicValue, [configKey]: fieldObj[configKey] };
        }
    }
    convertNewlinesToBreaks(text) {
        if (!text)
            return text;
        // console.log('🔄 NEWLINE CONVERSION - Input:', text.substring(0, 100) + (text.length > 100 ? '...' : ''));
        // console.log('🔄 NEWLINE CONVERSION - Contains \\n:', text.includes('\\n'));
        // console.log('🔄 NEWLINE CONVERSION - Contains actual newlines:', text.includes('\n'));
        const result = text
            // Convert actual newlines
            .replace(/(?:\r\n|\r|\n)/g, '<br>')
            // Convert literal escaped newlines
            .replace(/\\n/g, '<br>')
            .replace(/\\r/g, '<br>')
            // Convert tabs (actual and escaped)
            .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
            .replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');
        // console.log('🔄 NEWLINE CONVERSION - Result:', result.substring(0, 100) + (result.length > 100 ? '...' : ''));
        // console.log('🔄 NEWLINE CONVERSION - Contains <br>:', result.includes('<br>'));
        return result;
    }
    recursiveFunc(val) {
        let init = val.indexOf('(');
        let fin = val.indexOf(')');
        let expression = val.substr(init + 1, fin - init - 1);
        let evaluatedVal = this.evaluateExpression(expression);
        val = val.replaceAll('(' + expression + ')', evaluatedVal);
        if (val.includes('DATE_COMPAIR')) {
            val = this.recursiveFunc(val);
        }
        return val;
    }
    evaluateExpression(val) {
        if (val.includes('DATE_COMPAIR')) {
            let vArr = val.split('?');
            let valArr = vArr[0].split('|');
            if (valArr[0] == 'DATE_COMPAIR') {
                val = this.compairDates(valArr);
            }
        }
        return val;
    }
    compairDates(valArr) {
        let result = false;
        if (valArr.length == 4) {
            if (valArr[0] == 'DATE_COMPAIR') {
                if (valArr[1].trim() == 'CURR_DATE') {
                    valArr[1] = moment$1(new Date());
                }
                else {
                    valArr[1] = moment$1(new Date(valArr[1]));
                }
                if (valArr[3].trim() == 'CURR_DATE') {
                    valArr[3] = moment$1(new Date());
                }
                else {
                    valArr[3] = moment$1(new Date(valArr[3]));
                }
                switch (valArr[2].trim()) {
                    case '==':
                        result = valArr[1].isSame(valArr[3], 'day') ? true : false;
                        break;
                    case '>':
                        result = valArr[1].isAfter(valArr[3]) ? true : false;
                        break;
                    case '<':
                        result = valArr[1].isBefore(valArr[3]) ? true : false;
                        break;
                    default:
                        result = (valArr[1] == valArr[3]) ? true : false;
                        break;
                }
            }
        }
        return result;
    }
    setDynamicKeysValue(fieldValue, apiData) {
        if (Array.isArray(fieldValue)) {
            const arr = [];
            for (const singleVal of fieldValue) {
                if (singleVal.includes('((dynamic))')) {
                    const dynamicKeys = this.extractApiKeys(singleVal.split('((dynamic))')[1]);
                    // console.log(dynamicKeys);
                    arr.push(this.getSentence(dynamicKeys, singleVal, apiData).replace('((dynamic))', ''));
                }
                else {
                    arr.push(singleVal);
                }
            }
            return arr;
        }
        else {
            const dynamicKeys = this.extractApiKeys(fieldValue.split('((dynamic))')[1]);
            // Support for multiple response key in dynamic labels with '|'
            dynamicKeys.forEach((apiKey, i) => {
                if (apiKey.includes('|')) {
                    apiKey = apiKey.replaceAll('%', '');
                    let apiKeyArr = apiKey.split('|');
                    var dataFound = false;
                    apiKeyArr.forEach((keyPart, index) => {
                        console.log('Key Part:', keyPart);
                        if (this.checkHandlerDataExists(keyPart.split('##')[0].trim(), keyPart) && !dataFound) {
                            fieldValue = fieldValue.replaceAll(dynamicKeys[i], '%' + keyPart + '%');
                            dynamicKeys[i] = '%' + keyPart + '%';
                            dataFound = true;
                            return this.getSentence(dynamicKeys, fieldValue, apiData).replace('((dynamic))', '');
                        }
                    });
                }
            });
            // console.log(dynamicKeys);
            return this.getSentence(dynamicKeys, fieldValue, apiData).replace('((dynamic))', '');
        }
    }
    // /**
    //  * get the sentence
    //  * @param values the field data
    //  * @param data  then api call back data
    //  */
    // private getDynamicSentence(field, key, data) {
    //     // field = JSON.parse(JSON.stringify(field));
    //     // let config_key: any;
    //     // let sentence: any;
    //     // let linked_api_keys = [];
    //     // let final_array_values = [];
    //     // let new_sentence_val: string;
    //     // config_key = key + '_config';
    //     // sentence = (field[config_key]) ? field[config_key] : field[key];
    //     // // console.log('has Key', field[config_key], key);
    //     // field[config_key] = sentence;
    //     // if (Array.isArray(sentence)) {
    //     //     // field[key + '_config'] = sentence;
    //     //     sentence.map(sentence_val => {
    //     //         if (typeof sentence_val == 'string' && sentence_val.startsWith('((dynamic))')) {
    //     //             var keys = this.extractApiKeys(sentence_val, '.*%(.*)%.*', linked_api_keys);
    //     //             sentence_val = this.getSentence(keys, sentence_val, data);
    //     //             new_sentence_val = sentence_val.replace('((dynamic))', '');
    //     //             final_array_values.push(new_sentence_val);
    //     //         } else {
    //     //             final_array_values.push(sentence_val);
    //     //         }
    //     //     });
    //     //     field[key] = final_array_values;
    //     //     // field = { ...field, ...{ [key]: final_array_values } };
    //     // } else {
    //     //     if (typeof sentence == 'string' && sentence.startsWith('((dynamic))')) {
    //     //         // console.log(field[config_key]);
    //     //         var keys = this.extractApiKeys(sentence, '.*%(.*)%.*', linked_api_keys);
    //     //         sentence = this.getSentence(keys, sentence, data);
    //     //         // console.log('After', field[key]);
    //     //         field[key] = sentence.replace('((dynamic))', '');
    //     //         // console.log('Before', field[key]);
    //     //         // console.log('values', values);
    //     //     }
    //     // }
    //     // console.log(field);
    //     // return field;
    // }
    /**
     * get the sentence
     * @param apiKey the api key string
     * @param data then api call back data
     */
    getSentence(keys, sentence, data) {
        if (keys && keys.length > 0) {
            keys.forEach((apiKey, i) => {
                apiKey = apiKey.split('%')[1];
                const formats = apiKey.split(':::').map(str => str.trim());
                let keyValue = this.returnKeyValue(formats[0].trim(), data);
                if (apiKey.includes(':::') && formats.length > 1) {
                    formats.shift(); // first one is api key
                    keyValue = this.returnFormattedValue(keyValue, formats.shift(), formats);
                }
                if (!keyValue) {
                    keyValue = this.appDataService.getFieldDataByApiKey(apiKey, 'request');
                }
                sentence = sentence.replaceAll('%' + apiKey + '%', keyValue !== undefined ? keyValue : '');
            });
        }
        return sentence;
    }
    /**
     * function returns formatted/transformed data
     * @param defaultValue: any
     * @param transformType: string the method to transform
     * @param format: Array<string> the formats for ex: date requires 1 format
     * whereas currency can have more than one formats one for the country code
     * and another for the number of digits after decimal places
     */
    returnFormattedValue(defaultValue, transformType, format) {
        let keyValue = typeof defaultValue === 'number' ? defaultValue.toString() : defaultValue;
        switch (transformType.toLowerCase()) {
            case 'datetime':
            case 'date':
                const tzName = moment$1.tz.guess();
                // Handle array values first
                if (Array.isArray(keyValue)) {
                    keyValue = keyValue.length > 0 ? keyValue[0] : '';
                }
                // Convert to string to ensure we can use string methods
                keyValue = String(keyValue);
                if (!keyValue.includes(' ') && !keyValue.includes('-') && !keyValue.includes('/')) {
                    keyValue = Number(keyValue);
                }
                keyValue = keyValue && keyValue != '' ? moment$1(this.commonUtil.adjustTZ(new Date(keyValue))).tz(tzName).format(format[0]) : '';
                break;
            case 'time':
                if (!keyValue.includes(' ') && !keyValue.includes('-') && !keyValue.includes('/') && !keyValue.includes(':')) {
                    keyValue = Number(keyValue);
                }
                if (keyValue && String(keyValue).includes(':')) {
                    keyValue = moment$1(keyValue, format[0]).format(format[0]);
                }
                else {
                    keyValue = moment$1(new Date(keyValue)).format(format[0]);
                }
                break;
            case 'currency':
            case 'curr':
                // TODO: use Intl format for currency
                const num = Number(keyValue);
                if (!isNaN(num)) {
                    keyValue = `${getCurrencySymbol(format[0], 'narrow')}` +
                        `${Number(keyValue).toFixed(Number(format[1])).replace(/\d(?=(\d{3})+\.)/g, '$&,')}`;
                }
                break;
            case 'mask':
                keyValue = this.getMaskedInputValue(keyValue, format[0]);
                break;
            case 'masklabel':
                keyValue = this.getMaskedOutputValueforLabel(keyValue, format[0]);
                break;
            case 'masknumberlimit':
                let formatsMask = format[0].split('|');
                keyValue = this.commonUtil.getMaskedData(keyValue, formatsMask[0], formatsMask[1], formatsMask[2], formatsMask[3], formatsMask[4]);
                break;
            case 'thousand_separator':
                keyValue = keyValue && keyValue != '' ? this.commonUtil.formatNumber(keyValue) : '';
                break;
            default:
                console.error(`Pipe Failed, Value: ${JSON.stringify({ valueToTransForm: defaultValue, type: transformType, format })}`);
                break;
        }
        return keyValue;
    }
    getMaskedOutputValueforLabel(inputValue, mask) {
        const maskData = [];
        const apiData = inputValue.split('');
        let index = 0;
        mask.split('').forEach(element => {
            element == 'X' ? maskData.push(apiData[index++]) : maskData.push(element);
        });
        if (inputValue && maskData && maskData.length > 0) {
            return maskData.join('');
        }
        return inputValue;
    }
    getMaskedInputValue(inputValue, mask) {
        const maskData = [];
        mask.split('').forEach(element => {
            element == 'X' ? maskData.push(/[0-9a-zA-Z]/) : element == '0' ? maskData.push(/\d/) : maskData.push(element);
        });
        if (inputValue && maskData && maskData.length > 0) {
            const convertData = this.conformToMask(inputValue, maskData);
            return convertData.conformedValue;
        }
        return inputValue;
    }
    // ######### This is a substitute function for masking, need to test ##########
    conformToMask(rawValue, mask) {
        let conformedValue = '';
        let rawIndex = 0;
        for (let i = 0; i < mask.length; i++) {
            const maskChar = mask[i];
            if (rawIndex >= rawValue.length) {
                break; // Stop if we've reached the end of the input value    
            }
            const rawChar = rawValue[rawIndex];
            if (maskChar === '9' && /\d/.test(rawChar)) {
                conformedValue += rawChar;
                rawIndex++;
            }
            else if (maskChar === 'A' && /[a-zA-Z]/.test(rawChar)) {
                conformedValue += rawChar;
                rawIndex++;
            }
            else {
                conformedValue += maskChar;
            }
        }
        return { 'conformedValue': conformedValue };
    }
    /**
     * the api key that is set to dynamic
     * @param apiKey the api key string
     * @param data then api call back data
     */
    returnKeyValue(apiKey, data) {
        return this.setAPIKeyUtil.isSingleApiKey || this.setAPIKeyUtil.setApiCallBackData(apiKey, data) !== null ?
            this.setAPIKeyUtil.setApiCallBackData(apiKey, data) : this.setAPIKeyUtil.setApiCallBackData(apiKey, this.setAPIKeyUtil.returnValueFromApiStoreUsingHandlerName(apiKey)) !== null ? this.setAPIKeyUtil.setApiCallBackData(apiKey, this.setAPIKeyUtil.returnValueFromApiStoreUsingHandlerName(apiKey)) : '';
    }
    /**
     * Aggressively clean all delimiters from a string
     */
    cleanAllDelimiters(input) {
        if (!input)
            return input;
        // console.log('🧽 CLEAN DELIMITERS - Input (length:', input.length, '):', input);
        let cleanResult = input.trim();
        // Handle the most common pattern: ||...|| (regardless of internal quotes)
        if (cleanResult.startsWith("||") && cleanResult.endsWith("||")) {
            cleanResult = cleanResult.substring(2, cleanResult.length - 2);
            // console.log('🧽 CLEAN DELIMITERS - Removed ||...|| pattern, result:', cleanResult.substring(0, 100) + (cleanResult.length > 100 ? '...' : ''));
        }
        else {
            // Fallback: aggressive delimiter removal for other patterns
            let previousResult = '';
            let iterations = 0;
            // Keep cleaning until no more changes occur or max iterations reached
            while (cleanResult !== previousResult && iterations < 10) {
                previousResult = cleanResult;
                iterations++;
                // console.log(`🧽 CLEAN DELIMITERS - Iteration ${iterations}:`, cleanResult.substring(0, 50) + (cleanResult.length > 50 ? '...' : ''));
                // Remove all delimiter patterns - more aggressive
                cleanResult = cleanResult.replace(/^\|\|+/g, ''); // Remove || from start
                cleanResult = cleanResult.replace(/\|\|+$/g, ''); // Remove || from end  
                cleanResult = cleanResult.replace(/^\|+/g, ''); // Remove | from start
                cleanResult = cleanResult.replace(/\|+$/g, ''); // Remove | from end
                // Trim whitespace
                cleanResult = cleanResult.trim();
                // Handle edge cases where the entire content is just delimiters
                if (cleanResult === '||' || cleanResult === '|' || cleanResult === '||||' || cleanResult === '') {
                    if (cleanResult === '')
                        break;
                    cleanResult = '';
                    break;
                }
            }
        }
        // Final trim and safety check
        cleanResult = cleanResult.trim();
        // console.log('🧽 CLEAN DELIMITERS - Final result (length:', cleanResult.length, '):', cleanResult.substring(0, 100) + (cleanResult.length > 100 ? '...' : ''));
        return cleanResult;
    }
    /**
     * Safely evaluate ternary expressions without using eval()
     * Handles the format: 'condition' == 'value' ? trueResult : falseResult
     */
    evaluateTernaryExpression(expression) {
        try {
            // Find the question mark and the CORRECT colon for ternary operator
            const questionIndex = expression.indexOf('?');
            if (questionIndex === -1) {
                return expression;
            }
            // Find the ternary colon by looking for pattern: ? value : value
            // We need to find the colon that's part of the ternary, not in the content
            let colonIndex = -1;
            // Look for colons after the question mark
            const afterQuestion = expression.substring(questionIndex + 1);
            // Strategy: Look for colon that has quotes around the values (typical ternary pattern)
            // Pattern: ? 'value' : 'value' or ? '-' : 'value'
            const ternaryPattern = /\?\s*['"][^'"]*['"]\s*:\s*['"][^'"]*['"]|\?\s*['"][^'"]*['"]\s*:\s*[^'"]+$|\?\s*[^'"]+\s*:\s*['"][^'"]*['"]/;
            const match = expression.match(ternaryPattern);
            if (match) {
                // Find the colon in the matched pattern
                const matchStart = expression.indexOf(match[0]);
                const matchPart = match[0];
                const colonInMatch = matchPart.lastIndexOf(':');
                colonIndex = matchStart + colonInMatch;
            }
            else {
                // Fallback: find the last colon that comes after the question mark
                // and is likely to be the ternary colon (not inside quotes)
                const searchStart = questionIndex + 1;
                let tempIndex = searchStart;
                while (tempIndex < expression.length) {
                    const char = expression[tempIndex];
                    if (char === ':') {
                        // Check if this colon is likely the ternary colon
                        // by ensuring it's not inside quotes or part of the content
                        const beforeColon = expression.substring(questionIndex + 1, tempIndex).trim();
                        const afterColon = expression.substring(tempIndex + 1).trim();
                        // If both parts look like values (start with quotes or are short), this might be our colon
                        if ((beforeColon.startsWith("'") || beforeColon.startsWith('"') || beforeColon === '-') &&
                            (afterColon.startsWith("'") || afterColon.startsWith('"'))) {
                            colonIndex = tempIndex;
                            break;
                        }
                    }
                    tempIndex++;
                }
            }
            if (colonIndex === -1 || questionIndex >= colonIndex) {
                return expression;
            }
            // Extract the condition, true value, and false value
            const conditionPart = expression.substring(0, questionIndex).trim();
            let trueValue = expression.substring(questionIndex + 1, colonIndex).trim();
            let falseValue = expression.substring(colonIndex + 1).trim();
            // Clean quotes from the values (delimiters already removed at expression level)
            trueValue = trueValue.replace(/^['"]|['"]$/g, '').trim();
            falseValue = falseValue.replace(/^['"]|['"]$/g, '').trim();
            // Parse the condition - looking for patterns like 'value' == '' or 'value' != '' or 'value' == 'something'
            let isConditionTrue = false;
            // Handle != '' pattern
            if (conditionPart.includes(" != ''") || conditionPart.includes(' != ""')) {
                // Extract the value before != ''
                const value = conditionPart.split(' != ')[0].replace(/^['"]|['"]$/g, '').trim();
                isConditionTrue = value !== '' && value !== null && value !== undefined;
            }
            // Handle == '' pattern
            else if (conditionPart.includes(" == ''") || conditionPart.includes(' == ""')) {
                // Extract the value before == ''
                const value = conditionPart.split(' == ')[0].replace(/^['"]|['"]$/g, '').trim();
                isConditionTrue = value === '' || value === null || value === undefined;
            }
            // Handle other != patterns
            else if (conditionPart.includes(' != ')) {
                const parts = conditionPart.split(' != ');
                const leftValue = parts[0].replace(/^['"]|['"]$/g, '').trim();
                const rightValue = parts[1].replace(/^['"]|['"]$/g, '').trim();
                isConditionTrue = leftValue !== rightValue;
            }
            // Handle other == patterns
            else if (conditionPart.includes(' == ')) {
                const parts = conditionPart.split(' == ');
                const leftValue = parts[0].replace(/^['"]|['"]$/g, '').trim();
                const rightValue = parts[1].replace(/^['"]|['"]$/g, '').trim();
                isConditionTrue = leftValue === rightValue;
            }
            // Return the appropriate value based on condition (values are already cleaned)
            const result = isConditionTrue ? trueValue : falseValue;
            // // Handle formatting - convert both literal \n and actual newlines to <br> tags for HTML display
            // let finalResult = result.replace(/\\n/g, '<br>'); // Convert literal \n
            // finalResult = finalResult.replace(/\n/g, '<br>'); // Convert actual newlines
            return result;
        }
        catch (error) {
            return expression; // Return original if parsing fails
        }
    }
    /**
     * Check if handler data exists in the API data of Akita store
     * @param handlerName - The name of the handler to check for
     * @param apiKey - Optional specific API key to check within the handler data
     * @returns boolean - true if handler data exists, false otherwise
     */
    checkHandlerDataExists(handlerName, apiKey) {
        try {
            // Get all API store data
            const apiStoreData = this.apiDataService.getAllApiStoreData();
            if (!apiStoreData || apiStoreData.length === 0) {
                return false;
            }
            // Check if handler exists in the store
            const handlerData = apiStoreData.find(item => item.apiKey === handlerName ||
                item.id === handlerName ||
                this.commonUtil.getHandlerName(item.id) === handlerName);
            if (!handlerData) {
                return false;
            }
            // If no specific apiKey provided, just check if handler exists with data
            if (!apiKey) {
                return handlerData.value !== null && handlerData.value !== undefined;
            }
            // If specific apiKey provided, check if it exists in the handler's value
            if (handlerData.value && typeof handlerData.value === 'object') {
                return handlerData.value.hasOwnProperty(apiKey) &&
                    handlerData.value[apiKey] !== null &&
                    handlerData.value[apiKey] !== undefined;
            }
            return false;
        }
        catch (error) {
            console.error('Error checking handler data existence:', error);
            return false;
        }
    }
    /**
     * Get handler data from the API data of Akita store
     * @param handlerName - The name of the handler to retrieve data for
     * @param apiKey - Optional specific API key to retrieve from the handler data
     * @returns any - The handler data or specific API key data, null if not found
     */
    getHandlerData(handlerName, apiKey) {
        try {
            // Get all API store data
            const apiStoreData = this.apiDataService.getAllApiStoreData();
            if (!apiStoreData || apiStoreData.length === 0) {
                return null;
            }
            // Find handler data in the store
            const handlerData = apiStoreData.find(item => item.apiKey === handlerName ||
                item.id === handlerName ||
                this.commonUtil.getHandlerName(item.id) === handlerName);
            if (!handlerData) {
                return null;
            }
            // If no specific apiKey provided, return the entire handler value
            if (!apiKey) {
                return handlerData.value;
            }
            // If specific apiKey provided, return that specific data
            if (handlerData.value && typeof handlerData.value === 'object') {
                return handlerData.value[apiKey] || null;
            }
            return null;
        }
        catch (error) {
            console.error('Error retrieving handler data:', error);
            return null;
        }
    }
    /**
     * Check if multiple handler data keys exist in the API data of Akita store
     * @param handlerName - The name of the handler to check
     * @param apiKeys - Array of API keys to check for existence
     * @returns object - Object with each API key and its existence status
     */
    checkMultipleHandlerDataExists(handlerName, apiKeys) {
        const result = {};
        try {
            for (const apiKey of apiKeys) {
                result[apiKey] = this.checkHandlerDataExists(handlerName, apiKey);
            }
        }
        catch (error) {
            console.error('Error checking multiple handler data existence:', error);
            // Initialize all keys as false in case of error
            apiKeys.forEach(key => result[key] = false);
        }
        return result;
    }
    static ɵfac = function DynamicLabelUtil_Factory(t) { return new (t || DynamicLabelUtil)(i0.ɵɵinject(ApiDataService), i0.ɵɵinject(AppDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DynamicLabelUtil, factory: DynamicLabelUtil.ɵfac, providedIn: 'any' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DynamicLabelUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'any',
            }]
    }], () => [{ type: ApiDataService }, { type: AppDataService }], null); })();

class CustomErrorsValidation {
    ceeMessages;
    customMessages;
    messages = {};
    constructor(ceeMessages, customMessages) {
        this.ceeMessages = ceeMessages;
        this.customMessages = customMessages;
        // get the message JSON and set it from custom_errors_validation
        this.messages = customMessages;
    }
    /**
     * function that reads the json object gets the user input and the field ID
     * and returns error messages based on the field if configured
     * in the src/assets/config/error_message_config.json
     * and if the the stepID matches the stepId that is given in the
     * array of customErrorMessage in the src/assets/app_config.json
     * @param fieldId the field unique ID for repeatable block field unique ID is the appDataId
     * it should look similar to <stepID>$<fieldId>$<Index>
     * @param value the user input in the following field
     */
    getMessages(fieldId, value) {
        // console.log(messages[fieldId]);
        if (!this.messages || (this.messages && !this.messages[fieldId])) {
            return [];
        }
        let multipleMessages = {};
        for (const message of Object.keys(this.messages[fieldId].errors)) {
            multipleMessages = {
                ...multipleMessages,
                ...this.switchMessages(message, this.messages[fieldId].errors[message], value)
            };
        }
        if (!Object.keys(multipleMessages).length) {
            return [];
        }
        const msgs = Object.values(multipleMessages);
        if (this.messages[fieldId].type === 'single') {
            return msgs[0];
        }
        else {
            return msgs.reduce((acc, item) => {
                return [...acc, ...item];
            }, []);
        }
    }
    // function that checks the type of the messages
    // test the value based on the type and
    // finally returns the message object based on the validation
    // if all the validation satisfies it return empty object
    switchMessages(type, data, fieldValue) {
        let obj = {};
        switch (type.toLowerCase()) {
            case 'mandatory':
                data.messages.forEach(mObj => {
                    if ((mObj.value === fieldValue) === mObj.displayOn) {
                        obj = this.storeObj(obj, data, mObj);
                    }
                });
                return this.returnProperData(obj, data);
            case 'regex':
                if (fieldValue) {
                    data.messages.forEach(mObj => {
                        const regex = new RegExp(mObj.value);
                        const test = regex.test(fieldValue);
                        // displayOn is needed to check if the message needs to be 
                        // shown when the condition gets satisfied or not
                        // default value should true
                        if (test === mObj.displayOn) {
                            obj = this.storeObj(obj, data, mObj);
                        }
                    });
                }
                return this.returnProperData(obj, data);
            case 'minlength':
                if (fieldValue) {
                    data.messages.forEach(mObj => {
                        if (fieldValue.length <= mObj.value === mObj.displayOn) {
                            obj = this.storeObj(obj, data, mObj);
                        }
                    });
                }
                return this.returnProperData(obj, data);
            case 'maxlength':
                if (fieldValue) {
                    data.messages.forEach(mObj => {
                        if (fieldValue.length >= mObj.value === mObj.displayOn) {
                            obj = this.storeObj(obj, data, mObj);
                        }
                    });
                }
                return this.returnProperData(obj, data);
            default:
                return {};
        }
    }
    /**
     * private function check if the the data is present in the object
     * @param finalObject the final object that needs to be returned back
     * @param messageData the whole message data
     * @param currObj the current validation message that is checked
     */
    storeObj(finalObject, messageData, currObj) {
        if (!finalObject[messageData.priority]) {
            finalObject[messageData.priority] = [];
        }
        // it should return the cee error object map not the error object;
        finalObject[messageData.priority].push(this.returnCEEMessageObject(currObj.messageId));
        return finalObject;
    }
    /**
     * function returns the data one th basis of the data present in the object
     * if the priority object is has length 0 then it will return
     * empty object else it will return priority object
     * @param finalObject the final object that needs to be returned back
     * @param messageData the whole message data
     */
    returnProperData(finalObject, messageData) {
        if (finalObject[messageData.priority] && Object.keys(finalObject[messageData.priority]).length) {
            return finalObject;
        }
        else {
            return {};
        }
    }
    // TODO
    /**
     * function returns the CEE Message object that is configured in the CEE Portal
     * and by mapping through the message Id
     * @param messageId the message ID
     */
    returnCEEMessageObject(messageId) {
        if (this.ceeMessages[messageId]) {
            return this.ceeMessages[messageId];
        }
        return {
            color: '',
            message_text: ''
        };
    }
}

/**
 * This file should contain all the internal emitters used
 * by the CEE Angular Product
 * Note: All the internal emitters except the following
 * need to be moved to this file
 * accordionStateEmitter
 * customEventVariableEmitter
 * customEventTargetSubscriber
 * eventResponseSubscriber
 * emitApiSuccessResponse
 * emitApiErrorResponse
 * customSectionLoaderEmitter
 */
class CEEInternalEmitterService {
    fileUploadActionEmitter = new EventEmitter();
    languageChangeEmitter = new EventEmitter();
    static ɵfac = function CEEInternalEmitterService_Factory(t) { return new (t || CEEInternalEmitterService)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CEEInternalEmitterService, factory: CEEInternalEmitterService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CEEInternalEmitterService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

/**
 * class file uses crypto .js for encryption
 * and decryption type of encryption/decryption can be
 * added from the map file if the map file does not
 * contain the algorithm then it will by default use
 * the AES algorithm
 */
const AlgorithmName = new InjectionToken('algorithmName');
const encryptMap = {
    aes_256: 'AES',
    aws_aes_256: 'AES',
    des: 'DES',
    triple_des: 'TripleDES',
    rabbit: 'Rabbit',
    rc4: 'RC4',
    rc4drop: 'RC4Drop'
};
class CEEEncryptDecryptUtil {
    algorithmName;
    encMethod = 'AES';
    delimiter = '##CBOEIBO##'; // decode in https://www.theproblemsite.com/reference/mathematics/codes/shifted-alphabet-code
    constructor(algorithmName) {
        this.algorithmName = algorithmName;
        this.encMethod = encryptMap[this.algorithmName.toLowerCase()] || this.encMethod;
    }
    /**
     * function encrypts the file that is send
     * @param strFile: string the file or the text
     * @param secretKey the key to encrypt the file
     * @returns encrypted file
     */
    encrypt(strFile, secretKey, cipherTextBlob) {
        let encryptedFile = '';
        try {
            encryptedFile = CryptoJS[this.encMethod].encrypt(strFile, secretKey).toString();
            encryptedFile = `${encryptedFile}${this.delimiter}${cipherTextBlob}`;
        }
        catch (err) {
            console.error(`Error Occurred while encrypting the file`, err);
        }
        return encryptedFile;
    }
    /**
     * function decrypts the file that is send
     * @param strFile the file or the text
     * @param secretKey the secret key that gets returned from the decryption
     * @returns decrypted file
     */
    decrypt(strFile, secretKey) {
        let decryptedStr = '';
        try {
            strFile = strFile.split(this.delimiter)[0];
            decryptedStr = CryptoJS[this.encMethod].decrypt(strFile, secretKey).toString(CryptoJS.enc.Utf8);
        }
        catch (error) {
            console.error(`Error occurred while decrypting the file`, error);
        }
        return decryptedStr;
    }
    static ɵfac = function CEEEncryptDecryptUtil_Factory(t) { return new (t || CEEEncryptDecryptUtil)(i0.ɵɵinject(AlgorithmName)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CEEEncryptDecryptUtil, factory: CEEEncryptDecryptUtil.ɵfac, providedIn: 'any' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CEEEncryptDecryptUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'any',
            }]
    }], () => [{ type: undefined, decorators: [{
                type: Inject,
                args: [AlgorithmName]
            }] }], null); })();

class FileUploadService {
    http;
    ceeInternalEmitter;
    apiDataService;
    appDataService;
    headers = {};
    apiEndPoint = `/application/${sessionStorage.getItem('CEE_WFEId')}/attachment/`;
    applicationServicesUrl = localStorage.getItem('applicationServicesUrl');
    renameEndPoint = '/rename-object';
    encrypted = window.sessionStorage.getItem('CEE_Encrypt') &&
        (window.sessionStorage.getItem('CEE_Encrypt_Values') || '').includes('user_attachments') ? true : false;
    flatAndNestUtil;
    encryptRequestBody = {
        region: '',
        keyId: '',
        algorithm: ''
    };
    decryptRequestBody = {
        region: '',
        cipherTextBlob: '',
        decrypt: 'true'
    };
    url = '';
    apiData = {
        id: '',
        apiKey: '',
        apiUrl: '',
        value: ''
    };
    ceeEncryptDecrypt;
    commonUtil;
    constructor(http, ceeInternalEmitter, apiDataService, appDataService) {
        this.http = http;
        this.ceeInternalEmitter = ceeInternalEmitter;
        this.apiDataService = apiDataService;
        this.appDataService = appDataService;
        this.flatAndNestUtil = new FlatUnflat(appDataService);
        this.ceeEncryptDecrypt = new CEEEncryptDecryptUtil(window.sessionStorage.getItem('CEE_Encrypt') || '');
        const encryptConfig = JSON.parse(localStorage.getItem('CEE_ENCRYPT_CONFIG')) || {};
        // set the encrypt/decrypt variables
        this.encryptRequestBody.keyId = encryptConfig['KEY_ID'] || '';
        this.encryptRequestBody.region = this.decryptRequestBody.region = encryptConfig['REGION'] || '';
        this.encryptRequestBody.algorithm = encryptConfig['ALG'] || '';
        this.url = encryptConfig['URL'] || '';
        this.commonUtil = new CommonUtil();
    }
    get getHeaders() {
        return this.headers;
    }
    set setHeaders(data) {
        if (data) {
            this.headers = { ...this.headers, ...data };
        }
    }
    /**
     * a setter function that stores the attachment
     * meta data response that comes from the backend
     * object should contain id, apiUrl, value
     */
    storeAttachmentMetaData(data) {
        const { id, apiUrl, value } = data;
        const flattenResponse = this.flatAndNestUtil.flattenJSON(value);
        this.apiData.id = id;
        this.apiData.apiUrl = apiUrl;
        const modifiedObject = {};
        for (const key of Object.keys(flattenResponse)) {
            const keyName = id + '##' + key;
            let flatData = flattenResponse[key];
            if (flattenResponse[key] === null || flattenResponse[key] === 'null') {
                flatData = '';
            }
            else if (typeof (flattenResponse[key]) === 'boolean') {
                flatData = flattenResponse[key] ? '1' : '0';
            }
            else if ((!Array.isArray(flattenResponse[key]) ||
                typeof (flattenResponse[key]) !== 'object') &&
                typeof (flattenResponse[key]) !== 'string') {
                flatData = String(flattenResponse[key]);
            }
            modifiedObject[keyName] = flatData;
        }
        modifiedObject.handler_name = apiUrl;
        this.apiData.value = modifiedObject;
        // if exists update else add api data
        const isPresent = this.apiDataService.getApiDataByHandler(String(id));
        if (isPresent) {
            this.apiDataService.updateApiData(Object.assign({}, this.apiData));
        }
        else {
            this.apiDataService.addApiData(Object.assign({}, this.apiData));
        }
    }
    /**
     * generic file service function that uploads, downloads,  previews, deletes
     * the files based on the type of the request
     * @param type the type of the request
     * @param payLoad the data specific to the generic application services
     * @param extraConfigData the data that can be configured in the api config json
     */
    async genericFileService(type, payLoad, extraConfigData = {}, eventHandler = '') {
        let queryData;
        let requestBody;
        let queryParam = '';
        const url = extraConfigData.url ? this.getUrl(extraConfigData) : '';
        // set the headers
        this.setHeaders = extraConfigData.headers || {};
        if (extraConfigData.hasAuthorisation) {
            const accessToken = this.commonUtil.returnAccessToken();
            this.setHeaders = { Authorization: accessToken };
        }
        const hasCustomEventHandler = extraConfigData.hasCustomEventHandler || false, customEventHandler = extraConfigData.customEventHandler || undefined;
        // if there is a record id present
        // in the akita store use that else use the record id in the session storage
        // if not present session storage will return null and null if null record id wont be
        // added as a request body
        const getRecordId = window.sessionStorage.getItem('CEE_RecordId');
        const app_id = window.sessionStorage.getItem('CEE_WFEId');
        const recordId = (getRecordId && (this.apiDataService.getApiDataByApiKey(getRecordId) || {})['value']) || getRecordId;
        // // console.log(this.apiEndPoint);
        if (payLoad && payLoad.fileData) {
            queryData = {
                apiKey: payLoad.fileData.apiKey || '',
                attachmentId: encodeURIComponent(payLoad.fileData.attachmentId || '')
            };
            if (eventHandler === 'file/fetch' || eventHandler === 'file/remove' || eventHandler === 'file/rename') {
                queryData = {};
                queryParam = payLoad.fileData.attachmentId;
            }
            if (payLoad.fileData.attachmentPath) {
                queryData['attachmentPath'] = payLoad.fileData.attachmentPath;
            }
            if (payLoad.hasOwnProperty('extraQueryParams') && payLoad['extraQueryParams']) {
                queryData = { ...queryData, ...payLoad['extraQueryParams'] };
            }
            // tslint:disable-next-line: no-unused-expression
            recordId && (queryData['recordId'] = recordId);
            Object.keys(queryData).forEach((key, index) => queryParam = `${queryParam}${(index === 0) ?
                (url.includes('?') ? '&' : '?') : '&'}${key}=${queryData[key]}`);
            if (payLoad.fileData.file) {
                if (extraConfigData.isESB) {
                    requestBody = {
                        name: payLoad.fileData.file.name,
                        size: payLoad.fileData.file.size,
                        type: payLoad.fileData.file.type,
                        uId: payLoad.fileData.uId,
                        attachmentName: payLoad.fileData.attachmentName,
                        fileSize: payLoad.fileData.fileSize
                    };
                    requestBody = {
                        ...extraConfigData.esbRequestBody,
                        app_id,
                        api_request: JSON.stringify(requestBody)
                    };
                }
                else {
                    requestBody = new FormData();
                    // tslint:disable-next-line: no-unused-expression
                    recordId && requestBody.append('recordId', recordId);
                    // tslint:disable-next-line: no-unused-expression
                    for (const metaKey of Object.keys(payLoad.fileData)) {
                        if (metaKey != 'attachmentName') {
                            requestBody.append(metaKey, payLoad.fileData[metaKey]);
                        }
                    }
                    requestBody.append('attachmentName', payLoad.fileData.file.name);
                    if (payLoad && payLoad.fileData && payLoad.fileData.uId) {
                        this.setHeaders = { 'uId': payLoad.fileData.uId };
                    }
                    // payLoad.fileData.apiKey && requestBody.append('apiKey', payLoad.fileData.apiKey);
                    // requestBody.append('attachmentPath', payLoad.fileData.attachmentPath || '');
                    // requestBody.append('xxxx', payLoad.fileData.attachmentPath || '');
                    // check if encrypted is true and on upload encrypt the request file
                    if (type === 'OnUpload' && this.encrypted) {
                        const encryptRes = await this.encryptDecrypt().toPromise();
                        if (encryptRes.status == 200 && encryptRes.body && encryptRes.body['credentials']) {
                            const { cipherTextBlob, plainText } = encryptRes.body['credentials'];
                            // create string from the blob
                            const strFile = await Promise.resolve(this.createStringFromBlob(payLoad.fileData.file));
                            // create the encrypted file string
                            const encryptedFile = this.ceeEncryptDecrypt.encrypt(strFile, plainText, cipherTextBlob);
                            // create blob
                            const blob = new Blob([encryptedFile], { type: payLoad.fileData.file.type });
                            // create file
                            const file = new File([blob], payLoad.fileData.file.name, { type: payLoad.fileData.file.type });
                            // assign the converted blob to payload
                            payLoad.fileData.file = file;
                        }
                        else {
                            console.error(`Something went wrong while encrypting the file Status Code ${encryptRes.status} ${encryptRes}`);
                            return { statusCode: encryptRes.status, data: {}, emit: false };
                        }
                    }
                    requestBody.append('file', payLoad.fileData.file);
                    // check for request body in the extra config data object
                    if (extraConfigData.requestBody) {
                        Object.keys(extraConfigData.requestBody).forEach(key => {
                            requestBody.append(key, extraConfigData.requestBody[key]);
                        });
                    }
                }
            }
        }
        // emit flag false will not emit the emitApiSuccessResponse in the
        // wfe event list handler
        const responseData = {
            handler: hasCustomEventHandler ? customEventHandler : eventHandler,
            actualHandler: eventHandler,
            hasCustomEventHandler: hasCustomEventHandler,
            statusCode: 200,
            event_success: true,
            emit: false,
            data: {}
        };
        let res;
        switch (type) {
            case 'OnPreview':
            case 'OnLoad':
                if (type !== 'OnPreview') {
                    responseData.emit = true;
                }
                try {
                    // res = await this.fetchFile(queryParam, url).toPromise();
                    if ((extraConfigData.isESB) && (extraConfigData.methodType == "POST")) {
                        res = await this.postReq({ ...extraConfigData.esbRequestBody, app_id, id: queryParam }, url).toPromise();
                    }
                    else {
                        res = await this.fetchFile(queryParam, url).toPromise();
                    }
                }
                catch (err) {
                    res = err;
                }
                break;
            case 'OnUpload':
                try {
                    // responseData.emit = true;
                    res = await this.uploadFile(requestBody, url).toPromise();
                    if (res && res.status === 200 && res.body && res.body.api_response) {
                        const apiRes = JSON.parse(res.body.api_response);
                        const uploadLink = JSON.parse(JSON.stringify(apiRes.result.url));
                        const requestFileBody = new FormData();
                        for (const key in uploadLink['fields']) {
                            requestFileBody.append(key, uploadLink['fields'][key]);
                        }
                        requestFileBody.append('file', payLoad.fileData.file);
                        this.headers = {};
                        const resFile = await this.uploadFile(requestFileBody, uploadLink['url']).toPromise();
                        if (resFile.status === 204) {
                            res.body = apiRes;
                        }
                        else {
                            res = { err: 'File Upload faild to: ' + uploadLink };
                        }
                    }
                }
                catch (err) {
                    res = err;
                }
                break;
            case 'OnRemove':
                try {
                    // res = await this.removeFile(queryParam, url).toPromise();
                    if ((extraConfigData.isESB) && (extraConfigData.methodType == "POST")) {
                        res = await this.postReq({ ...extraConfigData.esbRequestBody, app_id, id: queryParam }, url).toPromise();
                    }
                    else {
                        res = await this.removeFile(queryParam, url).toPromise();
                    }
                }
                catch (err) {
                    res = err;
                }
                break;
            case 'OnRename':
                try {
                    res = await this.renameFile({ ...extraConfigData.esbRequestBody, app_id: app_id, id: payLoad.fileData.attachmentId, "file-rename": payLoad.fileData.newName }, url).toPromise();
                }
                catch (err) {
                    res = err;
                }
                break;
            default:
                console.error(`Event Name Mismatch: ${type}`);
                break;
        }
        responseData.statusCode = res.body.header_status_code || res.statusCode || res.status;
        // responseData.data = {};
        // check if res.result && res.result.fileUpload is true
        // if yes then do the following
        // else
        // check if payload has an api key
        // the sent the res.result back
        // else
        // create an object with key FILE_UPLOAD_DATA
        // and value as res.result as the key is the custom api key
        // if both the above conditions are undefined
        // then return res.error
        responseData.data = res.body ? (res.body.result && res.body.result.fileUpload ? {
            [payLoad.fileData.apiKey]: typeof (res.body.result.fileUpload) === 'string' ? JSON.parse(res.body.result.fileUpload) :
                res.body.result.fileUpload
        } : (payLoad.fileData.apiKey || payLoad.fileData.apiKey === '') ? res.body.result || res.body : { FILE_UPLOAD_DATA: res.body.result }) || res.body : res.error;
        //
        responseData.event_success = responseData.statusCode == 200;
        // check if event handler is present
        if (res.status !== 0) {
            this.storeAttachmentMetaData({
                id: hasCustomEventHandler ? customEventHandler : eventHandler,
                apiUrl: hasCustomEventHandler ? customEventHandler : eventHandler,
                apiKey: '',
                value: responseData.data
            });
        }
        //
        this.ceeInternalEmitter.fileUploadActionEmitter.emit({ type, responseData, payLoad });
        return responseData;
    }
    uploadFile(requestBody, url = '') {
        return this.http.post(url || `${this.applicationServicesUrl}${this.apiEndPoint}add`, requestBody, { headers: this.headers, observe: 'response', reportProgress: true });
    }
    removeFile(queryData, url = '') {
        return this.http.delete(url ? `${url}${queryData}` :
            `${this.applicationServicesUrl}${this.apiEndPoint}delete${queryData}`, { headers: this.headers, observe: 'response' });
    }
    fetchFile(queryData, url = '') {
        return this.http.get(url ? `${url}${queryData}` :
            `${this.applicationServicesUrl}${this.apiEndPoint}fetch${queryData}`, { headers: this.headers, observe: 'response' });
    }
    postReq(requestBody, url = '') {
        return this.http.post(`${url}`, requestBody, { headers: this.headers, observe: 'response' });
    }
    previewFile(queryData, url = '') {
        return this.http.get(url ? `${url}${queryData}` :
            `${this.applicationServicesUrl}${this.apiEndPoint}fetch${queryData}`, { headers: this.headers, observe: 'response' });
    }
    updateFile(requestBody, url = '') {
        return this.http.patch(url || `${this.applicationServicesUrl}${this.apiEndPoint}update`, requestBody, {
            headers: this.headers, observe: 'response'
        });
    }
    renameFile(requestBody, url = '') {
        return this.http.post(url || `${this.applicationServicesUrl}${this.renameEndPoint}`, requestBody, { headers: this.headers, observe: 'response', reportProgress: true });
    }
    /***
     * function that sets the url
     * from the config
     * @param apiConfigData the configured data from api config
     */
    getUrl(apiConfigData) {
        let apiURL = apiConfigData.url;
        // set url param
        for (const key of Object.keys(apiConfigData.urlParams)) {
            if (apiURL.includes(`{${key}}`)) {
                apiURL = apiURL.split(`{${key}}`).join(apiConfigData.urlParams[key]);
            }
        }
        // set query param
        for (const key of Object.keys(apiConfigData.queryParams)) {
            if (apiURL.includes(`{${key}}`)) {
                apiURL = apiURL.split(`{${key}}`).join(apiConfigData.queryParams[key]);
            }
        }
        // console.log(apiURL);
        return apiURL;
    }
    /**
     * call the ceeEncryptDecrypt decrypt function so that
     * the code should call this function not the function in util file
     */
    returnDecryptedResult(strFile, secretKey) {
        return this.ceeEncryptDecrypt.decrypt(strFile, secretKey);
    }
    /**
     * function that will get the private key/secret key from the api
     * @param type the type of the operation that is performed
     * @param decryptString the string that needs to be sent to the
     * backend to get the private key
     * * decryptString is only needed when the type is decrypt
     * @returns an observable
     */
    encryptDecrypt(type = 'encrypt', decryptString = '') {
        if (type !== 'encrypt') {
            this.decryptRequestBody.cipherTextBlob = decryptString.split(this.ceeEncryptDecrypt.delimiter)[1] || '';
        }
        return this.http.post(this.url, type === 'encrypt' ? this.encryptRequestBody : this.decryptRequestBody, { observe: 'response' });
    }
    /**
     * method that creates a base64 string/normal string based on the type
     * @param blob the blob of a file
     * @param type the type of the operation based on which the
     * the file needs to be read and sen back
     * * type == 'encrypt' reads a base64 string else
     * * reads a normal text string
     * @returns a Promise of string
     */
    createStringFromBlob(blob, type = 'encrypt') {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                resolve(reader.result);
            };
            if (type === 'encrypt') {
                reader.readAsDataURL(blob);
            }
            else {
                reader.readAsText(blob);
            }
            reader.onerror = error => {
                console.error('Error while converting buffer to string', error);
                reject(error);
            };
        });
    }
    static ɵfac = function FileUploadService_Factory(t) { return new (t || FileUploadService)(i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(CEEInternalEmitterService), i0.ɵɵinject(ApiDataService), i0.ɵɵinject(AppDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: FileUploadService, factory: FileUploadService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FileUploadService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: i9.HttpClient }, { type: CEEInternalEmitterService }, { type: ApiDataService }, { type: AppDataService }], null); })();

class BaseView {
    userDataHandlerService;
    sharedEventsService;
    internalCEEEmitter;
    appDataService;
    apiDataService;
    wfeStepLoaderService;
    dialog;
    snackBar;
    http;
    _ceeApiService;
    router;
    fileUploadService;
    rootData;
    stepId;
    fieldData;
    hasInitialized = false;
    fieldData$;
    hasTooltip = false;
    tabIndexValue = 0; // By default 0, means tabbing in a sequential order.
    isEditable = false;
    isVisible = false;
    isMandatory = false;
    isCustomClass = true;
    isSafariClass = false;
    hasComments = false;
    hasAttachments = false;
    fieldValue = '';
    apiValue = '';
    additionalParameter = {};
    event_handler;
    isOnSelect = false;
    selectedDataObj = {};
    dependentObj = {};
    manageState = false;
    fromField = null;
    // message declarations
    messages = [];
    modalMessages = [];
    snackBarMessages = [];
    multipleErrorMessage = false;
    errorMessageData = { message_code: '', message_text: '', type: '', color: '' };
    showErrorOnNext = false;
    showComparisonError = {};
    comparisonErrorMessageData = { message_code: '', message_text: '', type: '', color: '' };
    characterCount = {
        display: false,
        type: ''
    };
    characterCountMessageData = {
        left: { message_code: '', message_text: '', type: '', color: '' },
        right: { message_code: '', message_text: '', type: '', color: '' },
    };
    // TODO Next Button error message needs to be done
    // Application Data Declarations
    appDataQuery;
    appData = {
        id: '',
        stepId: '',
        apiKey: '',
        fieldLabel: '',
        linkedBlockId: '',
        isRepeatedField: false,
        repeatedBlockFieldId: '',
        requestApiKey: [],
        responseApiKey: [],
        dataFormatSeparator: '',
        mandatory: false,
        editable: false,
        visible: false,
        value: '',
        isValid: true
    };
    valid = true;
    repetableBlockModel = {
        fieldId: '',
        isMandatory: false
    };
    changeDetectorRef;
    presetData;
    repeatableDataPresent = false;
    variableObject = {}; // variable object
    conditionObj = {}; // object that defines to override conditions
    // Util declarations
    conditionalValidator;
    sessionKeyUtil;
    wfeConditionalExecuter;
    wfeEventListHandler;
    apiKeyUtil;
    commonUtil;
    conditionalUtil;
    saveFieldValueUtil;
    flattenUnflattenUtil;
    repeatableBlockDataUtil;
    setApiCallBackDataUtil;
    setDynamicLabelUtil;
    externalRequestResponseUtil;
    apiConfigPath = 'assets/jsons/api_config.json';
    bindKeyList = [];
    checkEmpty;
    customErrorsValidation;
    is_bootstrap;
    is_material;
    fieldStyle;
    isListView = false;
    isTableView = false;
    ;
    constructor(userDataHandlerService, sharedEventsService, internalCEEEmitter, appDataService, apiDataService, wfeStepLoaderService, dialog, snackBar, http, _ceeApiService, router, fileUploadService) {
        this.userDataHandlerService = userDataHandlerService;
        this.sharedEventsService = sharedEventsService;
        this.internalCEEEmitter = internalCEEEmitter;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.wfeStepLoaderService = wfeStepLoaderService;
        this.dialog = dialog;
        this.snackBar = snackBar;
        this.http = http;
        this._ceeApiService = _ceeApiService;
        this.router = router;
        this.fileUploadService = fileUploadService;
        this.conditionalValidator = new ConditionalValidator();
        this.sessionKeyUtil = new SessionKeyUtil();
        this.wfeConditionalExecuter = new WFEConditionalExecuter(appDataService, apiDataService);
        this.apiKeyUtil = new APIKeyUtil();
        this.commonUtil = new CommonUtil();
        this.repeatableBlockDataUtil = new RepeatableBlockData();
        this.conditionalUtil = new ConditionalUtil(this.singleCondition, appDataService, apiDataService);
        this.wfeEventListHandler = new WFEEventListHandler(_ceeApiService, router, sharedEventsService, internalCEEEmitter, wfeStepLoaderService, appDataService, apiDataService, dialog, snackBar, http, fileUploadService);
        this.saveFieldValueUtil = new SaveFieldValueUtil();
        this.flattenUnflattenUtil = new FlatUnflat(appDataService);
        this.setApiCallBackDataUtil = new SetAPICallbackData(apiDataService);
        this.setDynamicLabelUtil = new DynamicLabelUtil(apiDataService, appDataService);
        this.externalRequestResponseUtil = new ExternalRequestResponseUtil(http, appDataService, apiDataService, sharedEventsService);
        this.checkEmpty = new EmptyUtil();
        this.customErrorsValidation = new CustomErrorsValidation(this.wfeStepLoaderService.messagesDataMap, this.wfeStepLoaderService.customErrorMessages);
        if (localStorage.getItem('is_bootstrap') === 'true') {
            this.is_bootstrap = true;
        }
        if (localStorage.getItem('is_material') === 'true') {
            this.is_material = true;
        }
    }
    // update star with position in display condition of fieldData
    updateStarWithPositionInFieldData(position) {
        if (this.fieldData.display_condition && this.fieldData.display_condition.condition) {
            this.fieldData.display_condition.condition.forEach((cond) => {
                let op = cond.comparision_operator.toLowerCase();
                if (op == 'e' || op == 'ne') {
                    if (cond.api_key && cond.api_key.includes('[*]')) {
                        cond.api_key = cond.api_key.replace('[*]', `[${position}]`);
                    }
                }
            });
        }
    }
    init(stepId, fieldData, manageState = false, data, ref) {
        if (!fieldData.field_style) {
            fieldData.field_style = {};
        }
        // safari fix - only apply if running in Safari browser
        if (this.isSafari) {
            this.isSafariClass = fieldData.field_style.bootstrap_class_name?.includes('safari-visibility-wrapper');
            if (this.isSafariClass) {
                this.fieldData.field_style.bootstrap_class_name = fieldData.field_style.bootstrap_class_name.replace('safari-visibility-wrapper', '').trim();
            }
        }
        this.changeDetectorRef = ref;
        this.presetData = data;
        this.stepId = stepId;
        this.fieldData = JSON.parse(JSON.stringify(fieldData));
        // update field data when the component is part of repeatable block
        if (data && data.linkedBlockId && data.position !== undefined) {
            this.updateStarWithPositionInFieldData(data.position);
        }
        this.wfeEventListHandler.fieldData = fieldData;
        this.appData.id = this.fieldData.unique_id;
        this.appData.fieldLabel = this.storeLabels ? this.fieldData.field_label : '';
        this.fieldData.html_id = this.presetData ?
            (this.presetData.html_id ? this.presetData.html_id : this.fieldData.unique_id) : this.fieldData.unique_id;
        this.appData.fieldLabel = localStorage.getItem('storeLabels') === 'true' ? this.fieldData.field_label : '';
        this.appData.stepId = stepId;
        this.appData.linkedBlockId = this.presetData ? (this.presetData.linkedBlockId ? this.presetData.linkedBlockId : '') : '';
        this.appData.repeatedBlockFieldId = this.presetData ?
            (this.presetData.repeatedBlockFieldId ? this.presetData.repeatedBlockFieldId : '') : '';
        // backward compatibility support
        if (this.isSingleApiKey) {
            this.appData.apiKey = this.fieldData.api_key;
        }
        else {
            // console.log(this.fieldData.unique_id, this.fieldData.request_api_key, this.fieldData.response_api_key)
            this.appData.requestApiKey = this.apiKeyUtil.getMultipleApiKeys(this.fieldData.request_api_key);
            this.appData.responseApiKey =
                this.apiKeyUtil.getMultipleApiKeys(this.apiKeyUtil.getConcatenatedApiKeys(this.fieldData.response_api_key));
        }
        this.manageState = manageState;
        // console.log('this.appData', this.appData);
        if (typeof (this.presetData) === 'object' && this.presetData !== null) {
            if (this.presetData.unique_id) {
                this.appData.id = this.presetData.unique_id;
            }
            if (this.isSingleApiKey) {
                if (this.presetData.api_key) {
                    this.appData.apiKey = this.presetData.api_key;
                }
            }
            else {
                // console.log('called in init', this.presetData);
                if (this.presetData.request_api_key) {
                    this.appData.requestApiKey = this.presetData.request_api_key;
                }
                if (this.presetData.response_api_key) {
                    this.appData.responseApiKey = this.presetData.response_api_key;
                }
                if (this.presetData.event_list && this.presetData.event_list.length > 0) {
                    this.fieldData.event_list = this.presetData.event_list;
                }
            }
            if (this.presetData.mandatory) {
                this.appData.mandatory = this.presetData.mandatory;
            }
            if (this.presetData.editable) {
                this.appData.editable = this.presetData.editable;
            }
            if (this.presetData.visible) {
                this.appData.visible = this.presetData.visible;
            }
            if (this.presetData.fromField) {
                this.fromField = this.presetData.fromField;
            }
        }
        if (this.fieldData.tooltip && this.fieldData.tooltip.length > 0) {
            this.hasTooltip = true;
        }
        if (this.presetData && this.presetData.hasOwnProperty('fromField')) {
            this.isListView = this.presetData.fromField === 'List' ? true : false;
            this.isTableView = this.presetData.fromField === 'Table' ? true : false;
        }
        // Check if data state present
        if (manageState) {
            const fieldUniqueId = this.presetData ?
                (this.presetData.unique_id ? this.presetData.unique_id : this.fieldData.unique_id) : this.fieldData.unique_id;
            if (this.appData.linkedBlockId) {
                this.repeatableDataPresent = this.repeatableBlockDataUtil.returnIfData(this.appData.linkedBlockId, fieldUniqueId);
            }
            this.fieldData$ = this.appDataService.getAppDataByFieldId(fieldUniqueId);
            this.fieldData$
                .pipe(take(1))
                .subscribe(val => {
                if (!this.hasInitialized) {
                    if (val) {
                        if (val.id === fieldUniqueId) {
                            // State found
                            this.loadLastSavedState(val);
                        }
                    }
                    else {
                        // Create new state
                        this.createNewFieldState(manageState);
                    }
                }
            }, err => {
                console.error(err);
            });
        }
        else {
            this.createNewFieldState(manageState);
        }
        this.multipleErrorMessage = localStorage.getItem('multipleErrorMessage') === 'true' ? true : false;
        if (this.multipleErrorMessage && this.fieldData.validation_messages) {
            // TODO:Recheck code revert if code breaks any old implementation
            // const messages = this.returnMessages(this.fieldData.validation_messages);
            this.fieldData.validation_messages.forEach(message => {
                if (message.type !== 'Conditional') {
                    message = {
                        type: message.type,
                        displayType: message.display_type,
                        code: message.message_code
                    };
                    switch (message.displayType) {
                        case 'POPUP':
                            this.snackBarMessages.push(message);
                            break;
                        case 'MODAL':
                            this.modalMessages.push(message);
                            break;
                        case 'INLINE':
                            this.messages.push(message);
                            break;
                    }
                }
            });
        }
        else {
            const messageData = this.returnMessageData(this.fieldData.message_code);
            if (messageData) {
                this.errorMessageData = messageData;
            }
        }
        // console.log(this.messages);
        if (!this.isListView && !this.isTableView) {
            this.variableObject['showMandatoryErrorMsg_' + this.appData.id] = this.sharedEventsService.showMandatoryErrorMsg.subscribe((res) => {
                if (res) {
                    if (Array.isArray(res.fields) && res.type === 'event') {
                        if (res.fields.includes(this.appData.id)) {
                            this.setMandatoryError();
                        }
                    }
                    else {
                        this.setMandatoryError();
                    }
                    this.setModalorSanckBarMessage(this.fieldData.unique_id, this.appDataService.getFieldDataByFieldId(this.fieldData.unique_id));
                }
            });
        }
        if (this.additionalParameter['Textfield Type'] !== 'Search') {
            if (this.additionalParameter['BindKey']) {
                const keyList = this.additionalParameter['BindKey'].split('|').map(str => str.trim());
                for (const keyCode of keyList) {
                    this.rootData['BindKey'][keyCode] = () => {
                        this.sharedEventsService.emitKeyDown.emit();
                        this.onComponentEvent('OnClick');
                    };
                }
            }
        }
        if (this.fieldData.field_style) {
            this.fieldStyle = {
                'font-family': this.fieldData.field_style.font_name,
                'font-size': this.fieldData.field_style.font_size,
                'font-style': this.fieldData.field_style.font_style,
                color: this.fieldData.field_style.font_color,
                'border-color': this.fieldData.field_style.border_color,
                height: this.fieldData.field_style.field_height,
                width: this.fieldData.field_style.field_width,
                'background-color': this.fieldData.field_style.background_color
            };
        }
    }
    // returns true if the current browser is Safari
    get isSafari() {
        return typeof window !== 'undefined' &&
            /Safari/.test(navigator.userAgent) &&
            /Apple Computer/.test(navigator.vendor) &&
            !/Chrome|Chromium/.test(navigator.userAgent);
    }
    // returns css classes for field wrapper
    get cssClasses() {
        if (this.isSafariClass) {
            return 'field-wrapper safari-visibility-wrapper ' + (this.isVisible ? 'safari-visible' : 'safari-hidden');
        }
        return 'field-wrapper';
    }
    setMandatoryError() {
        if (this.isMandatory) {
            this.showErrorOnNext = this.checkEmpty.isEmpty(this.fieldValue);
            if (this.showErrorOnNext) {
                this.valid = false;
            }
        }
    }
    createNewFieldState(withState) {
        if (this.presetData) {
            if (this.presetData.mandatory) {
                this.isMandatory = this.presetData.mandatory;
            }
            else {
                if (this.fieldData.is_mandatory === 1) {
                    this.isMandatory = true;
                }
            }
            if (this.presetData.editable) {
                this.isEditable = this.presetData.editable;
            }
            else {
                if (this.fieldData.is_editable === 1) {
                    this.isEditable = true;
                }
            }
            if (this.presetData.visible) {
                this.isVisible = this.presetData.visible;
            }
            else {
                if (this.fieldData.is_display === 1) {
                    this.isVisible = true;
                }
            }
        }
        else {
            if (this.fieldData.is_editable === 1) {
                this.isEditable = true;
            }
            if (this.fieldData.is_mandatory === 1) {
                this.isMandatory = true;
            }
            if (this.fieldData.is_display === 1) {
                this.isVisible = true;
            }
        }
        this.conditionObj['isEditable'] = false;
        this.conditionObj['isVisible'] = false;
        this.conditionObj['isMandatory'] = false;
        /**
         * date - 27/05/2020
         * code changed to support External API Handling ESF-14644
         */
        const handlerData = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(this.fieldData.api_key));
        const value = this.isSingleApiKey ?
            this.hashApiKey ?
                this.setApiCallBackDataUtil.setApiCallBackData(this.fieldData.api_key, handlerData ? handlerData.value : {}) :
                this.apiDataService.getApiKeyValueByApiKey(this.fieldData.api_key) :
            this.setFieldValue();
        if (!(this.presetData ? this.presetData.hasOwnProperty('value') : this.presetData) && value) {
            // console.log(this.appData.id);
            if (this.fieldData.field_type == 'Textfield' || this.fieldData.field_type == 'Textarea' || this.fieldData.field_type == 'PhoneNumber') {
                let validationRegex = (this.fieldData.validation_regex && typeof this.fieldData.validation_regex.web == 'object' && this.fieldData.validation_regex.Web !== '') ? this.fieldData.validation_regex.web
                    : (typeof this.fieldData.validation_regex == 'string' && this.fieldData.validation_regex !== '') ? this.fieldData.validation_regex : '';
                if (value && validationRegex) {
                    const patt = new RegExp(validationRegex);
                    this.valid = patt.test(value);
                    this.appData.isValid = this.valid;
                }
            }
            if (this.fieldData.field_type === 'Calendar' || this.fieldData.field_type === 'TimeSlots') {
                this.apiValue = value;
            }
            else {
                this.fieldValue = value;
            }
        }
        else if (this.presetData) {
            // Handle repeatable block data
            if (this.fieldData.additional_parameters && this.fieldData.additional_parameters.length > 0) {
                for (const paramter of this.fieldData.additional_parameters) {
                    // this.additionalParameter[paramter.parameter_type] = paramter.value;
                    switch (paramter.parameter_type) {
                        case 'default_value':
                            this.presetData.default_value = paramter.value;
                            break;
                        case 'DisplayCharacterCount':
                            this.presetData.DisplayCharacterCount = paramter.value;
                            break;
                        case 'Time Format':
                            this.appData.dataFormatSeparator = ':';
                            break;
                        case 'Date Format':
                            this.appData.dataFormatSeparator = '/';
                            break;
                        case 'Data Format':
                            this.appData.isValid = true;
                            this.valid = true;
                            break;
                    }
                }
            }
            if (typeof (this.presetData) === 'object' && this.presetData !== null && this.presetData.hasOwnProperty('value')) {
                if (!Array.isArray(this.presetData.value)) {
                    // console.log('ADD', this.appData.id, JSON.parse(JSON.stringify(this.presetData)), this.presetData.isApiResponse);
                    this.fieldValue = this.presetData.value;
                    if (this.presetData.isApiResponse) {
                        this.appDataService.updateAppData(Object.assign({}, this.appData, { value: this.fieldValue }));
                    }
                }
            }
            else {
                this.fieldValue = this.presetData;
            }
        }
        else {
            if (this.fieldData.additional_parameters
                && this.fieldData.additional_parameters.length > 0) {
                for (const paramter of this.fieldData.additional_parameters) {
                    // this.additionalParameter[paramter.parameter_type] = paramter.value;
                    switch (paramter.parameter_type) {
                        case 'default_value':
                            this.fieldValue = paramter.value;
                            //Check if it has language change event
                            if (this.fieldData && this.fieldData.event_list && this.fieldData.event_list.length > 0) {
                                for (const event of this.fieldData.event_list) {
                                    if (event && event.event_params
                                        && event.event_params.find(ep => ep.event_config.display_step === "LanguageToggle")) {
                                        this.fieldValue = localStorage.getItem('lang') ? localStorage.getItem('lang').replace('/', '') : this.fieldValue;
                                    }
                                }
                            }
                            //For multiple default value
                            if (typeof (this.fieldValue) === 'string' && this.fieldValue.includes('||')) {
                                this.fieldValue = this.fieldValue.split('||').map(str => str.trim());
                            }
                            break;
                        case 'Time Format':
                            this.appData.dataFormatSeparator = ':';
                            break;
                        case 'Date Format':
                            this.appData.dataFormatSeparator = '/';
                            break;
                    }
                }
            }
        }
        if (this.fieldData.additional_parameters && this.fieldData.additional_parameters.length > 0) {
            for (const paramter of this.fieldData.additional_parameters) {
                this.additionalParameter[paramter.parameter_type] = paramter.value;
            }
        }
        // set character count message
        this.setCharacterCountMessage();
        this.getConcatenation();
        if (withState) {
            if (this.fieldData.field_type === 'Attachments' && this.fieldValue == '') {
                this.fieldValue = [];
            }
            // set the repeatable state if with state
            if (this.presetData) {
                if (this.presetData.unique_id) {
                    this.repeatableBlockDataUtil.updateRepeatableLocalStorageData(this.appData.linkedBlockId, {
                        ...this.repetableBlockModel,
                        ...{ fieldId: String(this.appData.id), isMandatory: this.isMandatory }
                    });
                }
            }
            this.appDataService.addAppData(Object.assign({}, this.appData, { visible: this.isVisible, editable: this.isEditable, mandatory: this.isMandatory, value: this.fieldValue }));
        }
        this.unsubscribeAndInit();
    }
    loadLastSavedState(val) {
        this.appData = Object.assign({}, val);
        this.isEditable = this.appData.editable;
        this.isMandatory = this.appData.mandatory;
        this.isVisible = this.appData.visible;
        this.fieldValue = this.appData.value;
        this.valid = this.appData.isValid;
        /**
         * date - 27/05/2020
         * code changed to support External API Handling ESF-14644
         */
        const handlerData = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(this.fieldData.api_key));
        const value = this.isSingleApiKey ?
            this.hashApiKey ?
                this.setApiCallBackDataUtil.setApiCallBackData(this.fieldData.api_key, handlerData ? handlerData.value : {}) :
                this.apiDataService.getApiKeyValueByApiKey(this.fieldData.api_key) :
            this.setFieldValue();
        if (!(this.presetData ? this.presetData.hasOwnProperty('value') : this.presetData) && value) {
            if (this.fieldData.field_type === 'Calendar' || this.fieldData.field_type === 'TimeSlots') {
                this.apiValue = value;
            }
            else {
                this.fieldValue = value;
            }
        }
        else if (typeof (this.presetData) === 'object' && this.presetData !== null) {
            if (this.fieldData.additional_parameters && this.fieldData.additional_parameters.length > 0) {
                for (const paramter of this.fieldData.additional_parameters) {
                    // this.additionalParameter[paramter.parameter_type] = paramter.value;
                    switch (paramter.parameter_type) {
                        case 'default_value':
                            this.presetData.default_value = paramter.value;
                            break;
                        case 'DisplayCharacterCount':
                            this.presetData.DisplayCharacterCount = paramter.value;
                            break;
                        case 'Time Format':
                            this.appData.dataFormatSeparator = ':';
                            break;
                        case 'Date Format':
                            this.appData.dataFormatSeparator = '/';
                            break;
                    }
                }
            }
            // Handle repeatable block data
            if (this.presetData.hasOwnProperty('value')) {
                // console.log('UPDATE', this.appData.id, JSON.parse(JSON.stringify(this.presetData)));
                if (!Array.isArray(this.presetData.value)) {
                    this.fieldValue = this.presetData.value;
                    if (this.presetData.isApiResponse) {
                        this.appDataService.updateAppData(Object.assign({}, this.appData, { value: this.fieldValue }));
                    }
                }
            }
            else {
                this.fieldValue = this.presetData;
            }
        }
        else {
            // if (this.fieldData.additional_parameters.length > 0) {
            //     for (const paramter of this.fieldData.additional_parameters) {
            //         this.additionalParameter[paramter.parameter_type] = paramter.value;
            //     }
            // }
        }
        if (this.fieldData.additional_parameters && this.fieldData.additional_parameters.length > 0) {
            for (const paramter of this.fieldData.additional_parameters) {
                this.additionalParameter[paramter.parameter_type] = paramter.value;
            }
        }
        // set character count message
        this.setCharacterCountMessage();
        this.getConcatenation();
        if (this.changeDetectorRef && !this.changeDetectorRef.destroyed) {
            this.changeDetectorRef.detectChanges();
        }
        this.unsubscribeAndInit();
    }
    unsubscribeAndInit() {
        // Fatching MaxValue and MinValue from repeated field of same row
        if (this.presetData) {
            const targetParams = ['MaxValue', 'MinValue'];
            for (const tParam of targetParams) {
                if (this.additionalParameter[tParam] && this.additionalParameter[tParam].endsWith('$')) {
                    this.additionalParameter[tParam] = this.stepId + '$' + this.additionalParameter[tParam] + this.presetData.position;
                }
            }
        }
        this.hasInitialized = true;
        if (this.fieldData$ && this.fieldData$.length > 0) {
            this.fieldData$.forEach((s) => {
                if (!s.closed) {
                    s.unsubscribe();
                }
            });
        }
        if (!this.isListView && !this.isTableView) {
            // TODO: Separate conditional for all emitters and then subscribe if required
            this.variableObject['emitOnDataSetOrUpdated_' + this.appData.id] = this.sharedEventsService.emitOnDataSetOrUpdated.subscribe(res => {
                if (res.index) {
                    if (res.index === String(this.appData.id).split('$')[2]) {
                        this.onSetSessionData(res.apiKey, res.value);
                        if (this.fieldData.validation_messages !== undefined) {
                            if (!(this.additionalParameter['sin_number'] === 'true')) {
                                this.conditionalErrorMessageCompareFields(res.apiKey, this.fieldData, String(this.appData.id));
                            }
                        }
                    }
                }
                else {
                    this.onSetSessionData(res.apiKey, res.value);
                    this.getConcatenation();
                    this.saveFieldValueUtil.saveListofFieldValues(res.apiKey, res.value, this.fieldData);
                    if (this.fieldData.validation_messages !== undefined) {
                        if (!(this.additionalParameter['sin_number'] === 'true')) {
                            this.conditionalErrorMessageCompareFields(res.apiKey, this.fieldData);
                        }
                    }
                    this.comparisonError();
                }
            });
            this.variableObject['emitSetFieldValueOnEvent_' + this.appData.id] =
                this.sharedEventsService.emitSetFieldValueOnEvent.subscribe(res => {
                    if (res) {
                        const _res = JSON.parse(JSON.stringify(res));
                        for (let i = 0; i < _res?.uniqueIds.length; i++) {
                            if (_res.uniqueIds[i] === this.appData.id) {
                                _res.uniqueIds[i] = this.fieldData.unique_id;
                            }
                        }
                        // set value event filter field for repeated table
                        if (this.appData.repeatedBlockFieldId) {
                            const idSplit = this.appData.id.toString().split('$');
                            if (idSplit.length === 3) {
                                const repeatedTableIndex = localStorage.getItem('repeatedTableIndex');
                                if (this.stepId != idSplit[1]) {
                                    this.setFieldValueOnSetValuesEvent(_res);
                                    return; // optimized to call setFieldValue only once
                                }
                                if (repeatedTableIndex && this.appData.repeatedBlockFieldId === repeatedTableIndex.split('|')[0]) {
                                    if (repeatedTableIndex.split('|')[1] !== idSplit[2]) {
                                        return;
                                    }
                                }
                            }
                        }
                        this.setFieldValueOnSetValuesEvent(_res);
                    }
                });
            if (this.manageState) {
                this.variableObject['stateHistoryEmitter_' + this.appData.id] =
                    this.sharedEventsService.stateHistoryEmitter.subscribe(res => {
                        if (res) {
                            // console.log(res);
                            this.updateStateHistory(res);
                            // updateStateHistory.remove(updateStateHistory);
                        }
                    });
            }
            this.variableObject['emitForEmptySession_' + this.appData.id] = this.sharedEventsService.emitForEmptySession.subscribe(res => {
                if (res) {
                    this.onEmptySession(res);
                }
            });
            this.variableObject['customEventTargetSubscriber_' + this.appData.id] =
                this.sharedEventsService.customEventTargetSubscriber.subscribe((res) => {
                    if (res) {
                        this.handleCustomFunction(res);
                    }
                });
            this.variableObject['emitApiSuccessResponse_' + this.appData.id] =
                this.sharedEventsService.emitApiSuccessResponse.subscribe(res => {
                    if (Array.isArray(res)) {
                        this.onAPICallback(res[0]);
                    }
                    else {
                        this.onAPICallback(res);
                    }
                    this.conditionCheck(this.fieldValue);
                    // this.setSessionData(this.fieldValue);
                });
            this.variableObject['emitFieldStateChangeEventEmitter_' + this.appData.id] =
                this.sharedEventsService.emitFieldStateChangeEventEmitter.subscribe(res => {
                    if (res) {
                        const id = this.returnUniqueId();
                        if (res.ids.includes(id)) {
                            switch (res.type) {
                                case 'ChangeVisibility':
                                    setTimeout(() => {
                                        this.isVisible = (res.value[0]) === 0 ? false : true;
                                    }, 0);
                                    break;
                                case 'ChangeEditable':
                                    setTimeout(() => {
                                        this.isEditable =
                                            (res.value.length > 0 ? res.value[res.ids.indexOf(id)] : res.value[0]) === 0 ? false : true;
                                    }, 0);
                                    break;
                                case 'ChangeMandatory':
                                    setTimeout(() => {
                                        this.isMandatory =
                                            (res.value.length > 0 ? res.value[res.ids.indexOf(id)] : res.value[0]) ? false : true;
                                    }, 0);
                                    break;
                            }
                            this.appDataService.updateAppData(Object.assign({}, this.appData, {
                                visible: this.isVisible,
                                editable: this.isEditable,
                                mandatory: this.isMandatory
                            }));
                        }
                    }
                });
        }
        /**
         * Emit after the code has subscribed the emitter else conditions on the last index of repeatable block
         * won't work
         */
        if (this.manageState) {
            this.setSessionData(this.fieldValue);
        }
        else if (!this.isListView && !this.isTableView) {
            this.onSetSessionData(this.fieldData.unique_id, this.fieldValue);
        }
        this.onViewDataInit();
        let attachmentApiKey = null;
        if (this.fieldData.field_type === 'Attachments') {
            if (this.isSingleApiKey) {
                attachmentApiKey = this.fieldData.api_key;
            }
            else if (this.fieldData.response_api_key) {
                const responseAPIkeyArr = this.fieldData.response_api_key.split('|');
                attachmentApiKey = responseAPIkeyArr[0];
                if (attachmentApiKey.includes('##')) {
                    attachmentApiKey = attachmentApiKey.split('##').pop();
                }
            }
        }
        // console.log('attachmentApiKey', attachmentApiKey);
        this.onComponentEvent('onLoad', {}, true, this.fieldData.field_type === 'Attachments' ? {
            type: 'file',
            fileData: { apiKey: attachmentApiKey }
        } : undefined);
    }
    onViewUnload() {
        if (this.changeDetectorRef && !this.changeDetectorRef.destroyed) {
            this.changeDetectorRef.detectChanges();
        }
        for (const key in this.variableObject) {
            if (this.variableObject[key]) {
                this.variableObject[key].unsubscribe();
            }
        }
    }
    onViewLoaded() { }
    // set attachment message
    /**
     * method sets message for the special
     * attachment data type
     */
    setAttachmentMessage(messageId) {
    }
    conditionCheck(value) {
        let mandatoryCondition;
        let editableCondition;
        let visibilityCondition;
        let customClassCondition;
        if (!this.conditionObj['isMandatory']) {
            mandatoryCondition = this.conditionalUtil.checkMandatory(this.fieldData, String(this.appData.id), value);
        }
        if (!this.conditionObj['isEditable']) {
            editableCondition = this.conditionalUtil.checkEditable(this.fieldData, String(this.appData.id), value);
        }
        if (!this.conditionObj['isVisible']) {
            visibilityCondition = this.conditionalUtil.checkVisibility(this.fieldData, String(this.appData.id), value);
        }
        if (this.fieldData['custom_class_condition'] && this.fieldData['custom_class_condition'].hasOwnProperty('query') && this.fieldData['custom_class_condition']['query'] != '') {
            customClassCondition = this.conditionalUtil.checkCustomClass(this.fieldData, String(this.appData.id), value);
        }
        const conditionalFieldValue = this.conditionalUtil.conditionalValue(this.fieldData, String(this.appData.id), value, this.fieldValue);
        if (mandatoryCondition !== undefined) {
            this.isMandatory = mandatoryCondition;
        }
        if (editableCondition !== undefined) {
            if (this.fromField === null) {
                this.isEditable = editableCondition;
                this.sharedEventsService.emitOnEditableStatusChanged.emit(this.fieldData.unique_id);
            }
        }
        if (visibilityCondition !== undefined) {
            if (this.fromField === null) {
                this.isVisible = visibilityCondition;
            }
        }
        if (customClassCondition !== undefined) {
            if (this.fromField === null) {
                this.isCustomClass = customClassCondition;
            }
        }
        if (this.fieldData.is_conditional_value && this.fieldData.is_conditional_value === 1) {
            if (conditionalFieldValue !== undefined) {
                if (conditionalFieldValue && String(conditionalFieldValue).includes('|')) {
                    this.fieldData.possible_values = conditionalFieldValue.split('|').map(s => s.trim());
                }
                else {
                    this.fieldValue = conditionalFieldValue;
                }
            }
        }
    }
    onSetSessionData(apiKey, value) {
        // console.log(apiKey, this.fieldData.unique_id + ' :: ' + value);
        this.conditionCheck(value);
        // check if preset data
        // Note: preset data only comes from table , list, and repeatable block
        // repeatable block contains unique id
        // if this is present store in another local storage
        // else store in akita store
        if (this.manageState) {
            if (this.presetData) {
                // set the repeatable state if with state
                if (this.appData.linkedBlockId) {
                    this.repeatableBlockDataUtil.updateRepeatableLocalStorageDataAfterSessionSet(this.appData.linkedBlockId, {
                        ...this.repetableBlockModel,
                        ...{ fieldId: String(this.appData.id), isMandatory: this.isMandatory }
                    });
                }
            }
            else {
                if (this.fieldData.is_mandatory === 2) {
                    this.appDataService.updateAppData(Object.assign({}, this.appData, { visible: this.isVisible, editable: this.isEditable, mandatory: this.isMandatory, value: this.fieldValue }));
                }
            }
        }
        if (this.changeDetectorRef && !this.changeDetectorRef.destroyed) {
            this.changeDetectorRef.detectChanges();
        }
    }
    onDirty() {
        if (!this.hasUnsavedData && this.modalOnPageLeave) {
            history.pushState(null, document.title, document.location.toString());
        }
        localStorage.setItem('has_unsaved_data', 'true');
        this.onComponentEvent('OnDirty');
    }
    /**
     * function that only updates a single entity in the akita store
     * and does not update or emit any event
     * @param data the field value that needs to be updated
     */
    updateFieldEntity(data) {
        if (this.manageState) {
            this.appDataService.updateAppData(Object.assign({}, this.appData, { visible: this.isVisible, editable: this.isEditable, mandatory: this.isMandatory, value: data }));
        }
    }
    /**
     * function that updates the attachment data in the akita store
     * special method that merges the new data with the existing data
     * or modifies the existing data based on the type or action
     * data
     */
    updateAttachments(type, fieldUniqueId, data = {}, attachmentId = '', isReplace = false) {
        let existingData = [];
        if (type) {
            const attachmentData = this.appDataService.getFieldDataByFieldId(fieldUniqueId);
            if (attachmentData) {
                // existingData = attachmentData;
                existingData = Object.assign([], attachmentData);
            }
        }
        else {
            existingData = data;
        }
        switch (type) {
            case 'upload':
                // console.log('Called', fieldUniqueId);
                // existingData = [...existingData, ...[data]];
                if (isReplace && existingData.length > 0) {
                    existingData[0] = data;
                }
                else {
                    existingData.push(data);
                }
                break;
            case 'delete':
                for (const [index, attachment] of Object.entries(existingData)) {
                    if (attachment.attachmentId === attachmentId) {
                        existingData.splice(Number(index), 1);
                        break;
                    }
                }
                // console.log('Deleted attachment data', existingData);
                break;
            case 'update':
                // TODO
                break;
            default:
                break;
        }
        // setTimeout(() => {
        this.updateFieldData(existingData);
        // this.appDataService.updateAppData(Object.assign({}, this.appData,
        //     {
        //         visible: this.isVisible,
        //         editable: this.isEditable,
        //         mandatory: this.isMandatory,
        //         isValid: true, value: existingData
        //     }));
        // this.sharedEventsService.buttonValidationEmitter.emit();
        // }, 1500);
    }
    updateFieldData(data, isValid = true) {
        // Perform custom validation check if applicable
        if (this.customCheck && data) {
            isValid = this.customErrorsValidation.getMessages(this.appData.id, data).length === 0 && isValid;
        }
        this.valid = isValid;
        this.fieldValue = data;
        // Update appData with new validation state
        this.appData = { ...this.appData, isValid };
        if (this.manageState) {
            this.appDataService.updateAppData({
                ...this.appData,
                visible: this.isVisible,
                editable: this.isEditable,
                mandatory: this.isMandatory,
                value: this.fieldValue,
            });
        }
        this.setSessionData(this.fieldValue);
        // Emit events asynchronously in a single timeout block
        setTimeout(() => {
            const { validateButtonForTagEmitter, buttonValidationEmitter } = this.sharedEventsService;
            validateButtonForTagEmitter.emit();
            buttonValidationEmitter.emit();
            // Emits Only if field is part of a repeatable block
            if (this.isRepeatable()) {
                this.sharedEventsService.rbCurrentIndex.emit(this.getRepeatableInfo());
            }
        }, 0);
    }
    /**
    * Check if field is part of a repeatable block
    */
    isRepeatable() {
        // Check if ID contains delimiter '$' which indicates repeatable block
        const idParts = String(this.appData.id).split('$');
        return (
        // Check if ID has 4 parts (stepId$blockId$parentPosition$position)
        // OR Check if ID has 3 parts (stepId$blockId$position)
        idParts.length === 3 || idParts.length === 4 ||
            // Check if it has repeatable block ID
            !!this.appData.repeatedBlockFieldId ||
            // Check if it's linked to a block
            !!this.appData.linkedBlockId ||
            // Check if it has preset data with position
            !!(this.presetData && this.presetData.position));
    }
    /**
     * Get repeatable block info if field is repeatable
     */
    getRepeatableInfo() {
        if (!this.isRepeatable()) {
            return null;
        }
        const idParts = String(this.appData.id).split('$');
        // Handle nested repeatable block: stepId$blockId$parentPosition$position
        if (idParts.length === 4) {
            return {
                stepId: idParts[0],
                id: idParts[1],
                parentPosition: parseInt(idParts[2]),
                position: parseInt(idParts[3]),
                isChildBlock: true,
                linkedBlockId: this.appData.linkedBlockId,
                repeatedBlockFieldId: this.appData.repeatedBlockFieldId
            };
        }
        // Handle regular repeatable block: stepId$blockId$position
        else if (idParts.length === 3) {
            return {
                stepId: idParts[0],
                id: idParts[1],
                parentPosition: undefined,
                position: parseInt(idParts[2]),
                isChildBlock: false,
                linkedBlockId: this.appData.linkedBlockId,
                repeatedBlockFieldId: this.appData.repeatedBlockFieldId,
            };
        }
    }
    // Emit on Data Set or Updated
    emitForFieldsSectionBlock(emitObj) {
        this.sharedEventsService.emitOnDataSetOrUpdated.emit(emitObj); // For Fields
        this.sharedEventsService.emitOnDataSetOrUpdatedForSection.emit(emitObj); // For Sections
        this.sharedEventsService.emitOnDataSetOrUpdatedForBlock.emit(emitObj); // For Blocks
        this.sharedEventsService.emitOnDataSetOrUpdatedForGenericBlock.emit(emitObj); // For Generic Blocks
    }
    setSessionData(data) {
        this.fieldValue = data;
        let emitObj = null;
        if (String(this.appData.id).split('$').length === 3) {
            emitObj = {
                apiKey: this.appData.linkedBlockId ? this.appData.id : this.fieldData.unique_id,
                value: data,
                index: String(this.appData.id).split('$')[2]
            };
        }
        else {
            emitObj = {
                apiKey: this.appData.linkedBlockId ? this.appData.id : this.fieldData.unique_id,
                value: data
            };
        }
        this.emitForFieldsSectionBlock(emitObj);
    }
    getSessionData() {
        this.fieldValue = this.userDataHandlerService.getFieldData(this.sessionKeyUtil.generateSessionKey(this.fieldData));
    }
    conditionalErrorMessageCompareFields = (apiKey, fieldData, repeatedFieldId = '', options) => {
        // console.log(this.fieldData.unique_id);
        if (!fieldData.validation_messages || !Array.isArray(fieldData.validation_messages) || fieldData.validation_messages.length === 0) {
            return;
        }
        const ifValid = [];
        for (const [index, validationMessage] of fieldData.validation_messages.entries()) {
            if (!validationMessage || !validationMessage.type) {
                continue;
            }
            if (validationMessage.type) {
                if (validationMessage.type === 'Conditional' || validationMessage.type === 'conditional_message') {
                    let validationMsg = {};
                    const displayMessage = this.wfeConditionalExecuter.evaluateConditionQuery(validationMessage.query, validationMessage.conditions, repeatedFieldId, {}, { unique_id: this.fieldData.unique_id, apiKey: this.fieldData.api_key });
                    if (this.wfeStepLoaderService.messagesDataMap[validationMessage.message_code]) {
                        validationMsg = this.wfeStepLoaderService.messagesDataMap[validationMessage.message_code];
                    }
                    // switch to display type of the message that is configured
                    // console.log("displayMessage", displayMessage);
                    if (displayMessage !== undefined) {
                        // this.updateFieldData(this.fieldData.value, false);
                        // update the app data for the field
                        ifValid.push(!displayMessage);
                    }
                    switch (validationMessage.display_type) {
                        case 'MODAL':
                            // show the error message in the modal
                            if (displayMessage) {
                                this.dialog.closeAll();
                                this.openDialog(validationMsg['message_text']);
                            }
                            break;
                        case 'INLINE':
                            //console.log('this.fieldData.additional param2 - ', this.fieldData.additional_parameters);
                            if (this.fieldData.additional_parameters['sin_number'] != true) {
                                if (displayMessage) {
                                    this.showComparisonError[String(this.appData.id) + '_' + index] = validationMsg;
                                    // this.comparisonErrorMessageData = validationMsg;
                                }
                                else {
                                    if (this.showComparisonError[String(this.appData.id) + '_' + index]) {
                                        delete this.showComparisonError[String(this.appData.id) + '_' + index];
                                    }
                                    // this.showComparisonError = false;
                                }
                            }
                            // console.log(this.fieldData.unique_id, this.showComparisonError);
                            break;
                        case 'POPUP':
                            // show the error message as popup or mat snack bar
                            if (displayMessage) {
                                this.snackBar.dismiss();
                                this.openSanckBar(validationMsg['message_text']);
                            }
                            break;
                        default:
                            // show the error message inline
                            //console.log('this.fieldData.additional param2 - ', this.fieldData.additional_parameters);
                            if (this.fieldData.additional_parameters['sin_number'] != true) {
                                if (displayMessage) {
                                    this.showComparisonError[String(this.appData.id) + '_' + index] = validationMsg;
                                    // this.comparisonErrorMessageData = validationMsg;
                                }
                                else {
                                    if (this.showComparisonError[String(this.appData.id) + '_' + index]) {
                                        delete this.showComparisonError[String(this.appData.id) + '_' + index];
                                    }
                                    // this.showComparisonError = false;
                                }
                            }
                            break;
                    }
                }
                if (validationMessage.type === 'Regex') {
                    let valid;
                    let mask = [];
                    let fieldVal = this.fieldValue;
                    if (this.additionalParameter["Data Format"] && this.additionalParameter["Data Format"] != '') {
                        let maskFormat = this.additionalParameter["Data Format"];
                        maskFormat.split('').forEach(element => {
                            element == 'X' || element == '0' ? mask.push('X') : mask.push(element);
                        });
                    }
                    // fieldVal = this.getMaskedInputValue(fieldVal, mask);
                    if (fieldVal && this.fieldData.validation_regex) {
                        const patt = new RegExp(this.fieldData.validation_regex);
                        valid = patt.test(fieldVal);
                    }
                    if (valid !== undefined) {
                        // this.updateFieldData(this.fieldData.value, false);
                        // update the app data for the field
                        ifValid.push(valid);
                    }
                }
            }
        }
        if (ifValid.length > 0) {
            // if regex validation is passed and has conditional errors
            if ((this.appData.isValid && ifValid.includes(false)) || !this.appData.isValid && !ifValid.includes(false)) {
                this.valid = !ifValid.includes(false);
                this.appData = Object.assign({}, this.appData, { isValid: this.valid });
                this.appDataService.updateAppData(Object.assign({}, this.appData, {
                    visible: this.isVisible,
                    editable: this.isEditable,
                    mandatory: this.isMandatory, isValid: this.valid, value: this.fieldValue
                }));
            }
        }
        this.sharedEventsService.buttonValidationEmitter.emit();
    };
    conditionalErrorMessageCompareFieldsSin = (apiKey, fieldData, repeatedFieldId = '', isMessageDisplay = false) => {
        // console.log(this.fieldData.unique_id);
        const ifValid = [];
        for (const [index, validationMessage] of fieldData.validation_messages.entries()) {
            if (validationMessage.type) {
                if (validationMessage.type === 'Conditional' || validationMessage.type === 'conditional_message') {
                    let validationMsg = {};
                    const displayMessage = isMessageDisplay;
                    if (this.wfeStepLoaderService.messagesDataMap[validationMessage.message_code]) {
                        validationMsg = this.wfeStepLoaderService.messagesDataMap[validationMessage.message_code];
                    }
                    // switch to display type of the message that is configured
                    // console.log("displayMessage", displayMessage); sd
                    if (displayMessage !== undefined) {
                        // this.updateFieldData(this.fieldData.value, false);
                        // update the app data for the field
                        ifValid.push(!displayMessage);
                    }
                    // console.log('validationMessage.display_type - ', validationMsg);
                    //this.showComparisonError[String(this.appData.id) + '_' + index] = validationMsg;
                    // show the error message inline
                    if (displayMessage) {
                        this.valid = false;
                        this.showComparisonError[String(this.appData.id) + '_' + index] = validationMsg;
                        // this.comparisonErrorMessageData = validationMsg;
                        return;
                    }
                    else {
                        this.valid = true;
                        if (this.showComparisonError[String(this.appData.id) + '_' + index]) {
                            delete this.showComparisonError[String(this.appData.id) + '_' + index];
                        }
                    }
                    // console.log(this.fieldData.unique_id, this.showComparisonError);
                }
            }
        }
        // if (ifValid.length > 0) {
        //     // if regex validation is passed and has conditional errors
        //     if ((this.appData.isValid && ifValid.includes(false)) || !this.appData.isValid && !ifValid.includes(false)) {
        //         this.valid = !ifValid.includes(false);
        //         this.appData = Object.assign({}, this.appData, { isValid: this.valid });
        //         this.appDataService.updateAppData(Object.assign({}, this.appData,
        //             {
        //                 visible: this.isVisible,
        //                 editable: this.isEditable,
        //                 mandatory: this.isMandatory, isValid: this.valid, value: this.fieldValue
        //             }));
        //     }
        // }
        // this.sharedEventsService.buttonValidationEmitter.emit();
    };
    getMaskedInputValue(inputValue, mask) {
        if (inputValue && mask && mask.length > 0) {
            let inputValueArr = inputValue.split('');
            let index = 0;
            let maskedInput = [];
            mask.forEach((v) => {
                if (v == 'X') {
                    maskedInput.push(inputValueArr[index++]);
                }
                else {
                    maskedInput.push(v);
                }
            });
            return maskedInput.join('');
            // return conformToMask(inputValue, mask, { guide: false }).conformedValue;
        }
        return inputValue;
    }
    returnMessages(messageArray) {
        const arr = [];
        for (const message of messageArray) {
            if (message.type !== 'Conditional') {
                arr.push({
                    type: message.type,
                    displayType: message.display_type,
                    code: message.message_code
                });
            }
        }
        return arr;
    }
    setData() {
        this.userDataHandlerService.setOrUpdateFieldData(this.fieldData.api_key, this.fieldValue);
    }
    updateConditionField(fieldData, data) {
        let unq = data.unique_id;
        fieldData.event_list.forEach(event => {
            event.event_params.forEach(params => {
                params?.condition?.forEach(condition => {
                    if (condition?.repeatableBlockExist === "true") {
                        if (condition.field) {
                            condition.field = unq;
                        }
                        if (condition.api_key) {
                            condition.api_key = unq;
                        }
                    }
                });
            });
        });
        return fieldData;
    }
    /**
     * function triggers the event list
     * @param type the event type
     * @param primaryData optional mainly the data that is stored in list or table
     * @param isDefault boolean flag to check the event by default it is set to true
     * @param payLoad optional data if required to pass to the event
     * @param displayType optional only required if display_type in the event needs to be matched default empty
     */
    onComponentEvent(type, primaryData = {}, isDefault = true, payLoad, displayType = '') {
        if (this.fieldData.event_list && this.fieldData.event_list.length > 0) {
            if (this.fieldData.field_type == 'Menu' && this.presetData) {
                this.fieldData = this.updateConditionField(this.fieldData, this.presetData);
            }
            const _this = this;
            setTimeout(() => {
                this.wfeEventListHandler.onComponentEventBatch(_this.fieldData, _this.presetData, _this.stepId, type, primaryData, isDefault, payLoad, displayType);
            }, 100);
            // for (const event of JSON.parse(JSON.stringify(this.fieldData.event_list))) {
            //     if (event.isDefault === isDefault &&
            //         event.event_name.toLowerCase() === type.toLowerCase() &&
            //         (displayType ? event.display_type.toLowerCase() === displayType.toLowerCase() : true)) {
            //         this.setNextStepId(event);
            //         window['eventElementId'] = this.fieldData.html_id;
            //         if (this.presetData && this.presetData.repeatedBlockFieldId) {
            //             primaryData = {
            //                 ...primaryData,
            //                 value: {
            //                     ...primaryData.value,
            //                     linkedBlockId: this.presetData.linkedBlockId,
            //                     position: this.presetData.position,
            //                     parentPosition: this.presetData.parentPosition,
            //                     isRepeatable: true
            //                 }
            //             };
            //         }
            //         this.wfeEventListHandler.switchEventDisplayType(event, this.fieldData.event_list, primaryData, payLoad);
            //     }
            // }
        }
    }
    /**
     * function to set next step id for NavigatetoNextPage in onResponse
     * @param event the event
     */
    // setNextStepId(event) {
    //     for (const eventParam of event.event_params) {
    //         if (eventParam.invoke_event_config && eventParam.invoke_event_config.callback_config && eventParam.invoke_event_config.callback_config.onResponse) {
    //             for (const onRes of eventParam.invoke_event_config.callback_config.onResponse) {
    //                 if (onRes.NavigatetoNextPage) {
    //                     onRes.NavigatetoNextPage = this.wfeStepLoaderService.getNextStepInCurrentSequence(this.stepId);
    //                 }
    //             }
    //         }
    //     }
    // }
    dependencyHandler = async (type, payLoad = {}) => {
        if (type == 'onLoad') {
            if (this.fieldData.possible_value_type === 'ExternalApi') {
                const apiType = localStorage.getItem('API_TYPE');
                switch (apiType) {
                    case 'ESB':
                        this._ceeApiService.ESBRequestHandler(this.fieldData.possible_value_api).subscribe(res => {
                            if (res['status'] === 'ok') {
                                const appBaseResult = window.sessionStorage.getItem('ApplicationBaseResultPath');
                                const apiResponse = JSON.parse(res['api_response'])[appBaseResult];
                                this.sharedEventsService.emitApiSuccessResponse.emit(apiResponse);
                            }
                            else {
                                this.sharedEventsService.emitApiErrorResponse.emit(res);
                            }
                        });
                        break;
                    case 'INTERNAL':
                    case 'EXTERNAL':
                        this.externalRequestResponseUtil.prepareObjectToBeSent(this.fieldData.possible_value_api, apiType === 'INTERNAL' ? 'internal' : '');
                        break;
                    default:
                        let appData = [];
                        let apiData = [];
                        // store the appData
                        this.appDataService.getAllAppData().subscribe(res => {
                            // console.log('appData', res);
                            if (this.isSingleApiKey) {
                                appData = res;
                            }
                            else {
                                let finalArr = [];
                                for (const data of res) {
                                    let obj = {};
                                    const arr = [];
                                    for (const requestKey of data['requestApiKey']) {
                                        obj = data;
                                        obj = { ...obj, apiKey: requestKey };
                                        arr.push(obj);
                                    }
                                    finalArr = [...finalArr, ...arr];
                                }
                                appData = finalArr;
                            }
                            // console.log('app Data', appData);
                        });
                        // store the apiData
                        this.apiDataService.getAllApiData().subscribe(res => {
                            // console.log('apiData', res);
                            apiData = res;
                        });
                        const eventHandlerEmitterObject = {
                            handler: this.fieldData.possible_value_api,
                            apiKey: this.fieldData.api_key,
                            appData,
                            apiData
                        };
                        this.sharedEventsService.eventHandlerEmitter.emit(eventHandlerEmitterObject);
                        break;
                }
                this.isOnSelect = true;
            }
        }
        if (type == 'onSelect') {
            // trigger event list
            this.onComponentEvent(type, {}, true, payLoad);
        }
    };
    comparisonError() {
        // Show Comparison Error Messages
        if (this.additionalParameter['ComparisonField']) {
            if (this.fieldValue !== this.appDataService.getFieldDataByFieldId(this.commonUtil.getID(this.additionalParameter['ComparisonField']))) {
                const errorCode = this.commonUtil.getValue(this.additionalParameter['ComparisonField']).trim();
                if (this.wfeStepLoaderService.messagesDataMap[errorCode]) {
                    this.showComparisonError[String(this.appData.id)] = this.wfeStepLoaderService.messagesDataMap[errorCode];
                }
            }
            else {
                if (this.showComparisonError[String(this.appData.id)]) {
                    delete this.showComparisonError[String(this.appData.id)];
                }
            }
        }
    }
    isHTML(value) {
        const regex = /(<([^>]+)>)/ig;
        return regex.test(value);
    }
    setCharacterCountMessage() {
        if (this.additionalParameter['DisplayCharacterCount']) {
            this.characterCount.display = true;
            if (this.additionalParameter['DisplayCharacterCount'].split('|')[0].trim()) {
                if (this.wfeStepLoaderService.messagesDataMap[this.additionalParameter['DisplayCharacterCount'].split('|')[0].trim()]) {
                    this.characterCount.type = this.additionalParameter['DisplayCharacterCount'].split('|')[1].trim();
                    this.characterCountMessageData.left =
                        this.wfeStepLoaderService.messagesDataMap[this.additionalParameter['DisplayCharacterCount'].split('|')[0].trim()];
                }
                else {
                    this.characterCount.type = this.additionalParameter['DisplayCharacterCount'].split('|')[0].trim();
                }
            }
            if (this.additionalParameter['DisplayCharacterCount'].split('|').length > 1 && this.additionalParameter['DisplayCharacterCount'].split('|')[1].trim()) {
                if (this.wfeStepLoaderService.messagesDataMap[this.additionalParameter['DisplayCharacterCount'].split('|')[1].trim()]) {
                    this.characterCount.type = this.additionalParameter['DisplayCharacterCount'].split('|')[0].trim();
                    this.characterCountMessageData.right =
                        this.wfeStepLoaderService.messagesDataMap[this.additionalParameter['DisplayCharacterCount'].split('|')[1].trim()];
                }
                else {
                    this.characterCount.type = this.additionalParameter['DisplayCharacterCount'].split('|')[1].trim();
                }
            }
        }
    }
    openDialog(data, id = '') {
        let dialogRef;
        if (id) {
            dialogRef = this.dialog.open(AlertModalComponent, {
                data: {
                    message: data
                },
                id
            });
        }
        else {
            dialogRef = this.dialog.open(AlertModalComponent, {
                data: {
                    message: data
                }
            });
        }
        dialogRef.afterClosed().subscribe(result => {
            // console.log('The dialog ' + data + ' was closed.');
        });
    }
    openSanckBar(message, messageCode = '') {
        this.snackBar.open(message, 'OK', {
            verticalPosition: 'top',
            panelClass: messageCode ?
                ['mat-toolbar', 'mat-primary', 'error-popup', `error-popup-${messageCode}`] :
                ['mat-toolbar', 'mat-primary', 'error-popup'],
            duration: localStorage.getItem('messageTimeOut') ? Number(localStorage.getItem('messageTimeOut')) : null
        });
    }
    // returns the array of the data
    checkForArray(array, key) {
        const ids = [];
        key = key.substr(1);
        for (const data of array) {
            ids.push(this.checkForObject(data, key));
        }
        return (ids);
    }
    checkForObject(data, key) {
        if (key.indexOf('.') >= 0) {
            const objectKeys = key.split('.');
            for (const singleKey of objectKeys) {
                objectKeys.splice(objectKeys.indexOf(singleKey), 1);
                this.checkForObject(data[singleKey], objectKeys.length > 0 ? objectKeys.join('.') : objectKeys[0]);
            }
        }
        else {
            return data[key] ? data[key] : data;
        }
    }
    getConcatenation = () => {
        if (this.isSingleApiKey) {
            if (this.fieldData.additional_parameters
                && this.fieldData.additional_parameters.length > 0) {
                for (const values of this.fieldData.additional_parameters) {
                    if (values.parameter_type === 'ConcatFields') {
                        const concatenatedValues = values.value.split('+');
                        this.concatData({ fid: this.fieldData.unique_id, concatValues: concatenatedValues });
                    }
                }
            }
        }
        else {
            if (this.appData.responseApiKey[0] && this.appData.responseApiKey[0].includes('+')) {
                const concatenatedValues = this.appData.responseApiKey[0].split('+').map(str => str.trim());
                this.concatData({ fid: this.fieldData.unique_id, concatValues: concatenatedValues });
            }
        }
    };
    setFieldValue() {
        let value = '';
        // TODO: check functionality
        if (this.fieldData.response_api_key && this.fieldData.response_api_key.includes('|')) {
            // set concatenated field values
            const apiKeys = this.apiKeyUtil.getMultipleApiKeys(this.apiKeyUtil.getConcatenatedApiKeys(this.fieldData.response_api_key));
            for (const key of apiKeys) {
                if (key.includes('+')) {
                    let val;
                    const keys = key.split('+');
                    for (const singleKey of keys) {
                        const apiCallbackData = this.returnValueFromCallback(singleKey);
                        if (apiCallbackData !== null && apiCallbackData !== undefined) {
                            val = keys.indexOf(singleKey) === 0 ? apiCallbackData : val + ' ' + apiCallbackData;
                        }
                    }
                    value = val;
                }
                else {
                    const apiCallbackData = this.returnValueFromCallback(key);
                    if (apiCallbackData !== null && apiCallbackData !== undefined) {
                        value = apiCallbackData;
                    }
                }
            }
        }
        else {
            value = this.returnValueFromCallback(this.fieldData.response_api_key);
        }
        return value;
    }
    /**
     * function that returns value from set api callback util
     * @param keyName the api key name
     */
    returnValueFromCallback(keyName) {
        const handlerValue = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(keyName)) ?
            this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(keyName)).value : {};
        return this.setApiCallBackDataUtil.setApiCallBackData(keyName, handlerValue);
    }
    returnMessageData(messageCode) {
        if (messageCode) {
            if (this.wfeStepLoaderService.messagesDataMap[messageCode]) {
                return this.wfeStepLoaderService.messagesDataMap[messageCode];
            }
        }
    }
    /**
     * open popup or snackbar based on the configuration
     * @param fieldId unique id of the field
     * @param value the current value of the field
     */
    setModalorSanckBarMessage(fieldId, value, messageType = '') {
        if (this.fieldData.unique_id === fieldId) {
            if (this.modalMessages.length > 0) {
                this.modalMessages.forEach(message => {
                    switch (message.type.toLowerCase()) {
                        case 'regex':
                            const regex = value.match(new RegExp(this.fieldData.validation_regex));
                            if (regex == null) {
                                this.dialog.closeAll();
                                this.openDialog(this.returnMessageData(message.code).message_text, message.code);
                            }
                            break;
                        case 'mandatory':
                            if (this.isMandatory && value === '') {
                                this.dialog.closeAll();
                                this.openDialog(this.returnMessageData(message.code).message_text, message.code);
                            }
                            break;
                        case 'individual_file_size':
                        case 'total_file_size':
                        case 'file_type':
                            if (messageType.toLowerCase() === message.type.toLowerCase()) {
                                this.dialog.closeAll();
                                this.openDialog(this.returnMessageData(message.code).message_text, message.code);
                            }
                            break;
                        default:
                            break;
                    }
                });
            }
            if (this.snackBarMessages.length > 0) {
                this.snackBarMessages.forEach(message => {
                    switch (message.type.toLowerCase()) {
                        case 'regex':
                            const regex = value.match(new RegExp(this.fieldData.validation_regex));
                            if (regex == null) {
                                this.snackBar.dismiss();
                                this.openSanckBar(this.returnMessageData(message.code).message_text, message.code);
                            }
                            break;
                        case 'mandatory':
                            if (this.isMandatory && value === '') {
                                this.snackBar.dismiss();
                                this.openSanckBar(this.returnMessageData(message.code).message_text, message.code);
                            }
                            break;
                        case 'individual_file_size':
                        case 'total_file_size':
                        case 'file_type':
                        case 'invalid_file_extension':
                            if (messageType.toLowerCase() === message.type.toLowerCase()) {
                                this.snackBar.dismiss();
                                this.openSanckBar(this.returnMessageData(message.code).message_text, message.code);
                            }
                            break;
                        default:
                            break;
                    }
                });
            }
        }
    }
    setConditions(childConditions, type) {
        let check = this.returnUniqueId() ? true : false;
        if (childConditions && childConditions.exceptionFields && childConditions.exceptionFields.length > 0 && childConditions.exceptionFields.includes(this.returnUniqueId())) {
            check = false;
        }
        if (check && childConditions && childConditions.isActive) {
            if (childConditions.fields.length > 0 && childConditions.fields.includes(this.returnUniqueId())) {
                this[type] = childConditions.value;
                this.conditionObj[type] = true;
            }
            else if (childConditions.overrideAll) {
                // console.log(type, obj);
                this[type] = childConditions.value;
                this.conditionObj[type] = true;
            }
            else {
                this.conditionObj[type] = false; // The child conditions will work
            }
        }
    }
    /**
     * get associated fields from the conditional mandatory, display, editable
     */
    getAssociatedFields() {
        const dependentFields = [];
        if (this.fieldData.editable_condition.condition) {
            for (const condition of this.fieldData.editable_condition.condition) {
                dependentFields.push(condition.field);
            }
        }
        if (this.fieldData.display_condition.condition) {
            for (const condition of this.fieldData.display_condition.condition) {
                dependentFields.push(condition.field);
            }
        }
        if (this.fieldData.mandatory_condition.condition) {
            for (const condition of this.fieldData.mandatory_condition.condition) {
                dependentFields.push(condition.field);
            }
        }
        return [...new Set(dependentFields)];
    }
    /**
     * function that returns the unique id
     */
    returnUniqueId() {
        const id = String(this.appData.id);
        if (id.split('$').length === 3) {
            return id.split('$')[1];
        }
        return id;
    }
    /**
     * function that set primary key value that comes from cell
     * and returns the cellData
     * @param primaryKeyIndex an object
     */
    setPrimaryKey(primaryKeyIndex) {
        const cellData = {
            type: '',
            stepId: this.stepId,
            value: {}
        };
        if (primaryKeyIndex) {
            if (primaryKeyIndex.value) {
                const apiData = {
                    id: primaryKeyIndex.name,
                    apiUrl: '',
                    apiKey: primaryKeyIndex.name,
                    value: primaryKeyIndex.value
                };
                this.apiDataService.setApiData(Object.assign({}, apiData));
            }
            if (primaryKeyIndex.type && primaryKeyIndex.cellData) {
                cellData.type = primaryKeyIndex.type;
                cellData.value = primaryKeyIndex.cellData;
            }
        }
        return cellData;
    }
    // customValidationCheck(value) {
    //     if (this.customCheck) {
    //         const value
    //         console.log(this.customErrorsValidation.getMessages(this.appData.id, value));
    //     }
    // }
    /**
     * function returns an object with key and value where
     * key is the name of the field/parameter that needs to be
     * changed on language change and value is the data that needs to
     * be set for that param
     * @param value: string the key name that needs to be checked and set
     * @param data: object the current changes field data
     * @param changeMap: object a map that checks which value will change
     * for a specific field
     */
    switchLang(value, data, changeMap) {
        const checkType = value.split('[*]');
        if (data[checkType[0]]) {
            if (checkType[1]) {
                // checking for additional parameter
                data[checkType[0]].forEach((element) => {
                    if (element.parameter_type === checkType[1]) {
                        return { key: changeMap[value], val: element.value };
                    }
                });
            }
            else {
                return { key: changeMap[value], val: checkType[0] };
            }
        }
    }
    /**
     * this function returns the external api option value for picker, menu,
     * @param value the api key from which the value of the picker should come
     * @param data the api data
     */
    getExternalApiOptionValue(value, data) {
        if (value.includes('||')) {
            const valueApikeys = value.split('||').map(str => str.trim());
            var valueData = this.setApiCallBackDataUtil.setApiCallBackData(valueApikeys[0], data);
            var labelData = this.setApiCallBackDataUtil.setApiCallBackData(valueApikeys[1], data);
            // console.log("valueData: ",valueData);
            // console.log("labelData: ",labelData);
            if (value.indexOf('[*]') > -1) {
                const handlerValueData = this.setApiCallBackDataUtil.setApiCallBackData(valueApikeys[0].split('[*]')[0], data);
                const handlerLabelData = this.setApiCallBackDataUtil.setApiCallBackData(valueApikeys[1].split('[*]')[0], data);
                // console.log("handlerValueData: ",handlerValueData);
                // console.log("handlerLabelData: ",handlerLabelData);
                if (Array.isArray(handlerValueData) && handlerValueData.length == 0) {
                    valueData = [];
                }
                if (Array.isArray(handlerLabelData) && handlerLabelData.length == 0) {
                    labelData = [];
                }
            }
            if (Array.isArray(valueData) && Array.isArray(labelData) && valueData.length === labelData.length) {
                const optionValues = [];
                for (let v = 0; v < valueData.length; v++) {
                    optionValues.push(valueData[v] + '||' + labelData[v]);
                }
                // console.log("optionValues: ",optionValues);
                return optionValues;
            }
            else {
                return null;
            }
        }
        else {
            return this.setApiCallBackDataUtil.setApiCallBackData(value, data);
        }
    }
    // all getter and setters go here
    get singleCondition() {
        return localStorage.getItem('isSingleCondition') === 'true' ? true : false;
    }
    get storeLabels() {
        return localStorage.getItem('storeLabels') === 'true' ? true : false;
    }
    get isSingleApiKey() {
        return localStorage.getItem('singleApiKey') === 'true' ? true : false;
    }
    get hashApiKey() {
        return localStorage.getItem('hash_api_key') === 'true' ? true : false;
    }
    get hasUnsavedData() {
        return localStorage.getItem('has_unsaved_data') === 'true' ? true : false;
    }
    get modalOnPageLeave() {
        return localStorage.getItem('modal_on_page_leave') ? localStorage.getItem('modal_on_page_leave') : false;
    }
    get customCheck() {
        return localStorage.getItem('customErrorSteps') && localStorage.getItem('customErrorSteps').includes(this.stepId);
    }
    static ɵfac = function BaseView_Factory(t) { return new (t || BaseView)(i0.ɵɵdirectiveInject(UserDataHandlerService), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(CEEInternalEmitterService), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(WfeStepLoaderService), i0.ɵɵdirectiveInject(i7$1.MatDialog), i0.ɵɵdirectiveInject(i8.MatSnackBar), i0.ɵɵdirectiveInject(i9.HttpClient), i0.ɵɵdirectiveInject(CeeApiService), i0.ɵɵdirectiveInject(i11.Router), i0.ɵɵdirectiveInject(FileUploadService)); };
    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: BaseView, inputs: { rootData: "rootData" } });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(BaseView, [{
        type: Directive
    }], () => [{ type: UserDataHandlerService }, { type: SharedEventsServiceService }, { type: CEEInternalEmitterService }, { type: AppDataService }, { type: ApiDataService }, { type: WfeStepLoaderService }, { type: i7$1.MatDialog }, { type: i8.MatSnackBar }, { type: i9.HttpClient }, { type: CeeApiService }, { type: i11.Router }, { type: FileUploadService }], { rootData: [{
            type: Input
        }] }); })();

class DebounceClickDirective {
    debounceClick = new EventEmitter();
    debouncedClick = debounce((event) => {
        this.debounceClick.emit(event);
    }, 500, { leading: true, trailing: false });
    static ɵfac = function DebounceClickDirective_Factory(t) { return new (t || DebounceClickDirective)(); };
    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: DebounceClickDirective, selectors: [["", "appDebounceClick", ""]], hostBindings: function DebounceClickDirective_HostBindings(rf, ctx) { if (rf & 1) {
            i0.ɵɵlistener("click", function DebounceClickDirective_click_HostBindingHandler($event) { return ctx.debouncedClick($event); });
        } }, outputs: { debounceClick: "debounceClick" }, standalone: true });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DebounceClickDirective, [{
        type: Directive,
        args: [{
                selector: '[appDebounceClick]',
                standalone: true
            }]
    }], null, { debounceClick: [{
            type: Output
        }], debouncedClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

var TooltipPosition;
(function (TooltipPosition) {
    TooltipPosition["ABOVE"] = "above";
    TooltipPosition["BELOW"] = "below";
    TooltipPosition["LEFT"] = "left";
    TooltipPosition["RIGHT"] = "right";
    TooltipPosition["DYNAMIC"] = "dynamic";
    TooltipPosition["DEFAULT"] = "below";
})(TooltipPosition || (TooltipPosition = {}));
var TooltipTheme;
(function (TooltipTheme) {
    TooltipTheme["DARK"] = "dark";
    TooltipTheme["LIGHT"] = "light";
    TooltipTheme["DEFAULT"] = "dark";
})(TooltipTheme || (TooltipTheme = {}));

const _c0$6 = (a0, a1) => [a0, a1];
function TooltipComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 2);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("left", ctx_r0.left + "px")("top", ctx_r0.top + "px");
    i0.ɵɵclassProp("tooltip--visible", ctx_r0.visible);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(8, _c0$6, "tooltip--" + ctx_r0.position, "tooltip--" + ctx_r0.theme));
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1(" ", ctx_r0.tooltip, "\n");
} }
function TooltipComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 3);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("left", ctx_r0.left + "px")("top", ctx_r0.top + "px");
    i0.ɵɵclassProp("tooltip--visible", ctx_r0.visible);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(8, _c0$6, "tooltip--" + ctx_r0.position, "tooltip--" + ctx_r0.theme))("innerHTML", ctx_r0.tooltip, i0.ɵɵsanitizeHtml);
} }
class TooltipComponent {
    position = TooltipPosition.DEFAULT;
    theme = TooltipTheme.DEFAULT;
    tooltip = '';
    left = 0;
    top = 0;
    visible = false;
    constructor() {
    }
    ngOnInit() {
    }
    isHTML(value) {
        const regex = /(<([^>]+)>)/ig;
        return regex.test(value);
    }
    static ɵfac = function TooltipComponent_Factory(t) { return new (t || TooltipComponent)(); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TooltipComponent, selectors: [["tooltip"]], decls: 2, vars: 2, consts: [["class", "tooltip", 3, "ngClass", "tooltip--visible", "left", "top", 4, "ngIf"], ["class", "tooltip", 3, "ngClass", "tooltip--visible", "left", "top", "innerHTML", 4, "ngIf"], [1, "tooltip", 3, "ngClass"], [1, "tooltip", 3, "ngClass", "innerHTML"]], template: function TooltipComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, TooltipComponent_div_0_Template, 2, 11, "div", 0)(1, TooltipComponent_div_1_Template, 1, 11, "div", 1);
        } if (rf & 2) {
            i0.ɵɵproperty("ngIf", !ctx.isHTML(ctx.tooltip));
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.isHTML(ctx.tooltip));
        } }, dependencies: [i13.NgClass, i13.NgIf], styles: [".tooltip[_ngcontent-%COMP%]{position:fixed;background-color:#000;border-radius:4px;color:#fff;font-family:Arial,sans-serif;padding:3px 6px;font-size:5px;opacity:0}.tooltip[_ngcontent-%COMP%]:before{content:\"\";width:0;height:0;position:absolute}.tooltip--visible[_ngcontent-%COMP%]{opacity:1;font-size:10px;transition:all .3s}.tooltip--light[_ngcontent-%COMP%]{background-color:#fff;color:#000}.tooltip--light[_ngcontent-%COMP%]:before{border:5px solid white}.tooltip--dark[_ngcontent-%COMP%]{background-color:#4b4b4b;color:#fff}.tooltip--dark[_ngcontent-%COMP%]:before{border:5px solid #4b4b4b}.tooltip--below[_ngcontent-%COMP%]{transform:translate(-50%);margin-top:7px}.tooltip--below[_ngcontent-%COMP%]:before{border-left-color:transparent;border-right-color:transparent;border-top:none;left:calc(50% - 5px);top:-5px}.tooltip--above[_ngcontent-%COMP%]{transform:translate(-50%,-100%);margin-bottom:7px}.tooltip--above[_ngcontent-%COMP%]:before{border-left-color:transparent;border-right-color:transparent;border-bottom:none;left:calc(50% - 5px);bottom:-5px}.tooltip--left[_ngcontent-%COMP%]{transform:translate(calc(-100% - 7px),-50%)}.tooltip--left[_ngcontent-%COMP%]:before{border-top-color:transparent;border-bottom-color:transparent;border-right:none;right:-5px;top:calc(50% - 5px)}.tooltip--right[_ngcontent-%COMP%]{transform:translateY(-50%);margin-left:7px}.tooltip--right[_ngcontent-%COMP%]:before{border-top-color:transparent;border-bottom-color:transparent;border-left:none;left:-5px;top:calc(50% - 5px)}.tooltip--dynamic[_ngcontent-%COMP%]{margin-left:20px}.tooltip--dynamic[_ngcontent-%COMP%]:before{display:none}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TooltipComponent, [{
        type: Component,
        args: [{ selector: 'tooltip', template: "<div *ngIf=\"!isHTML(tooltip)\" class=\"tooltip\" [ngClass]=\"['tooltip--'+position, 'tooltip--'+theme]\"\r\n  [class.tooltip--visible]=\"visible\" [style.left]=\"left + 'px'\" [style.top]=\"top + 'px'\">\r\n  {{tooltip}}\r\n</div>\r\n<div *ngIf=\"isHTML(tooltip)\" class=\"tooltip\" [ngClass]=\"['tooltip--'+position, 'tooltip--'+theme]\"\r\n  [class.tooltip--visible]=\"visible\" [style.left]=\"left + 'px'\" [style.top]=\"top + 'px'\" [innerHTML]=\"tooltip\">\r\n</div>", styles: [".tooltip{position:fixed;background-color:#000;border-radius:4px;color:#fff;font-family:Arial,sans-serif;padding:3px 6px;font-size:5px;opacity:0}.tooltip:before{content:\"\";width:0;height:0;position:absolute}.tooltip--visible{opacity:1;font-size:10px;transition:all .3s}.tooltip--light{background-color:#fff;color:#000}.tooltip--light:before{border:5px solid white}.tooltip--dark{background-color:#4b4b4b;color:#fff}.tooltip--dark:before{border:5px solid #4b4b4b}.tooltip--below{transform:translate(-50%);margin-top:7px}.tooltip--below:before{border-left-color:transparent;border-right-color:transparent;border-top:none;left:calc(50% - 5px);top:-5px}.tooltip--above{transform:translate(-50%,-100%);margin-bottom:7px}.tooltip--above:before{border-left-color:transparent;border-right-color:transparent;border-bottom:none;left:calc(50% - 5px);bottom:-5px}.tooltip--left{transform:translate(calc(-100% - 7px),-50%)}.tooltip--left:before{border-top-color:transparent;border-bottom-color:transparent;border-right:none;right:-5px;top:calc(50% - 5px)}.tooltip--right{transform:translateY(-50%);margin-left:7px}.tooltip--right:before{border-top-color:transparent;border-bottom-color:transparent;border-left:none;left:-5px;top:calc(50% - 5px)}.tooltip--dynamic{margin-left:20px}.tooltip--dynamic:before{display:none}\n"] }]
    }], () => [], null); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(TooltipComponent, { className: "TooltipComponent", filePath: "lib\\directives\\tooltip\\tooltip.component.ts", lineNumber: 9 }); })();

class TooltipDirective {
    elementRef;
    appRef;
    componentFactoryResolver;
    injector;
    tooltip = '';
    position = TooltipPosition.DEFAULT;
    theme = TooltipTheme.DEFAULT;
    showDelay = 0;
    hideDelay = 0;
    componentRef = null;
    showTimeout;
    hideTimeout;
    touchTimeout;
    constructor(elementRef, appRef, componentFactoryResolver, injector) {
        this.elementRef = elementRef;
        this.appRef = appRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    onMouseEnter() {
        this.initializeTooltip();
    }
    onMouseLeave() {
        this.setHideTooltipTimeout();
    }
    onMouseMove($event) {
        if (this.componentRef !== null && this.position === TooltipPosition.DYNAMIC) {
            this.componentRef.instance.left = $event.clientX;
            this.componentRef.instance.top = $event.clientY;
            this.componentRef.instance.tooltip = this.tooltip;
        }
    }
    onTouchStart($event) {
        $event.preventDefault();
        window.clearTimeout(this.touchTimeout);
        this.touchTimeout = window.setTimeout(this.initializeTooltip.bind(this), 500);
    }
    onTouchEnd() {
        window.clearTimeout(this.touchTimeout);
        this.setHideTooltipTimeout();
    }
    initializeTooltip() {
        if (this.componentRef === null) {
            window.clearInterval(this.hideDelay);
            const componentFactory = this.componentFactoryResolver.resolveComponentFactory(TooltipComponent);
            this.componentRef = componentFactory.create(this.injector);
            this.appRef.attachView(this.componentRef.hostView);
            const [tooltipDOMElement] = this.componentRef.hostView.rootNodes;
            this.setTooltipComponentProperties();
            document.body.appendChild(tooltipDOMElement);
            this.showTimeout = window.setTimeout(this.showTooltip.bind(this), this.showDelay);
        }
    }
    setTooltipComponentProperties() {
        if (this.componentRef !== null) {
            this.componentRef.instance.tooltip = this.tooltip;
            this.componentRef.instance.position = this.position;
            this.componentRef.instance.theme = this.theme;
            const { left, right, top, bottom } = this.elementRef.nativeElement.getBoundingClientRect();
            switch (this.position) {
                case TooltipPosition.BELOW: {
                    this.componentRef.instance.left = Math.round((right - left) / 2 + left);
                    this.componentRef.instance.top = Math.round(bottom);
                    break;
                }
                case TooltipPosition.ABOVE: {
                    this.componentRef.instance.left = Math.round((right - left) / 2 + left);
                    this.componentRef.instance.top = Math.round(top);
                    break;
                }
                case TooltipPosition.RIGHT: {
                    this.componentRef.instance.left = Math.round(right);
                    this.componentRef.instance.top = Math.round(top + (bottom - top) / 2);
                    break;
                }
                case TooltipPosition.LEFT: {
                    this.componentRef.instance.left = Math.round(left);
                    this.componentRef.instance.top = Math.round(top + (bottom - top) / 2);
                    break;
                }
                default: {
                    break;
                }
            }
        }
    }
    showTooltip() {
        if (this.componentRef !== null) {
            this.componentRef.instance.visible = true;
        }
    }
    setHideTooltipTimeout() {
        this.hideTimeout = window.setTimeout(this.destroy.bind(this), this.hideDelay);
    }
    ngOnDestroy() {
        this.destroy();
    }
    destroy() {
        if (this.componentRef !== null) {
            window.clearInterval(this.showTimeout);
            window.clearInterval(this.hideDelay);
            this.appRef.detachView(this.componentRef.hostView);
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    static ɵfac = function TooltipDirective_Factory(t) { return new (t || TooltipDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Injector)); };
    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TooltipDirective, selectors: [["", "tooltip", ""]], hostBindings: function TooltipDirective_HostBindings(rf, ctx) { if (rf & 1) {
            i0.ɵɵlistener("mouseenter", function TooltipDirective_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function TooltipDirective_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("mousemove", function TooltipDirective_mousemove_HostBindingHandler($event) { return ctx.onMouseMove($event); })("touchstart", function TooltipDirective_touchstart_HostBindingHandler($event) { return ctx.onTouchStart($event); })("touchend", function TooltipDirective_touchend_HostBindingHandler() { return ctx.onTouchEnd(); });
        } }, inputs: { tooltip: "tooltip", position: "position", theme: "theme", showDelay: "showDelay", hideDelay: "hideDelay" } });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TooltipDirective, [{
        type: Directive,
        args: [{
                selector: '[tooltip]'
            }]
    }], () => [{ type: i0.ElementRef }, { type: i0.ApplicationRef }, { type: i0.ComponentFactoryResolver }, { type: i0.Injector }], { tooltip: [{
            type: Input
        }], position: [{
            type: Input
        }], theme: [{
            type: Input
        }], showDelay: [{
            type: Input
        }], hideDelay: [{
            type: Input
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], onMouseMove: [{
            type: HostListener,
            args: ['mousemove', ['$event']]
        }], onTouchStart: [{
            type: HostListener,
            args: ['touchstart', ['$event']]
        }], onTouchEnd: [{
            type: HostListener,
            args: ['touchend']
        }] }); })();

class TooltipModule {
    static ɵfac = function TooltipModule_Factory(t) { return new (t || TooltipModule)(); };
    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TooltipModule });
    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [CommonModule] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TooltipModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TooltipComponent,
                    TooltipDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [TooltipDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TooltipModule, { declarations: [TooltipComponent,
        TooltipDirective], imports: [CommonModule], exports: [TooltipDirective] }); })();

const _c0$5 = () => ({ "Submit": "cee-button success", "Button": "cee-button default", "Previous": "cee-button danger", "Next": "cee-button info" });
const _c1$5 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({ "font-family": a0, "font-size": a1, "font-style": a2, "color": a3, "border-color": a4, "height": a5, "width": a6, "background-color": a7 });
function CeeButtonComponent_div_0_button_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 5);
    i0.ɵɵtext(1, "i");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("tooltip", ctx_r1.fieldData.tooltip);
    i0.ɵɵattribute("aria-label", "Tooltip: " + ctx_r1.fieldData.tooltip);
} }
function CeeButtonComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵlistener("contextmenu", function CeeButtonComponent_div_0_Template_div_contextmenu_0_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.onContextMenu($event)); });
    i0.ɵɵelementStart(1, "div", 2)(2, "button", 3);
    i0.ɵɵlistener("click", function CeeButtonComponent_div_0_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.buttonClickListener()); });
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(3, CeeButtonComponent_div_0_button_3_Template, 2, 2, "button", 4);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", ctx_r1.cssClasses);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("name", ctx_r1.fieldData.api_key);
    i0.ɵɵpropertyInterpolate("id", ctx_r1.html_id);
    i0.ɵɵproperty("ngClass", ctx_r1.fieldData.field_style ? ctx_r1.isCustomClass && ctx_r1.fieldData.field_style.custom_class_name ? ctx_r1.fieldData.field_style.custom_class_name : "btn btn-primary" : i0.ɵɵpureFunction0(11, _c0$5)[ctx_r1.fieldData.field_type])("ngStyle", i0.ɵɵpureFunction8(12, _c1$5, ctx_r1.fieldData.field_style.font_name, ctx_r1.fieldData.field_style.font_size, ctx_r1.fieldData.field_style.font_style, ctx_r1.fieldData.field_style.font_color, ctx_r1.fieldData.field_style.border_color, ctx_r1.fieldData.field_style.field_height, ctx_r1.fieldData.field_style.field_width, ctx_r1.fieldData.field_style.background_color))("disabled", !ctx_r1.isEditable || !ctx_r1.validationPassed)("innerHtml", ctx_r1.buttonLabel, i0.ɵɵsanitizeHtml);
    i0.ɵɵattribute("aria-label", ctx_r1.additionalParameter["Aria-Label"] ? ctx_r1.additionalParameter["Aria-Label"] : "Click on " + ctx_r1.fieldData.field_label)("role", ctx_r1.additionalParameter["Aria-Role"] ? ctx_r1.additionalParameter["Aria-Role"] : "button")("tabindex", ctx_r1.tabIndexValue);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.hasTooltip);
} }
/**
 * CeeButtonComponent - Smart Button with Validation Control
 *
 * Enhanced Force Disable Section Parameter Support:
 * The 'Force Disable Section' parameter now supports multiple section IDs
 * separated by pipe (|) character for comprehensive validation control.
 *
 * Examples:
 * - Single section: "17_34596_contact_view"
 * - Multiple sections: "17_34596_contact_view|0_34596_contact_view"
 * - Complex scenarios: "section1|section2|section3"
 *
 * The button will be disabled if ANY of the specified sections have:
 * - Missing mandatory field values
 * - Invalid field values with validation errors
 *
 * @enhanced Multi-section validation support for Force Disable Section parameter
 */
class CeeButtonComponent extends BaseView {
    userDataHandlerService;
    sharedEventsService;
    internalCEEEmitter;
    ceeApiService;
    router;
    sharedEventsServices;
    wfeStepLoaderService;
    appDataService;
    apiDataService;
    dialog;
    snackBar;
    http;
    fileUploadService;
    cdr;
    storageService;
    stepId;
    fieldData;
    primaryKeyIndex;
    keepState = false;
    rowData;
    mandatoryCondition;
    editableCondition;
    visibleCondition;
    buttonLabel = '';
    html_id = '';
    labelEmitter;
    appConfigData = {};
    validationPassed = true;
    sessionKeyUtil;
    $buttonValidationEmitter;
    applicationStateStore;
    checkBlockSection = '';
    fieldLabels = [];
    eventFlag = true;
    pdfUrl = '';
    labelUpdateTimeout;
    validationTimeout;
    buttonListnerTimeout;
    subscriptions = new Subscription();
    constructor(userDataHandlerService, sharedEventsService, internalCEEEmitter, ceeApiService, router, 
    // public ceeInitService: CeeInitServiceService,
    sharedEventsServices, 
    // public ceeLogHandlerService: CeeLogHandlerService,
    wfeStepLoaderService, appDataService, apiDataService, dialog, snackBar, http, fileUploadService, cdr, storageService) {
        super(userDataHandlerService, sharedEventsService, internalCEEEmitter, appDataService, apiDataService, wfeStepLoaderService, dialog, snackBar, http, ceeApiService, router, fileUploadService);
        this.userDataHandlerService = userDataHandlerService;
        this.sharedEventsService = sharedEventsService;
        this.internalCEEEmitter = internalCEEEmitter;
        this.ceeApiService = ceeApiService;
        this.router = router;
        this.sharedEventsServices = sharedEventsServices;
        this.wfeStepLoaderService = wfeStepLoaderService;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.dialog = dialog;
        this.snackBar = snackBar;
        this.http = http;
        this.fileUploadService = fileUploadService;
        this.cdr = cdr;
        this.storageService = storageService;
        this.sessionKeyUtil = new SessionKeyUtil();
    }
    ngAfterViewInit() {
        this.cdr.detectChanges();
    }
    ngAfterContentChecked() {
        this.cdr.detectChanges();
    }
    ngOnInit() {
        this.init(this.stepId, this.fieldData, this.keepState, this.rowData);
        this.buttonLabel = this.fieldData.field_label;
        this.applicationStateStore = new ApplicationStateStoreUtil(this.appDataService);
        this.checkConditionOnInit(this.editableCondition, this.visibleCondition, this.mandatoryCondition);
        localStorage.setItem('isButtonInvokeApi', '0');
    }
    //@HostListener('window:beforeunload')
    ngOnDestroy() {
        // Clear all timeouts
        if (this.validationTimeout) {
            clearTimeout(this.validationTimeout);
            this.validationTimeout = null;
        }
        if (this.labelUpdateTimeout) {
            clearTimeout(this.labelUpdateTimeout);
            this.labelUpdateTimeout = null;
        }
        if (this.buttonListnerTimeout) {
            clearTimeout(this.buttonListnerTimeout);
            this.buttonListnerTimeout = null;
        }
        // Unsubscribe from all subscriptions
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        // Clean up legacy subscription
        this.unsubscribe();
        // Close any open dialogs created by this component
        const htmlId = this.rowData ? this.rowData.html_id : this.fieldData?.html_id;
        if (htmlId) {
            const id = `previewModal-${htmlId.toLowerCase()}`;
            this.dialog.openDialogs.forEach(dialog => {
                if (dialog.id === id) {
                    dialog.close();
                }
            });
        }
        // Clean up DOM references
        if (this.rootData && this.rootData['FieldErrorFunctions'] && this.fieldData && this.fieldData.html_id) {
            delete this.rootData['FieldErrorFunctions'][this.fieldData.html_id];
        }
        // Clear object references
        this.applicationStateStore = null;
        this.rootData = null;
        this.variableObject = null;
        this.appConfigData = null;
        this.fieldLabels = null;
        // Clear localStorage entries if they were set by this component
        localStorage.removeItem('isButtonInvokeApi');
        // Call parent cleanup
        this.onViewUnload();
    }
    unsubscribe() {
        if (this.labelEmitter) {
            this.labelEmitter.unsubscribe();
        }
    }
    onViewDataInit() {
        // For unique html id
        this.html_id = this.fieldData.html_id;
        // console.log("onViewDataInit---", this.html_id);
        // END
        if (this.labelUpdateTimeout) {
            clearTimeout(this.labelUpdateTimeout);
        }
        this.tabIndexValue = this.additionalParameter['TabIndex'];
        if (this.isSingleApiKey) {
            if (this.rowData) {
                if (this.fieldData.api_key !== '') {
                    if (this.rowData.hasOwnProperty('value')) {
                        this.labelUpdateTimeout = setTimeout(() => {
                            this.buttonLabel = this.rowData.value;
                            this.cdr.detectChanges();
                        }, 0);
                    }
                }
            }
            else {
                if (this.fieldValue) {
                    this.labelUpdateTimeout = setTimeout(() => {
                        this.buttonLabel = this.fieldValue;
                        this.cdr.detectChanges();
                    }, 0);
                }
            }
        }
        else {
            if (this.rowData) {
                if (this.fieldData.response_api_key !== '') {
                    if (this.rowData.hasOwnProperty('value')) {
                        this.labelUpdateTimeout = setTimeout(() => {
                            this.buttonLabel = this.rowData.value;
                            this.cdr.detectChanges();
                        }, 0);
                    }
                }
            }
            else {
                if (this.fieldValue) {
                    this.labelUpdateTimeout = setTimeout(() => {
                        this.buttonLabel = this.fieldValue;
                        this.cdr.detectChanges();
                    }, 0);
                }
            }
        }
        if (this.additionalParameter['Force Disable Section']) {
            this.checkBlockSection = this.additionalParameter['Force Disable Section'];
            // ENHANCED: Log multiple section support with proper parsing
            const sectionIds = this.parseSectionIds(this.checkBlockSection);
            // console.log('🔧 Force Disable Section parameter initialized with sections:', sectionIds);
            if (sectionIds.length === 0) {
                console.warn('⚠️ Force Disable Section parameter is empty or invalid');
                return;
            }
            this.subscriptions.add(this.sharedEventsService.buttonValidationEmitter.subscribe(() => {
                if (this.validationTimeout) {
                    clearTimeout(this.validationTimeout);
                }
                this.validationTimeout = setTimeout(() => {
                    // Enhanced validation now supports multiple sections separated by pipe (|)
                    const validationResult = this.checkValidateANDCheckMandatoryFieldsForSection({ mandatory: true, valid: true }, this.checkBlockSection);
                    const isValidationPassed = validationResult.length === 0;
                    console.log('🎯 Force Disable Section validation result:', {
                        sections: sectionIds,
                        validationIssues: validationResult.length,
                        buttonEnabled: isValidationPassed,
                        failedFields: validationResult
                    });
                    this.forceDisableButtonForSection(isValidationPassed);
                }, 0);
            }));
        }
        if (this.additionalParameter['Force Disable Block']) {
            this.checkBlockSection = this.additionalParameter['Force Disable Block'];
            this.subscriptions.add(this.sharedEventsService.buttonValidationEmitter.subscribe(() => {
                if (this.validationTimeout) {
                    clearTimeout(this.validationTimeout);
                }
                this.validationTimeout = setTimeout(() => {
                    this.forceDisableButtonForBlock(this.checkValidateANDCheckMandatoryFieldsForBlock({ mandatory: true, valid: true }, this.checkBlockSection).length === 0);
                }, 0);
            }));
        }
        if (this.additionalParameter['Force Disable']) {
            if (this.additionalParameter['Force Disable'].toLowerCase() !== 'false') {
                if (this.additionalParameter['Force Disable'].toLowerCase() !== 'true') {
                    this.checkBlockSection = this.additionalParameter['Force Disable'];
                }
                this.subscriptions.add(this.sharedEventsService.buttonValidationEmitter.subscribe(() => {
                    if (this.validationTimeout) {
                        clearTimeout(this.validationTimeout);
                    }
                    this.validationTimeout = setTimeout(() => {
                        this.forceDisableButton(this.checkValidateANDCheckMandatoryFields({ mandatory: true, valid: true }, this.checkBlockSection).length === 0);
                    }, 0);
                }));
            }
        }
        // set dynamic label on load
        if (!this.rowData) {
            this.getDynamicLabel();
            this.subscriptions.add(this.sharedEventsService.emitOnDataSetOrUpdated.subscribe((res) => {
                const data = {};
                data[res.apiKey] = res.value;
                this.getDynamicLabel(data);
            }));
        }
        this.sharedEventsService.buttonValidationEmitter.emit();
        this.sharedEventsService.validateButtonForTagEmitter.emit();
    }
    getDynamicLabel(data) {
        if (this.fieldData.field_label && this.fieldData.field_label.includes('((dynamic))') ||
            this.fieldData.field_label_config && this.fieldData.field_label_config.includes('((dynamic))')) {
            this.fieldData = this.setDynamicLabelUtil.getDynamicValue(this.fieldData, data);
            if (this.fieldData.field_label != null) {
                this.fieldLabels = [];
                this.fieldLabels.push(this.fieldData.field_label);
            }
        }
    }
    onAPICallback(data) {
        this.fieldData = this.setDynamicLabelUtil.getDynamicValue(this.fieldData, data);
        if (this.fieldData.field_label != '' && this.fieldValue == '') {
            this.buttonLabel = this.fieldData.field_label;
        }
    }
    onSetSessionData(apiKey, value) {
        super.onSetSessionData(apiKey, value);
    }
    /* Special check for button click */
    buttonClickListener() {
        // console.log(" this.rowData--", this.rowData)
        // this.ceeLogHandlerService.d('Button Click', btnLabel + ' ' + btnType + ' ' + btnEvent);
        if (this.rowData) {
            this.buttonListnerTimeout = setTimeout(() => this.listener(), 0);
        }
        else {
            this.listener();
        }
    }
    listener() {
        switch (this.fieldData.field_type) {
            case 'Button':
                this.buttonClick();
                break;
            case 'Next':
                this.nextClick();
                break;
            case 'Previous':
                this.previousClick();
                break;
            case 'Submit':
                this.submitClick();
                break;
            default:
                this.buttonClick();
                break;
        }
    }
    concatData() { }
    buttonClick() {
        this.returnMandatoryCheck();
    }
    nextClick() {
        this.returnMandatoryCheck('next');
    }
    previousClick() {
        this.returnMandatoryCheck('previous');
    }
    submitClick() {
        this.returnMandatoryCheck('submit');
    }
    executeEvent(moveTo) {
        let eHandler;
        let flag = false;
        //check InvokeAPI exist or not .
        for (const event of this.fieldData.event_list) {
            if (event.isDefault) {
                for (const eventParam of event.event_params) {
                    if (eventParam && eventParam.event_config && eventParam.event_config.display_step
                        && (eventParam.event_config.display_step === 'InvokeAPI' || eventParam.event_config.display_step === 'stepRedirection')) {
                        eHandler = eventParam.event_handler;
                        flag = true;
                        if (!this.additionalParameter['IS_CONFIRMATION_BOX_SHOW'] ||
                            (this.additionalParameter['IS_CONFIRMATION_BOX_SHOW'] && this.additionalParameter['IS_CONFIRMATION_BOX_SHOW'].toLowerCase() != 'false')) {
                            const isOpenPopup = this.storageService.getFieldData('CEE_CONFIRM_MODAL_ON_CRUD');
                            const isDrawrOpen = localStorage.getItem('isDrawerOpen') || '0';
                            if (isOpenPopup === '1' && isDrawrOpen === '0' &&
                                ['save', 'submit', 'delete', 'cancel'].some(word => this.buttonLabel?.toLowerCase().includes(word))) {
                                localStorage.setItem('isButtonInvokeApi', '1');
                                localStorage.setItem('buttonText', this.buttonLabel);
                            }
                        }
                    }
                }
            }
        }
        if (this.eventFlag && flag) {
            this.eventFlag = false;
            this.subscriptions.add(this.sharedEventsServices.eventConditionalFailureSubscriber.subscribe((res) => {
                if (res.event_handler === eHandler) {
                    this.eventFlag = true;
                }
                if (res.chk === false) {
                    this.eventFlag = true;
                }
            }));
            this.subscriptions.add(this.sharedEventsServices.eventResponseSubscriber.subscribe((res) => {
                if (res.handler === eHandler) {
                    this.eventFlag = true;
                }
            }));
            this.subscriptions.add(this.sharedEventsServices.emitApiSuccessResponse.subscribe((res) => {
                if (res.handler_name === eHandler) {
                    this.eventFlag = true;
                }
            }));
            this.subscriptions.add(this.sharedEventsService.emitApiSuccessResponse.pipe(take(1)).subscribe(res => {
                let data;
                if (Array.isArray(res)) {
                    data = res[0];
                }
                else {
                    data = res;
                }
                const actionResponseParam = this.fieldData.additional_parameters.find(param => param.parameter_type === 'Action_Response_Key');
                const actionTypeParam = this.fieldData.additional_parameters.find(param => param.parameter_type === 'Action_Type');
                const actionResponseValue = actionResponseParam?.value;
                const actionTypeParamValue = actionTypeParam?.value;
                if (actionResponseValue && actionResponseValue.includes(data.handler_name)) {
                    const apiData = this.apiDataService.getApiDataByHandler(data.handler_name);
                    this.pdfUrl = apiData ? apiData.value[actionResponseValue] : '';
                    if (actionTypeParamValue == "downloadpdf") {
                        this.downloadPdf(this.pdfUrl);
                    }
                    if (actionTypeParamValue === 'previewpdf') {
                        this.openPdfPreviewFromUrl(this.pdfUrl);
                    }
                }
            }));
        }
        else if (!this.eventFlag) {
            return;
        }
        const ModalOnPageLeave = this.additionalParameter['ModalOnPageLeave'] ? this.additionalParameter['ModalOnPageLeave'] : null;
        const primaryData = this.setPrimaryKey(this.primaryKeyIndex);
        const fData = Object.assign({}, this.fieldData);
        fData.event_list = fData.event_list ? fData.event_list.map((event) => {
            return {
                ...event,
                event_params: event.event_params.map((i) => {
                    return {
                        ...i,
                        ModalOnPageLeave
                    };
                })
            };
        }) : [];
        this.fieldData = fData;
        if (moveTo === '') {
            this.onComponentEvent('OnClick', primaryData);
        }
        else {
            // set progress bar step status
            this.wfeStepLoaderService.loaderService.skipLoading = true;
            this.setProgressBarStepStatus().then(() => {
                this.wfeStepLoaderService.loaderService.skipLoading = false;
                this.onComponentEvent('OnClick', primaryData);
                /* const navigateStepName = localStorage.getItem('navigateStepName') === 'true' ? true : false;
                const routeMap = JSON.parse(sessionStorage.getItem('CEE_ROUTE_MAP')); */
                if (moveTo === 'next') {
                    this.wfeEventListHandler.redirectTo(this.wfeStepLoaderService.getNextStepInCurrentSequence(this.stepId), ModalOnPageLeave);
                }
                else if (moveTo === 'previous') {
                    this.wfeEventListHandler.redirectTo(this.wfeStepLoaderService.getPreviousStepInCurrentSequence(this.stepId), ModalOnPageLeave);
                }
            });
        }
    }
    setProgressBarStepStatus() {
        const complete = this.checkValidateANDCheckMandatoryFields({ mandatory: true, valid: true }).length === 0;
        const seq = this.wfeStepLoaderService.getWorkflowSequenceIndexFromStep(this.stepId);
        if (seq) {
            const progressBar = this.wfeStepLoaderService.progressBarMap[seq.sequence];
            if (progressBar && progressBar['progress']) {
                complete ?
                    this.applicationStateStore.setComplete(progressBar['progress'].progress_bar_id, this.stepId) :
                    this.applicationStateStore.setIncomplete(progressBar['progress'].progress_bar_id, this.stepId);
            }
        }
        return new Promise(resolve => {
            this.setNextDependentProgressBarStepStatus(this.stepId, resolve);
        });
    }
    setNextDependentProgressBarStepStatus(stepId, resolve) {
        const currStep = this.wfeStepLoaderService.getNextStepInCurrentSequence(stepId);
        if (!currStep) {
            resolve();
        }
        else {
            this.subscriptions.add(this.wfeStepLoaderService.loadStepById(currStep).subscribe((currStepData) => {
                if (currStepData && currStepData.conditional && currStepData.dependency_condition.query) {
                    const dependencyCondition = this.conditionalUtil.checkStepDependency(currStepData.dependency_condition);
                    if (!dependencyCondition) {
                        // set the current step as completed
                        const progressBar = this.wfeStepLoaderService.progressBarMap[this.wfeStepLoaderService.getWorkflowSequenceIndexFromStep(currStep).sequence];
                        if (progressBar && progressBar['progress']) {
                            this.applicationStateStore.setComplete(progressBar['progress'].progress_bar_id, currStep);
                        }
                        this.setNextDependentProgressBarStepStatus(currStep, resolve);
                    }
                    else {
                        resolve();
                    }
                }
                else {
                    resolve();
                }
            }));
        }
    }
    returnMandatoryCheck(moveTo = '') {
        // TODO: Mandatory Check for Repeatable Block Needs to be done
        let mandatorySatisfied;
        if ((this.additionalParameter['MandatoryCheck'] &&
            this.additionalParameter['MandatoryCheck'].toLowerCase() === 'true') ||
            (this.additionalParameter['ValidationCheck'] &&
                this.additionalParameter['ValidationCheck'].toLowerCase() === 'true')) {
            mandatorySatisfied = this.checkValidateANDCheckMandatoryFields({
                mandatory: (this.additionalParameter['MandatoryCheck'] &&
                    this.additionalParameter['MandatoryCheck'].toLowerCase() === 'true'),
                valid: (this.additionalParameter['ValidationCheck'] &&
                    this.additionalParameter['ValidationCheck'].toLowerCase() === 'true')
            });
            this.forceDisableButton(mandatorySatisfied.length === 0);
            if (mandatorySatisfied.length === 0) {
                this.executeEvent(moveTo);
                let url = '';
                if (this.rowData && this.rowData.hasOwnProperty('value')) {
                    url = this.rowData.data[this.additionalParameter['Action_Key']];
                }
                else {
                    const apiData = this.apiDataService.getApiDataByApiKey(this.additionalParameter['Action_Key']);
                    url = apiData ? apiData.value : '';
                }
                if (!this.additionalParameter['Action_Response_Key'] && this.additionalParameter['Action_Type'] == "downloadpdf") {
                    this.downloadPdf(url);
                }
                if (!this.additionalParameter['Action_Response_Key'] && this.additionalParameter['Action_Type'] === 'previewpdf') {
                    this.openPdfPreviewFromUrl(url);
                }
            }
            else {
                this.sharedEventsService.showMandatoryErrorMsg.emit({
                    fields: mandatorySatisfied, type: 'click'
                });
            }
        }
        else {
            if (moveTo === 'next') {
                mandatorySatisfied = this.checkValidateANDCheckMandatoryFields({ mandatory: true, valid: false });
                if (mandatorySatisfied.length === 0) {
                    this.executeEvent(moveTo);
                }
                else {
                    this.sharedEventsService.showMandatoryErrorMsg.emit({ fields: mandatorySatisfied, type: 'click' });
                }
            }
            else {
                this.executeEvent(moveTo);
                let url = '';
                if (this.rowData && this.rowData.hasOwnProperty('value')) {
                    url = this.rowData.data[this.additionalParameter['Action_Key']];
                }
                else {
                    const apiData = this.apiDataService.getApiDataByApiKey(this.additionalParameter['Action_Key']);
                    url = apiData ? apiData.value : '';
                }
                if (!this.additionalParameter['Action_Response_Key'] && this.additionalParameter['Action_Type'] == "downloadpdf") {
                    this.downloadPdf(url);
                }
                if (!this.additionalParameter['Action_Response_Key'] && this.additionalParameter['Action_Type'] === 'previewpdf') {
                    this.openPdfPreviewFromUrl(url);
                }
            }
        } //test
        if (mandatorySatisfied && mandatorySatisfied.length) {
            for (const fUID of mandatorySatisfied) {
                if (this.rootData['FieldErrorFunctions'][fUID]) {
                    this.rootData['FieldErrorFunctions'][fUID]();
                    break;
                }
            }
        }
    }
    getValueBetweenDollars(input) {
        return input?.split('$')[1] || '';
    }
    replacePlaceholder(prefix, placeholder, index, subIndex) {
        let newString = `${prefix}$${placeholder}$${index}`;
        if (subIndex) {
            newString = `${prefix}$${placeholder}$${index}$${subIndex}`;
        }
        return newString;
    }
    /**
     * Utility method to validate and parse Force Disable Section parameter values
     * Ensures proper handling of pipe-separated section IDs
     *
     * @param {string} sectionParam - The Force Disable Section parameter value
     * @returns {string[]} Array of cleaned section IDs
     */
    parseSectionIds(sectionParam) {
        if (!sectionParam) {
            return [];
        }
        // Split by pipe and clean up whitespace
        const sectionIds = sectionParam.split('|')
            .map(id => id.trim())
            .filter(id => id.length > 0); // Remove empty strings
        // console.log('📊 Parsed section IDs from parameter:', sectionIds);
        return sectionIds;
    }
    /**
     * Enhanced validation method for Force Disable Section parameter
     * Now supports multiple section IDs separated by pipe (|) character
     *
     * @param {Object} options - Validation options
     * @param {boolean} options.mandatory - Check for mandatory field violations
     * @param {boolean} options.valid - Check for field validation errors
     * @param {string} sectionId - Single section ID or multiple IDs separated by pipe (|)
     * @returns {string[]} Array of field IDs that have validation issues
     *
     * @example
     * // Single section
     * checkValidateANDCheckMandatoryFieldsForSection({mandatory: true, valid: true}, "17_34596_contact_view")
     *
     * @example
     * // Multiple sections
     * checkValidateANDCheckMandatoryFieldsForSection({mandatory: true, valid: true}, "17_34596_contact_view|0_34596_contact_view")
     */
    checkValidateANDCheckMandatoryFieldsForSection({ mandatory, valid }, sectionId) {
        const fields = [];
        // ENHANCED: Support multiple section IDs separated by pipe (|)
        // Use the parser utility for consistent handling
        const sectionIds = this.parseSectionIds(sectionId);
        if (sectionIds.length === 0) {
            console.warn('⚠️ No valid section IDs provided for Force Disable Section');
            return fields;
        }
        // console.log('🔍 Force Disable Section - checking sections:', sectionIds);
        // Loop through each section ID
        for (const currentSectionId of sectionIds) {
            if (this.rootData &&
                this.rootData.sectionFields &&
                this.rootData.sectionFields.hasOwnProperty(currentSectionId)) {
                const sectionFields = this.rootData?.sectionFields?.[currentSectionId] ?? [];
                // console.log(`📋 Section ${currentSectionId} has ${sectionFields.length} fields`);
                for (let index = 0; index < sectionFields.length; index++) {
                    const fieldDetails = this.appDataService.getFieldPropertiesByID(sectionFields[index]);
                    if (mandatory && fieldDetails && fieldDetails.mandatory && this.checkEmpty.isEmpty(fieldDetails.value)) {
                        fields.push(fieldDetails.id);
                        // console.log(`❌ Mandatory field missing in section ${currentSectionId}:`, fieldDetails.id);
                    }
                    if (valid && fieldDetails && !fieldDetails.isValid && fieldDetails.value) {
                        fields.push(fieldDetails.id);
                        // console.log(`❌ Invalid field in section ${currentSectionId}:`, fieldDetails.id);
                    }
                }
            }
            else {
                console.warn(`⚠️ Section ${currentSectionId} not found in rootData.sectionFields`);
            }
        }
        console.log('🎯 Force Disable Section - total validation issues:', fields.length);
        return fields;
    }
    checkValidateANDCheckMandatoryFieldsForBlock({ mandatory, valid }, blockId) {
        const fields = [];
        if (this.rootData &&
            this.rootData.blockFields &&
            this.rootData.blockFields.hasOwnProperty(blockId)) {
            const blockFields = this.rootData?.blockFields?.[blockId] ?? [];
            for (let index = 0; index < blockFields.length; index++) {
                const fieldDetails = this.appDataService.getFieldPropertiesByID(blockFields[index]);
                if (mandatory && fieldDetails && fieldDetails.mandatory && this.checkEmpty.isEmpty(fieldDetails.value)) {
                    fields.push(fieldDetails.id);
                }
                if (valid && fieldDetails && !fieldDetails.isValid && fieldDetails.value) {
                    fields.push(fieldDetails.id);
                }
            }
        }
        return fields;
    }
    checkValidateANDCheckMandatoryFields({ mandatory, valid }, blockId) {
        const fields = [];
        const allStepData = this.appDataService.getAllAppStoreData(blockId);
        for (const fieldData of allStepData) {
            let blockName = this.fieldData.unique_id.split('$');
            if (blockName.length > 1) {
                let blockName = this.fieldData.unique_id.split('$');
                let checkValue = this.checkBlockSection;
                let checkBlockSection;
                if (blockName[3]) {
                    checkBlockSection = this.replacePlaceholder(blockName[0], checkValue, blockName[2], blockName[3]);
                }
                else {
                    checkBlockSection = this.replacePlaceholder(blockName[0], checkValue, blockName[2]);
                }
                if ((checkBlockSection && (this.rootData['blockFields'][checkBlockSection] && ((this.rootData['blockFields'][checkBlockSection].includes(fieldData.id) || this.rootData['blockFields'][checkBlockSection].includes(this.getValueBetweenDollars(fieldData.id))))))) {
                    if (mandatory && fieldData.mandatory && this.checkEmpty.isEmpty(fieldData.value)) {
                        fields.push(fieldData.id);
                    }
                    if (valid && !fieldData.isValid && fieldData.value) {
                        fields.push(fieldData.id);
                    }
                }
            }
            else {
                if ((this.checkBlockSection &&
                    ((this.rootData['sectionFields'][this.checkBlockSection] && ((this.rootData['sectionFields'][this.checkBlockSection].includes(fieldData.id) || this.rootData['sectionFields'][this.checkBlockSection].includes(this.getValueBetweenDollars(fieldData.id)))))
                        || (this.rootData['blockFields'][this.checkBlockSection] && ((this.rootData['blockFields'][this.checkBlockSection].includes(fieldData.id) || this.rootData['blockFields'][this.checkBlockSection].includes(this.getValueBetweenDollars(fieldData.id)))))))
                    || (!this.checkBlockSection && this.stepId === fieldData.stepId)) {
                    if (mandatory && fieldData.mandatory && this.checkEmpty.isEmpty(fieldData.value)) {
                        fields.push(fieldData.id);
                    }
                    if (valid && !fieldData.isValid && fieldData.value) {
                        fields.push(fieldData.id);
                    }
                }
            }
        }
        //console.log("fields",fields);
        return fields;
    }
    forceDisableButtonForBlock(initValidationPassed) {
        if (this.additionalParameter['Force Disable Block']) {
            this.validationTimeout = setTimeout(() => {
                this.validationPassed = initValidationPassed;
            }, 0);
        }
    }
    forceDisableButtonForSection(initValidationPassed) {
        if (this.additionalParameter['Force Disable Section']) {
            this.validationTimeout = setTimeout(() => {
                this.validationPassed = initValidationPassed;
            }, 0);
        }
    }
    forceDisableButton(initValidationPassed) {
        if (this.additionalParameter['Force Disable'] && this.additionalParameter['Force Disable'].toLowerCase() !== 'false') {
            this.validationTimeout = setTimeout(() => {
                this.validationPassed = initValidationPassed;
            }, 0);
        }
    }
    onEmptySession(data) {
        // throw new Error('Method not implemented.');
    }
    handleCustomFunction(getData) {
        // throw new Error('Method not implemented.');
    }
    setFieldValueOnSetValuesEvent(data) {
        // throw new Error('Method not implemented.');
    }
    setFieldStateOnStateChangeEvent(data) {
    }
    updateStateHistory(data) {
        // throw new Error("Method not implemented.");
    }
    toggleLanguage(data) {
    }
    ngOnChanges(changes) {
        if (changes.editableCondition) {
            this.setConditions(changes.editableCondition.currentValue, 'isEditable');
        }
        if (changes.visibleCondition) {
            this.setConditions(changes.visibleCondition.currentValue, 'isVisible');
        }
        if (changes.mandatoryCondition) {
            this.setConditions(changes.mandatoryCondition.currentValue, 'isMandatory');
        }
    }
    /**
     * function checks for the condition that comes on the init as well as on the on change
     * @param editableCondition the editable condition
     * @param visibleCondition  the visible condition
     * @param mandatoryCondition the mandatory condition
     */
    checkConditionOnInit(editableCondition = null, visibleCondition = null, mandatoryCondition = null) {
        if (editableCondition) {
            this.setConditions(editableCondition, 'isEditable');
        }
        if (visibleCondition) {
            this.setConditions(visibleCondition, 'isVisible');
        }
        if (mandatoryCondition) {
            this.setConditions(mandatoryCondition, 'isMandatory');
        }
    }
    onContextMenu(event) {
        if (event.button === 2) {
            this.fieldData?.event_list?.forEach(x => {
                if (x.event_name === "OnRightClick" && x.isDefault === true) {
                    event.preventDefault();
                }
            });
            let objectLoc = {
                x: event.clientX + 'px',
                y: event.clientY + 'px'
            };
            this.onComponentEvent('OnRightClick', objectLoc);
        }
    }
    async downloadPdf(pdfUrlLocal) {
        let blobUrl = null;
        try {
            // Fetch the PDF file from the URL
            const response = await fetch(pdfUrlLocal);
            // Check if the response is successful
            if (!response.ok) {
                throw new Error(`Failed to fetch PDF: ${response.statusText}`);
            }
            // Convert the response to a Blob
            const blob = await response.blob();
            // Create a URL for the Blob
            blobUrl = URL.createObjectURL(blob);
            // Create a temporary anchor element to trigger the download
            const anchor = document.createElement("a");
            anchor.setAttribute("href", blobUrl);
            anchor.setAttribute("download", this.generateFilename("pdf")); // Optional: set file extension as needed
            // Append anchor, click it, and then clean up
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
            // console.log("PDF downloaded successfully!");
        }
        catch (error) {
            console.error("Error downloading PDF:", error);
        }
        finally {
            // ✅ FIX: Always cleanup blob URL
            if (blobUrl) {
                URL.revokeObjectURL(blobUrl);
            }
        }
    }
    generateFilename(extension = 'txt') {
        const now = new Date();
        const timestamp = now.getFullYear().toString() +
            this.padZero(now.getMonth() + 1) +
            this.padZero(now.getDate()) + '_' +
            this.padZero(now.getHours()) +
            this.padZero(now.getMinutes()) +
            this.padZero(now.getSeconds());
        return `${timestamp}.${extension}`;
    }
    padZero(value) {
        return value < 10 ? '0' + value : value.toString();
    }
    async openPdfPreviewFromUrl(url) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch PDF: ${response.statusText}`);
            }
            const blob = await response.blob();
            // Ensure it's treated as a PDF
            const blobType = 'application/pdf';
            const pdfBlob = new Blob([blob], { type: blobType });
            // Create a Blob URL from the PDF blob
            const blobUrl = URL.createObjectURL(pdfBlob);
            const htmlId = this.rowData ? this.rowData.html_id : this.fieldData?.html_id;
            const id = htmlId ? `previewModal-${htmlId.toLowerCase()}` : 'previewModal-default';
            const existingDialog = this.dialog.openDialogs.find(dialog => dialog.id === id);
            if (existingDialog) {
                existingDialog.close(); // Optionally close it, or skip opening a new one
            }
            this.dialog.openDialogs.forEach(dialog => {
                if (dialog.id === id) {
                    dialog.close();
                }
            });
            const dialogRef = this.dialog.open(AlertModalComponent, {
                height: '80vh',
                width: '80vw',
                data: {
                    type: 'PreviewModal',
                    value: blobUrl,
                    config: {
                        disableClose: false,
                        id,
                    },
                    fileType: 'doc',
                    from: "button-pdf",
                },
                id,
                panelClass: 'previewModal-panel',
            });
            this.subscriptions.add(dialogRef.afterOpened().subscribe(() => {
                this.commonUtil.moveMatDialogToStepModalIfExist();
            }));
            this.subscriptions.add(dialogRef.afterClosed().subscribe(() => {
                this.commonUtil.moveMatDialogToBody();
                URL.revokeObjectURL(blobUrl); // Cleanup blob URL
            }));
        }
        catch (error) {
            console.error("Error loading PDF preview:", error);
        }
    }
    static ɵfac = function CeeButtonComponent_Factory(t) { return new (t || CeeButtonComponent)(i0.ɵɵdirectiveInject(UserDataHandlerService), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(CEEInternalEmitterService), i0.ɵɵdirectiveInject(CeeApiService), i0.ɵɵdirectiveInject(i11.Router), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(WfeStepLoaderService), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(i7$1.MatDialog), i0.ɵɵdirectiveInject(i8.MatSnackBar), i0.ɵɵdirectiveInject(i9.HttpClient), i0.ɵɵdirectiveInject(FileUploadService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(UserDataHandlerService)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: CeeButtonComponent, selectors: [["app-cee-button"]], inputs: { stepId: "stepId", fieldData: "fieldData", primaryKeyIndex: "primaryKeyIndex", keepState: "keepState", rowData: "rowData", mandatoryCondition: "mandatoryCondition", editableCondition: "editableCondition", visibleCondition: "visibleCondition" }, standalone: true, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature], decls: 1, vars: 1, consts: [["class", "field-wrapper", 3, "ngClass", "contextmenu", 4, "ngIf"], [1, "field-wrapper", 3, "contextmenu", "ngClass"], [1, "form-field"], ["type", "button", 3, "click", "name", "id", "ngClass", "ngStyle", "disabled", "innerHtml"], ["type", "button", "class", "btn-tooltip ml-auto", 3, "tooltip", 4, "ngIf"], ["type", "button", 1, "btn-tooltip", "ml-auto", 3, "tooltip"]], template: function CeeButtonComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, CeeButtonComponent_div_0_Template, 4, 21, "div", 0);
        } if (rf & 2) {
            i0.ɵɵproperty("ngIf", ctx.isVisible || ctx.isSafariClass);
        } }, dependencies: [NgClass, NgStyle, MatTooltipModule, CommonModule, i13.NgIf, TooltipModule, TooltipDirective], styles: [".cee-button[_ngcontent-%COMP%]{border:2px solid black;background-color:#fff;padding:10px 31px;margin:5px;cursor:pointer;box-sizing:border-box;font-family:Lato,sans-serif;font-size:14px;color:#555}.cee-button[_ngcontent-%COMP%]:disabled{opacity:.65;cursor:not-allowed}.success[_ngcontent-%COMP%]{border-color:#4caf50;color:#fff;background-color:#4caf50}.success[_ngcontent-%COMP%]:hover{background-color:#4caf50;color:#fff}.info[_ngcontent-%COMP%]{color:#fff;background-color:#007bff;border-color:#007bff}.info[_ngcontent-%COMP%]:hover{background:#2196f3;color:#fff}.danger[_ngcontent-%COMP%]{border-color:#f44336;color:#fff;background-color:#f44336}.danger[_ngcontent-%COMP%]:hover{background:#f44336;color:#fff}.default[_ngcontent-%COMP%]{border-color:#e7e7e7;color:#fff;background-color:#e7e7e7}.default[_ngcontent-%COMP%]:hover{background:#e7e7e7}", ".custom-control-input[_ngcontent-%COMP%]:checked ~ .custom-control-label[_ngcontent-%COMP%]:before{background-color:#0071eb}.custom-control-input[_ngcontent-%COMP%]:disabled + .custom-control-label[_ngcontent-%COMP%]{cursor:not-allowed}input[_ngcontent-%COMP%]:disabled, select[_ngcontent-%COMP%]:disabled, textarea[_ngcontent-%COMP%]:disabled{cursor:not-allowed}.btn-tooltip[_ngcontent-%COMP%]{padding:0;line-height:0;font-weight:600;color:#a0a0a0;width:24px;height:24px;border:0;background-size:10px auto}.form-control[_ngcontent-%COMP%], .custom-select[_ngcontent-%COMP%]{border-radius:0;border-color:#d1d1d1;font-style:italic}.mandetory-mark[_ngcontent-%COMP%]{color:#eb1122}input.form-control.invalid[_ngcontent-%COMP%]{border:2px solid rgba(193,50,17,.72)}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CeeButtonComponent, [{
        type: Component,
        args: [{ selector: 'app-cee-button', standalone: true, imports: [NgClass, NgStyle, MatTooltipModule, CommonModule, DebounceClickDirective, TooltipModule], template: "<div class=\"field-wrapper\" [ngClass]=\"cssClasses\" *ngIf=\"isVisible || isSafariClass\" (contextmenu)=\"onContextMenu($event)\">\r\n    <div class=\"form-field\">\r\n        <button name=\"{{fieldData.api_key}}\" id=\"{{html_id}}\"\r\n            [attr.aria-label]=\"additionalParameter['Aria-Label'] ? additionalParameter['Aria-Label'] : 'Click on ' + fieldData.field_label\"\r\n            [attr.role]=\"additionalParameter['Aria-Role'] ? additionalParameter['Aria-Role'] : 'button'\"\r\n            [ngClass]=\"fieldData.field_style?((isCustomClass && fieldData.field_style.custom_class_name)?fieldData.field_style.custom_class_name:'btn btn-primary'):{ 'Submit':'cee-button success', 'Button':'cee-button default', 'Previous':'cee-button danger', 'Next':'cee-button info'}[this.fieldData.field_type]\"\r\n            [attr.tabindex]=\"tabIndexValue\" [ngStyle]=\"{\r\n                'font-family': fieldData.field_style.font_name,\r\n                'font-size': fieldData.field_style.font_size,\r\n                'font-style': fieldData.field_style.font_style,\r\n                'color': fieldData.field_style.font_color,\r\n                'border-color': fieldData.field_style.border_color,\r\n                'height': fieldData.field_style.field_height,\r\n                'width': fieldData.field_style.field_width,\r\n                'background-color': fieldData.field_style.background_color\r\n            }\" type=\"button\" (click)=\"buttonClickListener()\" [disabled]=\"!isEditable || !validationPassed\" \r\n            [innerHtml]=\"buttonLabel\"></button>\r\n        <!-- <span *ngIf=\"this.isMandatory && this.fieldData.field_type == 'Button'\" class=\"mandetory-mark\"> *</span> -->\r\n\r\n        <button *ngIf=\"hasTooltip\" type=\"button\" class=\"btn-tooltip ml-auto\" [tooltip]=\"fieldData.tooltip\" [attr.aria-label]=\"'Tooltip: ' + fieldData.tooltip \">i</button>\r\n    </div>\r\n</div>\r\n", styles: [".cee-button{border:2px solid black;background-color:#fff;padding:10px 31px;margin:5px;cursor:pointer;box-sizing:border-box;font-family:Lato,sans-serif;font-size:14px;color:#555}.cee-button:disabled{opacity:.65;cursor:not-allowed}.success{border-color:#4caf50;color:#fff;background-color:#4caf50}.success:hover{background-color:#4caf50;color:#fff}.info{color:#fff;background-color:#007bff;border-color:#007bff}.info:hover{background:#2196f3;color:#fff}.danger{border-color:#f44336;color:#fff;background-color:#f44336}.danger:hover{background:#f44336;color:#fff}.default{border-color:#e7e7e7;color:#fff;background-color:#e7e7e7}.default:hover{background:#e7e7e7}\n", ".custom-control-input:checked~.custom-control-label:before{background-color:#0071eb}.custom-control-input:disabled+.custom-control-label{cursor:not-allowed}input:disabled,select:disabled,textarea:disabled{cursor:not-allowed}.btn-tooltip{padding:0;line-height:0;font-weight:600;color:#a0a0a0;width:24px;height:24px;border:0;background-size:10px auto}.form-control,.custom-select{border-radius:0;border-color:#d1d1d1;font-style:italic}.mandetory-mark{color:#eb1122}input.form-control.invalid{border:2px solid rgba(193,50,17,.72)}\n"] }]
    }], () => [{ type: UserDataHandlerService }, { type: SharedEventsServiceService }, { type: CEEInternalEmitterService }, { type: CeeApiService }, { type: i11.Router }, { type: SharedEventsServiceService }, { type: WfeStepLoaderService }, { type: AppDataService }, { type: ApiDataService }, { type: i7$1.MatDialog }, { type: i8.MatSnackBar }, { type: i9.HttpClient }, { type: FileUploadService }, { type: i0.ChangeDetectorRef }, { type: UserDataHandlerService }], { stepId: [{
            type: Input
        }], fieldData: [{
            type: Input
        }], primaryKeyIndex: [{
            type: Input
        }], keepState: [{
            type: Input
        }], rowData: [{
            type: Input
        }], mandatoryCondition: [{
            type: Input
        }], editableCondition: [{
            type: Input
        }], visibleCondition: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(CeeButtonComponent, { className: "CeeButtonComponent", filePath: "lib\\field-components\\cee-button\\cee-button.component.ts", lineNumber: 54 }); })();

var ceeButton_component = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CeeButtonComponent: CeeButtonComponent
});

class SessionTimeoutUtil {
    idle;
    keepalive;
    router;
    dialog;
    wfeStepLoaderService;
    appDataService;
    apiDataService;
    idleState = 'Not started.';
    timedOut = false;
    lastPing = null;
    title = 'angular-idle-timeout';
    i = 0;
    constructor(idle, keepalive, router, dialog, wfeStepLoaderService, appDataService, apiDataService) {
        this.idle = idle;
        this.keepalive = keepalive;
        this.router = router;
        this.dialog = dialog;
        this.wfeStepLoaderService = wfeStepLoaderService;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        // Lets check the path everytime the route changes, reset the idle timer.
        this.router.events.subscribe((val) => {
            if (!this.timedOut) {
                this.reset(); // Restart idle tracking on route change
                // console.log('Timer Reset on route change: ', this.idleState);
            }
        });
        //  FIXED: Sync session timeout across tabs using localStorage for cross-tab communication
        window.addEventListener("storage", (event) => {
            if (event.key === "lastActivity" && !this.timedOut) {
                this.reset();
                // console.log('Timer Reset from cross-tab activity: ', this.idleState);
            }
        });
        //  FIXED: Detect tab switching - continue tracking when tab becomes visible
        document.addEventListener("visibilitychange", () => {
            if (!document.hidden && !this.timedOut) {
                // Tab became visible - reset timer and resume tracking
                this.updateLastActivity();
                this.reset();
                // console.log('Timer Reset on tab focus: ', this.idleState);
            }
            // Don't stop idle when tab becomes hidden - let it continue in background
        });
        // this.sessionTimeout();
    }
    sessionTimeout() {
        const seconds = Number(window.sessionStorage.getItem('SessionTimeOut'));
        const SessionModalTimeOut = window.sessionStorage.getItem('SessionModalTimeOut') ? Number(window.sessionStorage.getItem('SessionModalTimeOut')) : 8;
        const SessionModalStepId = window.sessionStorage.getItem('SessionModalStepId') ? window.sessionStorage.getItem('SessionModalStepId') : '';
        const LogoutModalStepId = window.sessionStorage.getItem('LogoutModalStepId') ? window.sessionStorage.getItem('LogoutModalStepId') : '';
        // console.log('seconds', seconds, this.idleState);
        if (seconds !== null && seconds !== 0) {
            // sets an idle timeout of 5 seconds, for testing purposes.
            this.idle.setIdle(seconds - SessionModalTimeOut);
            // sets a timeout period of 5 seconds. after 10 seconds of inactivity, the user will be considered timed out.
            this.idle.setTimeout(SessionModalTimeOut);
            // sets the default interrupts, in this case, things like clicks, scrolls, touches to the document
            this.idle.setInterrupts(DEFAULT_INTERRUPTSOURCES);
            this.idle.onIdleEnd.subscribe(() => {
                this.idleState = 'No longer idle.';
                this.updateLastActivity(); // Update cross-tab activity tracker
                this.reset();
                this.i = 0;
            });
            if (this.i === 0) {
                this.idle.onTimeout.subscribe(() => {
                    this.idleState = 'Timed out!';
                    this.timedOut = true;
                    // console.log(this.idleState);
                    // this.dialog.closeAll();
                    // clear the session here
                    window.sessionStorage.clear();
                    // Show Modal Here
                    /* const initialState = {
                        title: 'Session Timed Out !!!',
                        body: 'Your session is timed out. Please re-login',
                        buttonName: 'OK',
                        navigationLink: '/'
                    }; */
                    // this.bsModalRef = this.modalService.show(this.modalRenderer, {initialState});
                    if (LogoutModalStepId == '') {
                        alert('Your session is timed out. Please re-login');
                    }
                    else {
                        this.wfeStepLoaderService.loadStepById(LogoutModalStepId).subscribe((data) => {
                            if (data !== undefined) {
                                this.dialog.closeAll();
                                this.router.navigateByUrl(data.tid);
                                // this.openDialog(data);
                            }
                        });
                    }
                    // clear all the session data as well as akita store data
                    // window.sessionStorage.clear();
                    this.wfeStepLoaderService.stepDataStore = {};
                    this.wfeStepLoaderService.blockDataStore = {};
                    this.appDataService.removeAllAppData();
                    this.apiDataService.removeAllApiData();
                    if (LogoutModalStepId == '') {
                        // navigate to default step
                        this.navigate();
                    }
                });
                this.i++;
            }
            // this.idle.onIdleStart.pipe(first()).subscribe(() => {
            this.idle.onIdleStart.subscribe(() => {
                // console.log('Idle Start');
                // Check if there's been activity in other tabs before showing idle modal
                if (this.checkCrossTabActivity()) {
                    // console.log('Activity detected in other tab, resetting timer');
                    this.reset();
                    return;
                }
                // this.dialog.closeAll();
                this.idleState = 'You\'ve gone idle!';
                // console.log(this.idleState)
                if (SessionModalStepId != '') {
                    this.wfeStepLoaderService.loadStepById(SessionModalStepId).subscribe((data) => {
                        if (data !== undefined) {
                            setTimeout(() => {
                                // console.log("User has been idle for max timeout - 5 mins");
                                this.openDialog(data);
                            }, 0);
                        }
                    });
                }
            });
            this.idle.onTimeoutWarning.subscribe((countdown) => {
                this.idleState = 'You will time out in ' + countdown + ' seconds!';
                // console.log(this.idleState);
            });
            // sets the ping interval to 15 seconds
            this.keepalive.interval(15);
            this.keepalive.onPing.subscribe(() => {
                this.lastPing = new Date();
                this.updateLastActivity(); // Update cross-tab activity on ping
            });
            // Initialize cross-tab activity tracking
            this.updateLastActivity();
            this.reset();
        }
    }
    openDialog(data) {
        if (!this.dialog.getDialogById(`stepModal-${data.tid}`)) {
            this.dialog.closeAll();
            this.dialog.open(ModalRendererComponent, { data: { stepId: data.tid, startSession: false }, id: `stepModal-${data.tid}`, panelClass: `stepModal-${data.tid}` });
        }
    }
    reset() {
        // if (this.timedOut) {
        //   return;
        // }
        this.updateLastActivity(); // Update cross-tab activity tracker
        this.idle.watch();
        this.idleState = 'Started.';
        this.timedOut = false;
    }
    /**
     * Update last activity timestamp for cross-tab synchronization
     */
    updateLastActivity() {
        sessionStorage.setItem('lastActivity', Date.now().toString());
    }
    /**
     * Check if there's been recent activity in other tabs
     */
    checkCrossTabActivity() {
        const lastActivity = sessionStorage.getItem('lastActivity');
        if (lastActivity) {
            const timeDiff = Date.now() - parseInt(lastActivity);
            const seconds = Number(window.sessionStorage.getItem('SessionTimeOut'));
            const SessionModalTimeOut = Number(window.sessionStorage.getItem('SessionModalTimeOut')) || 8;
            // If activity was within the idle threshold, consider it recent
            return timeDiff < (seconds - SessionModalTimeOut) * 1000;
        }
        return false;
    }
    /**
     * function that navigates to default step
     */
    navigate(flag = true) {
        const stepMap = localStorage.getItem('CEE_ROUTE_MAP');
        if (stepMap) {
            const defaultStepData = Object.values(this.wfeStepLoaderService.sequenceDataMap)[0];
            let url = null;
            if (localStorage.getItem('navigateStepName') === 'true') {
                url = JSON.parse(stepMap)[defaultStepData.sequence[0].tid];
            }
            else {
                url = `/wfe/step/${defaultStepData.sequence[0].tid}`;
            }
            // CI-1118:  Force redirection to refresh the session storage data.
            if (flag) {
                window.location.href = url;
            }
        }
        else {
            console.error('Step Data Not Found !!!');
            this.router.navigateByUrl('/');
        }
    }
}

class SidemenuUtil {
    apiDataService;
    globalMenu = [];
    sidemenuBlock;
    sidemenuBlockOn = false;
    blockSetter = false;
    constructor(apiDataService) {
        this.apiDataService = apiDataService;
    }
    setSidemenuBlockStateOnDataEmit(res, sideBlockData, stepId) {
        if (sideBlockData) {
            for (const sidemenuBlockId of sideBlockData) {
                if (sidemenuBlockId.step_id && sidemenuBlockId.step_id.includes(stepId)) {
                    // console.log("sidemenuData>>>>>", stepId,sidemenuBlockId.step_id[0]);
                    // }
                    // if(this.sidemenuBlockOn == false){
                    this.globalMenu = sidemenuBlockId.submenu;
                    this.checkmenuContainsDyanmicContent(sidemenuBlockId.submenu);
                    // }
                    sidemenuBlockId.submenu = this.globalMenu;
                    this.sidemenuBlock = sidemenuBlockId;
                    this.sidemenuBlockOn = false;
                    let sideBlockDataResult = {
                        sidemenuBlock: this.sidemenuBlock,
                        sidemenuBlockOn: this.sidemenuBlockOn
                    };
                    return sideBlockDataResult;
                }
            }
        }
    }
    checkmenuContainsDyanmicContent(menu) {
        for (let i = 0; i < menu.length; i++) {
            if (menu[i].response_api_key && menu[i].response_api_key !== "") {
                this.createnewMenu(menu[i], menu[i].level, this.globalMenu);
            }
            if (menu[i].submenu && menu[i].submenu?.length > 0) {
                this.checkmenuContainsDyanmicContent(menu[i].submenu);
            }
        }
    }
    addyanmicContent(arrayAdd, text, level, globalMenu) {
        for (let i = 0; i < globalMenu?.length; i++) {
            if (globalMenu[i].response_api_key && globalMenu[i].response_api_key !== "") {
                if (globalMenu[i].linkText == text && globalMenu[i].level == level) {
                    globalMenu.splice(i, 1, ...arrayAdd);
                    break;
                }
            }
            if (globalMenu[i].submenu && globalMenu[i].submenu?.length > 0) {
                this.addyanmicContent(arrayAdd, text, level, globalMenu[i].submenu);
            }
        }
        this.globalMenu = globalMenu;
    }
    createnewMenu(menu, level, gm) {
        if (menu && menu.response_api_key) {
            let newArray = [];
            let responseKeys = menu.response_api_key.split("||");
            this.getCurrentParameterValue(responseKeys, 1);
            let parameterValue = this.blockSetter == true ? 1 : 0;
            let apiData = this.apiDataService.getApiDataByHandler(responseKeys[parameterValue].split('##')[0].trim());
            if (responseKeys[parameterValue].includes('[*]') && apiData) {
                const regex = responseKeys[parameterValue].split('[*]').join('\\[\\d+\\]');
                let counter = 0;
                const subMenuStatic = menu.submenu;
                for (const dataKey of Object.keys(apiData.value)) {
                    let newMenu = {};
                    const result = dataKey.match(new RegExp(regex));
                    if (result && apiData.value[dataKey] != null) {
                        let getlevel = this.getLevelClass(menu.level, menu.attchedmenuClass, counter, "", 1);
                        let getStatic = this.staticMenuAfterDynamic(subMenuStatic, getlevel, gm);
                        let clonedStatic = JSON.parse(JSON.stringify(getStatic));
                        newMenu.linkText = apiData.value[dataKey];
                        newMenu.menu = menu.menu;
                        // newMenu.attchedmenuClass =  getlevel;
                        //newMenu.attchedmenuClass =  menu.attchedmenuClass;
                        newMenu.attchedmenuClass = menu.attchedmenuClass + "_" + (counter + 1).toString();
                        newMenu.attachtoStep = menu.attachtoStep;
                        newMenu.menuclass = menu.menuclass;
                        newMenu.response_api_key = "";
                        newMenu.submenu = menu.submenu?.length > 0 ? clonedStatic : [];
                        newMenu.level = menu.level,
                            newMenu.menu_condition = menu.menu_condition;
                        newArray.push(newMenu);
                        counter++;
                    }
                }
                this.addyanmicContent(newArray, menu.linkText, level, gm);
            }
        }
    }
    getCurrentParameterValue(responseKeys, i) {
        if (responseKeys[i]) {
            let apiData = this.apiDataService.getApiDataByHandler(responseKeys[i].split('##')[0].trim());
            if (responseKeys[i].includes('[*]') && apiData) {
                const regex = responseKeys[i].split('[*]').join('\\[\\d+\\]');
                for (const dataKey of Object.keys(apiData.value)) {
                    const result = dataKey.match(new RegExp(regex));
                    if (result && apiData.value[dataKey] != null) {
                        this.blockSetter = true;
                    }
                }
            }
        }
    }
    staticMenuAfterDynamic(menu, parentPosition, gm) {
        menu.map((x, i) => {
            x.attchedmenuClass = this.getLevelClass(x.level, x.attchedmenuClass, i, parentPosition, 2);
            if (x.response_api_key && x.response_api_key !== "") {
                this.createnewMenu(x, x.level, gm);
            }
        });
        return menu;
    }
    getLevelClass(menuLevel, menuPosition, counter, parentPosition, box) {
        let parentPositionAdd;
        let contentValue = "dy";
        if (parentPosition != "") {
            const parentparts = parentPosition?.split('_');
            parentPositionAdd = Number(parentparts[parentparts.length - 1]);
        }
        const parts = menuPosition?.split('_');
        let lastNumber = box == 1 ? Number(parts[parts.length - 1]) + Number(counter) : Number(counter);
        let finalmenulevel = parentPositionAdd ? this.createMenuStringRecursive(menuLevel) + "_" + contentValue + "_" + parentPositionAdd + "_" + lastNumber : this.createMenuStringRecursive(menuLevel) + "_" + contentValue + "_" + lastNumber;
        return finalmenulevel;
    }
    createMenuStringRecursive(level) {
        if (level === 1) {
            return 'level1';
        }
        else {
            return this.createMenuStringRecursive(level - 1) + `_level${level}`;
        }
    }
    static ɵfac = function SidemenuUtil_Factory(t) { return new (t || SidemenuUtil)(i0.ɵɵinject(ApiDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: SidemenuUtil, factory: SidemenuUtil.ɵfac, providedIn: 'root' // The service is provided at the root level
     });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SidemenuUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'root' // The service is provided at the root level
            }]
    }], () => [{ type: ApiDataService }], null); })();

class RedirectionUtil {
    router;
    constructor(router) {
        this.router = router;
    }
    redirectTo(stepId, target = null, postURL = '') {
        const navigateStepName = localStorage.getItem('navigateStepName') === 'true' ? true : false;
        let url;
        if (navigateStepName) {
            const routeMap = JSON.parse(localStorage.getItem('CEE_ROUTE_MAP'));
            url = routeMap[stepId];
        }
        else {
            url = 'wfe/step/' + stepId;
        }
        url = url + postURL;
        if (target) {
            if (target === 'location') {
                // For same-origin navigation, use location.href for faster loading
                // This avoids Angular's routing lifecycle but maintains browser history
                const baseUrl = window.location.origin;
                const fullUrl = url.startsWith('/') ? `${baseUrl}${url}` : `${baseUrl}/${url}`;
                this.router?.navigate([]).then(_ => window.location.href = fullUrl);
            }
            else {
                // For external targets, use window.open
                this.router?.navigate([]).then(result => { window.open(url, target); });
            }
        }
        else {
            this.router?.navigateByUrl(url);
        }
    }
}

const _c0$4 = ["tree"];
const _c1$4 = (a0, a1) => ({ node: a0, currentState: a1 });
function ProgressBarRendererComponent_ng_container_3_mat_tree_node_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-tree-node", 7);
    i0.ɵɵelementContainer(1, 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r1 = ctx.$implicit;
    const ctx_r1 = i0.ɵɵnextContext(2);
    const progressElement_r3 = i0.ɵɵreference(7);
    i0.ɵɵclassMapInterpolate2("progressNode progressNode--", node_r1.currentState, " progressNode--", node_r1.nodeType, " mat-tree-node");
    i0.ɵɵattribute("data-display", ctx_r1.treeControlsData[node_r1.name])("aria-selected", node_r1.currentState === ctx_r1.applicationStates.STATE_ACTIVE ? "true" : "false");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngTemplateOutlet", progressElement_r3)("ngTemplateOutletContext", i0.ɵɵpureFunction2(8, _c1$4, node_r1, node_r1.currentState));
} }
function ProgressBarRendererComponent_ng_container_3_mat_nested_tree_node_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-nested-tree-node")(1, "div", 9)(2, "button", 10)(3, "mat-icon", 11);
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd()();
    i0.ɵɵelementContainer(5, 8);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "div", 12);
    i0.ɵɵelementContainer(7, 13);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const node_r4 = ctx.$implicit;
    const ctx_r1 = i0.ɵɵnextContext(2);
    const progressElement_r3 = i0.ɵɵreference(7);
    i0.ɵɵclassMapInterpolate2("progressNode progressNode--", node_r4.currentState, " progressNode--", node_r4.nodeType, " mat-tree-node");
    i0.ɵɵattribute("data-display", ctx_r1.treeControlsData[node_r4.name])("aria-selected", node_r4.currentState === ctx_r1.applicationStates.STATE_ACTIVE ? "true" : "false");
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("aria-label", "toggle " + node_r4.name);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", ctx_r1.treeControl.isExpanded(node_r4) ? "expand_more" : "chevron_right", " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngTemplateOutlet", progressElement_r3)("ngTemplateOutletContext", i0.ɵɵpureFunction2(12, _c1$4, node_r4, node_r4.currentState));
    i0.ɵɵadvance();
    i0.ɵɵclassProp("cee-tree-invisible", !ctx_r1.treeControl.isExpanded(node_r4));
} }
function ProgressBarRendererComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ProgressBarRendererComponent_ng_container_3_mat_tree_node_1_Template, 2, 11, "mat-tree-node", 5)(2, ProgressBarRendererComponent_ng_container_3_mat_nested_tree_node_2_Template, 8, 15, "mat-nested-tree-node", 6);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTreeNodeDefWhen", ctx_r1.hasChildTree);
} }
function ProgressBarRendererComponent_ng_template_4_mat_tree_node_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-tree-node", 16);
    i0.ɵɵelement(1, "button", 17);
    i0.ɵɵelementContainer(2, 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r5 = ctx.$implicit;
    const ctx_r1 = i0.ɵɵnextContext(2);
    const progressElement_r3 = i0.ɵɵreference(7);
    i0.ɵɵclassMapInterpolate2("progressNode progressNode--", node_r5.currentState, " progressNode--", node_r5.nodeType, " mat-tree-node");
    i0.ɵɵattribute("data-display", ctx_r1.treeControlsData[node_r5.name])("aria-selected", node_r5.currentState === ctx_r1.applicationStates.STATE_ACTIVE ? "true" : "false");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", progressElement_r3)("ngTemplateOutletContext", i0.ɵɵpureFunction2(8, _c1$4, node_r5, node_r5.currentState));
} }
function ProgressBarRendererComponent_ng_template_4_mat_tree_node_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-tree-node", 16)(1, "button", 10)(2, "mat-icon", 11);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd()();
    i0.ɵɵelementContainer(4, 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r6 = ctx.$implicit;
    const ctx_r1 = i0.ɵɵnextContext(2);
    const progressElement_r3 = i0.ɵɵreference(7);
    i0.ɵɵclassMapInterpolate2("progressNode progressNode--", node_r6.currentState, " progressNode--", node_r6.nodeType, " mat-tree-node");
    i0.ɵɵattribute("data-display", ctx_r1.treeControlsData[node_r6.name])("aria-selected", node_r6.currentState === ctx_r1.applicationStates.STATE_ACTIVE ? "true" : "false");
    i0.ɵɵadvance();
    i0.ɵɵattribute("aria-label", "toggle " + node_r6.name);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", ctx_r1.treeControl.isExpanded(node_r6) ? "expand_more" : "chevron_right", " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngTemplateOutlet", progressElement_r3)("ngTemplateOutletContext", i0.ɵɵpureFunction2(10, _c1$4, node_r6, node_r6.currentState));
} }
function ProgressBarRendererComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, ProgressBarRendererComponent_ng_template_4_mat_tree_node_0_Template, 3, 11, "mat-tree-node", 14)(1, ProgressBarRendererComponent_ng_template_4_mat_tree_node_1_Template, 5, 13, "mat-tree-node", 15);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("matTreeNodeDefWhen", ctx_r1.hasChild);
} }
function ProgressBarRendererComponent_ng_template_6_ng_container_1_img_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "img", 22);
    i0.ɵɵlistener("click", function ProgressBarRendererComponent_ng_template_6_ng_container_1_img_1_Template_img_click_0_listener() { i0.ɵɵrestoreView(_r7); const node_r8 = i0.ɵɵnextContext(2).node; const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.navigate(node_r8)); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    const node_r8 = ctx_r8.node;
    const currentState_r10 = ctx_r8.currentState;
    i0.ɵɵclassMapInterpolate2("progress-bar-element-image progress-bar-element-image--", currentState_r10, " progress-bar-element-image--", node_r8.nodeType, "");
    i0.ɵɵpropertyInterpolate("alt", node_r8.name + " " + currentState_r10 + " icon");
    i0.ɵɵproperty("src", node_r8["states"][currentState_r10]["state_icon"], i0.ɵɵsanitizeUrl);
} }
function ProgressBarRendererComponent_ng_template_6_ng_container_1_label_2_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "label", 23);
    i0.ɵɵlistener("click", function ProgressBarRendererComponent_ng_template_6_ng_container_1_label_2_Template_label_click_0_listener() { i0.ɵɵrestoreView(_r11); const node_r8 = i0.ɵɵnextContext(2).node; const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.navigate(node_r8)); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    const node_r8 = ctx_r8.node;
    const currentState_r10 = ctx_r8.currentState;
    i0.ɵɵclassMapInterpolate2("progress-bar-element-name progress-bar-element-name--", currentState_r10, " progress-bar-element-name--", node_r8.nodeType, "");
    i0.ɵɵstyleProp("color", node_r8.states[currentState_r10].state_color);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1(" ", node_r8.name, " ");
} }
function ProgressBarRendererComponent_ng_template_6_ng_container_1_label_3_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "label", 24);
    i0.ɵɵlistener("click", function ProgressBarRendererComponent_ng_template_6_ng_container_1_label_3_Template_label_click_0_listener() { i0.ɵɵrestoreView(_r12); const node_r8 = i0.ɵɵnextContext(2).node; const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.navigate(node_r8)); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    const node_r8 = ctx_r8.node;
    const currentState_r10 = ctx_r8.currentState;
    i0.ɵɵclassMapInterpolate2("progress-bar-element-name progress-bar-element-name--", currentState_r10, " progress-bar-element-name--", node_r8.nodeType, "");
    i0.ɵɵstyleProp("color", node_r8.states[currentState_r10].state_color);
    i0.ɵɵproperty("innerHTML", node_r8.name, i0.ɵɵsanitizeHtml);
} }
function ProgressBarRendererComponent_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ProgressBarRendererComponent_ng_template_6_ng_container_1_img_1_Template, 1, 6, "img", 19)(2, ProgressBarRendererComponent_ng_template_6_ng_container_1_label_2_Template, 2, 7, "label", 20)(3, ProgressBarRendererComponent_ng_template_6_ng_container_1_label_3_Template, 1, 7, "label", 21);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    const node_r8 = ctx_r8.node;
    const currentState_r10 = ctx_r8.currentState;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", node_r8.states[currentState_r10].state_icon && node_r8.states[currentState_r10].state_style !== "color");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !ctx_r1.isHTML(node_r8.name) && node_r8.states[currentState_r10].state_style !== "icon");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.isHTML(node_r8.name) && node_r8.states[currentState_r10].state_style !== "icon");
} }
function ProgressBarRendererComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, ProgressBarRendererComponent_ng_template_6_ng_container_1_Template, 4, 3, "ng-container", 18);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r8 = ctx.node;
    const currentState_r10 = ctx.currentState;
    i0.ɵɵclassMapInterpolate2("progress-bar-element progress-bar-element--", currentState_r10, " progress-bar-element--", node_r8.nodeType, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", node_r8.states[currentState_r10]);
} }
class ProgressBarRendererComponent {
    router;
    appDataService;
    apiDataService;
    sharedEventsService;
    progressBlock;
    stateIdMap;
    currentStep;
    applicationStates = {}; // application states
    stepIdMapStepName = {};
    stepNameMapStepId = {};
    navigationMap = {};
    applicationStateStoreUtil;
    redirectionUtil;
    progressBarDesign = '';
    isNestedTree = false;
    treeControl;
    treeControlsData = {};
    completedStepList = [];
    // tslint:disable-next-line: variable-name
    _transformer = (node, level) => {
        return {
            expandable: !!node.children && node.children.length > 0,
            name: node.name,
            navigation: node.navigation,
            stepName: node.stepName,
            stepId: node.stepId,
            nodeType: node.nodeType,
            currentState: node.currentState,
            states: node.states,
            level
        };
    };
    // tslint:disable-next-line: member-ordering
    treeFlattener = new MatTreeFlattener(this._transformer, node => node.level, node => node.expandable, node => node.children);
    // tslint:disable-next-line: member-ordering
    dataSource;
    variableObj = {};
    conditionalUtil;
    constructor(router, appDataService, apiDataService, sharedEventsService) {
        this.router = router;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.sharedEventsService = sharedEventsService;
        this.applicationStateStoreUtil = new ApplicationStateStoreUtil(this.appDataService);
        this.redirectionUtil = new RedirectionUtil(router);
        this.conditionalUtil = new ConditionalUtil(false, appDataService, apiDataService);
    }
    ngOnInit() {
        if (!this.progressBlock['response_api_key']) {
            this.progressBlock['response_api_key'] = "";
        }
        if (!this.progressBlock['request_api_key']) {
            this.progressBlock['request_api_key'] = "";
        }
        if (!this.progressBlock['workflowIds']) {
            this.progressBlock['workflowIds'] = [];
        }
        this.progressBlock.progress_elements.forEach((item, index) => {
            if (!this.progressBlock.progress_elements[index]['dependency_condition']) {
                this.progressBlock.progress_elements[index]['dependency_condition'] = {};
            }
            if (!this.progressBlock.progress_elements[index]['parent_element_id']) {
                this.progressBlock.progress_elements[index]['parent_element_id'] = "";
            }
            if (!this.progressBlock.progress_elements[index]['progress_elements']) {
                this.progressBlock.progress_elements[index]['progress_elements'] = [];
            }
        });
        this.applicationStates = {
            STATE_PENDING: localStorage.getItem('STATE_PENDING') || 'pending',
            STATE_COMPLETE: localStorage.getItem('STATE_COMPLETE') || 'complete',
            STATE_INCOMPLETE: localStorage.getItem('STATE_INCOMPLETE') || 'incomplete',
            STATE_ACTIVE: localStorage.getItem('STATE_ACTIVE') || 'active'
        };
        // get the step id if the navigateStepName is set to true
        if (localStorage.getItem('navigateStepName') === 'true') {
            this.currentStep = this.currentStep.split('-')[this.currentStep.split('-').length - 1];
        }
        if (this.progressBlock.progress_bar_type === 'nested-tree') {
            this.progressBarDesign = 'tree';
            this.isNestedTree = true;
            this.treeControl = new NestedTreeControl(node => node.children);
            this.dataSource = new MatTreeNestedDataSource();
        }
        else {
            this.progressBarDesign = this.progressBlock.progress_bar_type;
            this.treeControl = new FlatTreeControl(node => node.level, node => node.expandable);
            this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
        }
        this.intProgressBar();
        // console.log(this.stateIdMap);
        this.variableObj['emitApiSuccessRes_'] = this.sharedEventsService.emitApiSuccessResponse.subscribe(res => {
            setTimeout(() => {
                this.intProgressBar();
            }, 0);
        });
        // TODO: Separate conditional for all emitters and then subscribe if required
        this.variableObj['emitOnDataSetOrUpdated_'] = this.sharedEventsService.emitOnDataSetOrUpdated.subscribe(res => {
            setTimeout(() => {
                const progressElements = this.progressBlock.progress_elements;
                this.updateMap(progressElements);
                this.intProgressBar();
            }, 0);
        });
    }
    intProgressBar() {
        const progressData = this.createMap();
        if (JSON.stringify(progressData) !== JSON.stringify(this.dataSource.data)) {
            // this.getCompletedStepListFromBackend();
            this.dataSource.data = this.createMap();
            this.expandNode(); // expand the node by default if the current step matches
        }
    }
    tree;
    ngAfterViewInit() {
        if (this.progressBlock.default_expand_all) {
            this.tree.treeControl.expandAll();
        }
    }
    getElementID(element) {
        return element.step_name === 'None' ? element._id : this.stepNameMapStepId[element.step_name];
    }
    updateMap(progressElements) {
        for (const element of progressElements) {
            if (!element['progress_elements']) {
                element['progress_elements'] = [];
            }
            if (!element['parent_element_id']) {
                element['parent_element_id'] = '';
            }
            if (!element['dependency_condition']) {
                element['dependency_condition'] = {};
            }
            if (element.dependency_condition && element.dependency_condition.query) {
                const dependencyCondition = this.conditionalUtil.checkStepDependency(element.dependency_condition);
                this.treeControlsData[element.progress_element_name] = (dependencyCondition) ? true : false;
            }
            if (element.progress_elements) {
                for (const progressElement of element.progress_elements) {
                    this.updateMap(progressElement.progress_elements);
                }
            }
        }
    }
    createMap() {
        const obj = {};
        for (const state of this.progressBlock.states) {
            if (!state['state_response_key']) {
                state['state_response_key'] = "";
            }
            obj[state.state_id] = state;
        }
        for (const key of this.stateIdMap) {
            this.stepIdMapStepName[key.tid] = key.name;
            this.stepNameMapStepId[key.name] = key.tid;
        }
        // console.log(this.progressBlock.progress_elements);
        let data = this.getTreeStates(this.progressBlock.progress_elements, obj)[1];
        data = this.progressBarDesign === 'tree' ? this.getStatesDependingOnChildAsTree(data) : this.setStateDependingOnChild(data);
        // console.log(data);
        return data;
    }
    getTreeStates(progressElements, state, type = 'parent', mainArr = []) {
        const treeObject = {
            name: '',
            states: {},
            navigation: {
                page_navigation_oncomplete: 'false',
                navigation_false_oncomplete: 'false',
                navigation_false_incomplete_step: 'false'
            },
            nodeType: type,
            stepName: '',
            stepId: '',
            currentState: this.applicationStates.STATE_PENDING,
            forceStates: false,
            seq: 0
        };
        if (progressElements) {
            for (const element of progressElements) {
                if (!element['progress_elements']) {
                    element['progress_elements'] = [];
                }
                if (!element['parent_element_id']) {
                    element['parent_element_id'] = '';
                }
                if (!element['dependency_condition']) {
                    element['dependency_condition'] = {};
                }
                treeObject.name = element.progress_element_name;
                treeObject.stepName = element.step_name;
                treeObject.seq = element.seq;
                const stepId = this.stepNameMapStepId[element.step_name];
                treeObject.stepId = stepId;
                treeObject.navigation.page_navigation_oncomplete = element.page_navigation_oncomplete;
                treeObject.navigation.navigation_false_oncomplete = element.navigation_false_oncomplete;
                treeObject.navigation.navigation_false_incomplete_step = element.navigation_false_incomplete_step;
                treeObject.forceStates = false;
                treeObject.currentState = this.getCurrentState(element, treeObject);
                this.navigationMap[stepId] = JSON.parse(JSON.stringify(treeObject.navigation));
                if (element.dependency_condition && element.dependency_condition.query) {
                    const dependencyCondition = this.conditionalUtil.checkStepDependency(element.dependency_condition);
                    this.treeControlsData[element.progress_element_name] = (dependencyCondition) ? true : false;
                }
                const stateObj = {};
                for (const stateData of element.state_id.split('|')) {
                    stateObj[state[stateData].state_type] = state[stateData];
                }
                treeObject.states = stateObj;
                treeObject.children = [];
                if (this.progressBarDesign === 'tree' && element.progress_elements) {
                    for (const progressElement of element.progress_elements) {
                        treeObject.children.push(this.getTreeStates([progressElement], state, 'child', mainArr)[0]);
                    }
                    treeObject.children = treeObject.children.sort((a, b) => (a.seq > b.seq) ? 1 : ((b.seq > a.seq) ? -1 : 0));
                }
                else {
                    mainArr.push(JSON.parse(JSON.stringify(treeObject)));
                    // tslint:disable-next-line: no-unused-expression
                    mainArr = (this.getTreeStates(element.progress_elements, state, 'child', mainArr)[1]);
                }
                const obj = JSON.parse(JSON.stringify(treeObject));
                if (this.progressBarDesign === 'tree' && type === 'parent') {
                    mainArr.push(obj);
                }
            }
        }
        return [treeObject, mainArr.sort((a, b) => (a.seq > b.seq) ? 1 : ((b.seq > a.seq) ? -1 : 0))];
    }
    hasChild = (_, node) => node.expandable;
    hasChildTree = (_, node) => !!node.children && node.children.length > 0;
    setStateDependingOnChild(progressMap) {
        const object = {};
        let name = '';
        for (const index of Object.keys(progressMap)) {
            // check if there is step name or not
            if (progressMap[index].nodeType === 'parent') {
                name = 'parent_' + index;
                object[name] = [];
            }
            if (progressMap[index].nodeType === 'child') {
                object[name].push(index);
            }
        }
        Object.keys(object).forEach(key => {
            const parentIndex = key.split('parent_')[1];
            let active = false;
            let complete = true;
            let incomplete = false;
            for (const index of object[key]) {
                // if any one is active set parent active
                if (progressMap[index].currentState === this.applicationStates.STATE_ACTIVE) {
                    complete = false;
                    active = true;
                }
                // if any one is incomplete set parent incomplete
                if (progressMap[index].currentState === this.applicationStates.STATE_INCOMPLETE) {
                    complete = false;
                    incomplete = true;
                }
                // if any one is incomplete set parent incomplete
                if (progressMap[index].currentState === this.applicationStates.STATE_PENDING) {
                    complete = false;
                }
            }
            if (progressMap[parentIndex].currentState === this.applicationStates.STATE_ACTIVE) {
                active = true;
            }
            if (!progressMap[parentIndex].forceStates) {
                progressMap[parentIndex].currentState = active ?
                    this.applicationStates.STATE_ACTIVE : complete ?
                    this.applicationStates.STATE_COMPLETE : incomplete ?
                    this.applicationStates.STATE_INCOMPLETE :
                    this.applicationStates.STATE_PENDING;
            }
            this.applicationStateStoreUtil
                .setAnyState(this.progressBlock.progress_bar_id, this.stepNameMapStepId[progressMap[parentIndex].stepName], complete ?
                'STATE_COMPLETE' : incomplete ?
                'STATE_INCOMPLETE' :
                'STATE_PENDING');
            // console.log(key.split('parent_')[1], { active, complete, incomplete });
        });
        return progressMap;
    }
    getCompletedStepListFromBackend() {
        this.completedStepList = [];
        let completedStepHandler = this.progressBlock.step_completed_list_handler?.split('##');
        if (this.progressBlock.step_completed_list_handler && completedStepHandler.length > 1) {
            // console.log("completedStepHandler: ", completedStepHandler)
            const handlerData = this.apiDataService.getApiDataByHandler(completedStepHandler[0]);
            // console.log("handlerData: ", handlerData)
            if (this.progressBlock.step_completed_list_handler && this.progressBlock.step_completed_list_handler.includes('[*]') && handlerData) {
                const regex = this.progressBlock.step_completed_list_handler?.split('[*]').join('\\[\\d+\\]');
                let flag = 0;
                for (const dataKey of Object.keys(handlerData.value)) {
                    const result = dataKey.match(new RegExp(regex));
                    if (result && handlerData.value[dataKey] && this.completedStepList.indexOf(Number(handlerData.value[dataKey])) == -1) {
                        this.completedStepList.push(Number(handlerData.value[dataKey]));
                    }
                }
                // console.log("completedStepList: ", this.completedStepList)
            }
        }
    }
    getStatesDependingOnChildAsTree(progressData) {
        this.getCompletedStepListFromBackend();
        for (const key of progressData) {
            let active = false;
            // let complete = key.currentState === this.applicationStates.STATE_COMPLETE;
            let complete = (this.progressBlock.step_completed_list_handler && this.completedStepList.indexOf(Number(key.stepId)) != -1 && !this.hasCompletedStateCondition(key)) ? true : false;
            let incomplete = false;
            if (key.currentState === this.applicationStates.STATE_ACTIVE) {
                active = true;
            }
            else {
                const status = this.getChildStatus(key.children);
                if (status.active.includes(true)) {
                    active = true;
                    complete = false;
                }
                if (status.complete.length && !status.complete.includes(false)) {
                    complete = true;
                }
                if (status.incomplete.includes(true)) {
                    incomplete = true;
                    complete = false;
                }
                // console.log({ active, complete, incomplete });
            }
            if (!key.forceStates) {
                key.currentState = active ?
                    this.applicationStates.STATE_ACTIVE : complete ?
                    this.applicationStates.STATE_COMPLETE : incomplete ?
                    this.applicationStates.STATE_INCOMPLETE :
                    this.applicationStates.STATE_PENDING;
            }
            this.applicationStateStoreUtil
                .setAnyState(this.progressBlock.progress_bar_id, this.getElementID(key), complete ?
                'STATE_COMPLETE' : incomplete ?
                'STATE_INCOMPLETE' :
                'STATE_PENDING');
        }
        return progressData;
    }
    getChildStatus(children, statusObj = { active: [], incomplete: [], complete: [] }) {
        let active = false;
        let complete = false;
        let incomplete = false;
        for (const child of children) {
            complete = (this.progressBlock.step_completed_list_handler && this.completedStepList.indexOf(Number(child.stepId)) != -1 && !this.hasCompletedStateCondition(child)) ? true : false;
            // console.log(child, statusObj);
            if (child.currentState === this.applicationStates.STATE_ACTIVE) {
                complete = false;
                active = true;
            }
            // if any one is incomplete set parent incomplete
            if (child.currentState === this.applicationStates.STATE_INCOMPLETE) {
                complete = false;
                incomplete = true;
            }
            // if any one is incomplete set parent incomplete
            if (child.currentState === this.applicationStates.STATE_PENDING) {
                complete = false;
            }
            complete = (this.progressBlock.step_completed_list_handler && this.completedStepList.indexOf(Number(child.stepId)) != -1 && !this.hasCompletedStateCondition(child)) ? true : complete;
            if (complete) {
                incomplete = false;
                active = false;
            }
            statusObj.active.push(active);
            statusObj.incomplete.push(incomplete);
            statusObj.complete.push(complete);
            if (child.children.length) {
                // getChildStatus(child.children, statusObj)
                statusObj = { ...statusObj, ...this.getChildStatus(child.children, statusObj) };
            }
        }
        // console.log("statusObj: ",statusObj)
        return statusObj;
    }
    getCurrentState(element, treeObject) {
        this.getCompletedStepListFromBackend();
        if (!this.getElementID(element)) {
            return this.applicationStates['STATE_PENDING'];
        }
        let returnState = this.applicationStates[this.applicationStateStoreUtil
            .getStepState(this.progressBlock.progress_bar_id, this.getElementID(element)) || 'STATE_PENDING'];
        if (element.state_condition) {
            for (const sCond of element.state_condition) {
                if (sCond.query && sCond.state_id) {
                    const stateCondition = this.conditionalUtil.checkStepDependency(sCond);
                    const state = this.progressBlock.states.find(s => s.state_id === sCond.state_id);
                    if (!state['state_response_key']) {
                        state['state_response_key'] = "";
                    }
                    if (stateCondition && state) {
                        switch (state.state_value) {
                            case 'active':
                                returnState = this.applicationStates.STATE_ACTIVE;
                                break;
                            case 'pending':
                                returnState = this.applicationStates.STATE_PENDING;
                                break;
                            case 'incomplete':
                                returnState = this.applicationStates.STATE_INCOMPLETE;
                                break;
                            case 'complete':
                                returnState = this.applicationStates.STATE_COMPLETE;
                                break;
                            default:
                                break;
                        }
                        treeObject.forceStates = true;
                    }
                }
            }
        }
        if (this.stepNameMapStepId[element.step_name] === this.currentStep && !this.hasActiveStateCondition(element)) {
            returnState = this.applicationStates.STATE_ACTIVE;
        }
        if (returnState != this.applicationStates.STATE_ACTIVE && !this.hasCompletedStateCondition(element) && this.progressBlock.step_completed_list_handler && this.completedStepList.indexOf(Number(treeObject.stepId)) != -1 && !this.hasCompletedStateCondition(element) && treeObject.nodeType == "child") {
            returnState = this.applicationStates.STATE_COMPLETE;
        }
        if (returnState == this.applicationStates.STATE_COMPLETE && !this.hasCompletedStateCondition(element) && this.progressBlock.step_completed_list_handler && this.completedStepList.indexOf(Number(treeObject.stepId)) == -1 && !this.hasCompletedStateCondition(element) && treeObject.nodeType == "child") {
            returnState = this.applicationStates.STATE_INCOMPLETE;
        }
        return returnState;
    }
    hasActiveStateCondition(element) {
        if (element.state_condition) {
            for (const sCond of element.state_condition) {
                if (sCond.query && sCond.state_id) {
                    const state = this.progressBlock.states.find(s => s.state_id === sCond.state_id);
                    if (!state['state_response_key']) {
                        state['state_response_key'] = "";
                    }
                    if (state && state.state_value === 'active') {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    hasCompletedStateCondition(element) {
        if (element.state_condition) {
            for (const sCond of element.state_condition) {
                if (sCond.query && sCond.state_id) {
                    const state = this.progressBlock.states.find(s => s.state_id === sCond.state_id);
                    if (!state['state_response_key']) {
                        state['state_response_key'] = "";
                    }
                    if (state && state.state_value === 'complete') {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    expandNode() {
        if (this.progressBarDesign !== 'tree' || this.progressBlock.default_expand_all) {
            if (this.progressBlock.default_expand_all && this.tree && this.tree.treeControl) {
                this.tree.treeControl.expandAll();
            }
            return;
        }
        let lastExpandedIndex = 0;
        if (this.isNestedTree) {
        }
        else {
            for (const treeNode of this.treeControl.dataNodes) {
                if (treeNode.expandable) {
                    lastExpandedIndex = this.treeControl.dataNodes.indexOf(treeNode);
                }
                if (treeNode.stepId === this.currentStep) {
                    this.treeControl.expand(this.treeControl.dataNodes[lastExpandedIndex]);
                    break;
                }
            }
        }
    }
    /**
     * navigation function
     * @param node
     */
    navigate(node) {
        if (!node.stepName) {
            return;
        }
        // console.log(node, this.navigationMap);
        // navigation_false_incomplete_step: This allows user to navigate to previously completed steps only, user can not go to any upcoming step from progress bar.
        let navigate = true;
        if (node.navigation.navigation_false_incomplete_step === 'true') {
            // console.log("getStepState: ",this.applicationStateStoreUtil.getStepState(this.progressBlock.progress_bar_id, node.stepId))
            if (this.progressBlock.step_completed_list_handler) {
                if (this.completedStepList.indexOf(Number(node.stepId)) == -1 && !this.hasCompletedStateCondition(node)) {
                    navigate = false;
                }
            }
            else {
                navigate = this.applicationStateStoreUtil
                    .getStepState(this.progressBlock.progress_bar_id, node.stepId) === 'STATE_COMPLETE';
            }
        }
        // console.log("navigate: ", navigate, "node.stepId: ", node.stepId);
        if (!navigate) {
            return;
        }
        // cannot click or navigate to any step if the current step is not completed
        navigate = true;
        if (this.navigationMap[this.currentStep] && this.navigationMap[this.currentStep].page_navigation_oncomplete === 'true') {
            navigate = this.applicationStateStoreUtil
                .getStepState(this.progressBlock.progress_bar_id, this.currentStep) === 'STATE_COMPLETE';
        }
        if (!navigate) {
            return;
        }
        // cannot navigate to the required step if the step has navigation_false_oncomplete true and if the step is completed
        if (node.navigation.navigation_false_oncomplete === 'true') {
            navigate = this.applicationStateStoreUtil
                .getStepState(this.progressBlock.progress_bar_id, node.stepId) !== 'STATE_COMPLETE';
        }
        if (navigate && node.stepId) {
            this.redirectionUtil.redirectTo(node.stepId);
        }
    }
    ngOnDestroy() {
        for (const key in this.variableObj) {
            if (this.variableObj[key]) {
                this.variableObj[key].unsubscribe();
            }
        }
    }
    isHTML(value) {
        const regex = /(<([^>]+)>)/ig;
        return regex.test(value);
    }
    static ɵfac = function ProgressBarRendererComponent_Factory(t) { return new (t || ProgressBarRendererComponent)(i0.ɵɵdirectiveInject(i11.Router), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(SharedEventsServiceService)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ProgressBarRendererComponent, selectors: [["app-progress-bar-renderer"]], viewQuery: function ProgressBarRendererComponent_Query(rf, ctx) { if (rf & 1) {
            i0.ɵɵviewQuery(_c0$4, 5);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tree = _t.first);
        } }, inputs: { progressBlock: "progressBlock", stateIdMap: "stateIdMap", currentStep: "currentStep" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 8, vars: 7, consts: [["tree", ""], ["notNestedTree", ""], ["progressElement", ""], [3, "dataSource", "treeControl"], [4, "ngIf", "ngIfElse"], ["matTreeNodeToggle", "", 3, "class", 4, "matTreeNodeDef"], [3, "class", 4, "matTreeNodeDef", "matTreeNodeDefWhen"], ["matTreeNodeToggle", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "mat-tree-node"], ["mat-icon-button", "", "matTreeNodeToggle", ""], [1, "mat-icon-rtl-mirror"], ["role", "group"], ["matTreeNodeOutlet", ""], ["matTreeNodePadding", "", 3, "class", 4, "matTreeNodeDef"], ["matTreeNodePadding", "", 3, "class", 4, "matTreeNodeDef", "matTreeNodeDefWhen"], ["matTreeNodePadding", ""], ["mat-icon-button", "", "disabled", ""], [4, "ngIf"], [3, "src", "alt", "class", "click", 4, "ngIf"], [3, "class", "color", "click", 4, "ngIf"], [3, "class", "innerHTML", "color", "click", 4, "ngIf"], [3, "click", "src", "alt"], [3, "click"], [3, "click", "innerHTML"]], template: function ProgressBarRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementStart(0, "div")(1, "mat-tree", 3, 0);
            i0.ɵɵtemplate(3, ProgressBarRendererComponent_ng_container_3_Template, 3, 1, "ng-container", 4)(4, ProgressBarRendererComponent_ng_template_4_Template, 2, 1, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
            i0.ɵɵelementEnd();
            i0.ɵɵtemplate(6, ProgressBarRendererComponent_ng_template_6_Template, 2, 5, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            const notNestedTree_r13 = i0.ɵɵreference(5);
            i0.ɵɵclassMapInterpolate1("navigationPanel navigationPanel-", ctx.progressBlock.progress_bar_id, "");
            i0.ɵɵadvance();
            i0.ɵɵproperty("dataSource", ctx.dataSource)("treeControl", ctx.treeControl);
            i0.ɵɵadvance(2);
            i0.ɵɵproperty("ngIf", ctx.isNestedTree)("ngIfElse", notNestedTree_r13);
        } }, dependencies: [MatTreeModule, i5$1.MatNestedTreeNode, i5$1.MatTreeNodeDef, i5$1.MatTreeNodePadding, i5$1.MatTreeNodeToggle, i5$1.MatTree, i5$1.MatTreeNode, i5$1.MatTreeNodeOutlet, MatIconModule, i15.MatIcon, NgTemplateOutlet, CommonModule, i13.NgIf], styles: [".progress-bar-element-image[_ngcontent-%COMP%]{width:20px;margin-right:10px}[data-display=false][_ngcontent-%COMP%]{display:none!important}.cee-tree-invisible[_ngcontent-%COMP%]{display:none}.navigationPanel[_ngcontent-%COMP%]   .mat-nested-tree-node[_ngcontent-%COMP%]   div[role=group][_ngcontent-%COMP%]{padding-left:40px}.navigationPanel[_ngcontent-%COMP%]   div[role=group][_ngcontent-%COMP%] > .mat-tree-node[_ngcontent-%COMP%]{padding-left:40px}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ProgressBarRendererComponent, [{
        type: Component,
        args: [{ selector: 'app-progress-bar-renderer', standalone: true, imports: [MatTreeModule, MatIconModule, NgTemplateOutlet, CommonModule], template: "<div class=\"navigationPanel navigationPanel-{{progressBlock.progress_bar_id}}\">\r\n    <mat-tree #tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\">\r\n        <!-- This is the tree node template for leaf nodes -->\r\n        <ng-container *ngIf=\"isNestedTree; else notNestedTree\">\r\n            <mat-tree-node *matTreeNodeDef=\"let node\" [attr.data-display]=\"treeControlsData[node.name]\" matTreeNodeToggle\r\n                class=\"progressNode progressNode--{{node.currentState}} progressNode--{{node.nodeType}} mat-tree-node\"\r\n                [attr.aria-selected]=\"node.currentState === applicationStates.STATE_ACTIVE ? 'true': 'false'\">\r\n                <ng-container [ngTemplateOutlet]=\"progressElement\"\r\n                    [ngTemplateOutletContext]=\"{node:node, currentState:node.currentState}\"></ng-container>\r\n            </mat-tree-node>\r\n            <!-- This is the nested tree node template for expandable nodes -->\r\n            <mat-nested-tree-node *matTreeNodeDef=\"let node;when: hasChildTree\"\r\n                [attr.data-display]=\"treeControlsData[node.name]\"\r\n                class=\"progressNode progressNode--{{node.currentState}} progressNode--{{node.nodeType}} mat-tree-node\"\r\n                [attr.aria-selected]=\"node.currentState === applicationStates.STATE_ACTIVE ? 'true': 'false'\">\r\n                <div class=\"mat-tree-node\">\r\n                    <button mat-icon-button matTreeNodeToggle [attr.aria-label]=\"'toggle ' + node.name\">\r\n                        <mat-icon class=\"mat-icon-rtl-mirror\">\r\n                            {{treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right'}}\r\n                        </mat-icon>\r\n                    </button>\r\n                    <ng-container [ngTemplateOutlet]=\"progressElement\"\r\n                        [ngTemplateOutletContext]=\"{node:node, currentState:node.currentState}\">\r\n                    </ng-container>\r\n                </div>\r\n                <!-- There is inline padding applied to this div using styles.\r\n                    This padding value depends on the mat-icon-button width.  -->\r\n                <div [class.cee-tree-invisible]=\"!treeControl.isExpanded(node)\" role=\"group\">\r\n                    <ng-container matTreeNodeOutlet></ng-container>\r\n                </div>\r\n            </mat-nested-tree-node>\r\n        </ng-container>\r\n        <ng-template #notNestedTree>\r\n            <mat-tree-node *matTreeNodeDef=\"let node\" [attr.data-display]=\"treeControlsData[node.name]\" matTreeNodePadding\r\n                class=\"progressNode progressNode--{{node.currentState}} progressNode--{{node.nodeType}} mat-tree-node\"\r\n                [attr.aria-selected]=\"node.currentState === applicationStates.STATE_ACTIVE ? 'true': 'false'\">\r\n                <!-- use a disabled button to provide padding for tree leaf -->\r\n                <button mat-icon-button disabled></button>\r\n                <ng-container [ngTemplateOutlet]=\"progressElement\"\r\n                    [ngTemplateOutletContext]=\"{node:node, currentState:node.currentState}\"></ng-container>\r\n            </mat-tree-node>\r\n            <!-- This is the tree node template for expandable nodes -->\r\n            <mat-tree-node *matTreeNodeDef=\"let node;when: hasChild\" [attr.data-display]=\"treeControlsData[node.name]\"\r\n                matTreeNodePadding\r\n                class=\"progressNode progressNode--{{node.currentState}} progressNode--{{node.nodeType}} mat-tree-node\"\r\n                [attr.aria-selected]=\"node.currentState === applicationStates.STATE_ACTIVE ? 'true': 'false'\">\r\n                <button mat-icon-button matTreeNodeToggle [attr.aria-label]=\"'toggle ' + node.name\">\r\n                    <mat-icon class=\"mat-icon-rtl-mirror\">\r\n                        {{treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right'}}\r\n                    </mat-icon>\r\n                </button>\r\n                <ng-container [ngTemplateOutlet]=\"progressElement\"\r\n                    [ngTemplateOutletContext]=\"{node:node, currentState:node.currentState}\">\r\n                </ng-container>\r\n            </mat-tree-node>\r\n        </ng-template>\r\n    </mat-tree>\r\n    <ng-template #progressElement let-node=\"node\" let-currentState=\"currentState\">\r\n        <div\r\n            class=\"progress-bar-element progress-bar-element--{{currentState}} progress-bar-element--{{node.nodeType}}\">\r\n            <ng-container *ngIf=\"node.states[currentState]\">\r\n                <img [src]=\"node['states'][currentState]['state_icon']\" alt=\"{{node.name+' '+ currentState +' icon'}}\"\r\n                    class=\"progress-bar-element-image progress-bar-element-image--{{currentState}} progress-bar-element-image--{{node.nodeType}}\"\r\n                    *ngIf=\"node.states[currentState].state_icon && node.states[currentState].state_style !== 'color'\"\r\n                    (click)=\"navigate(node)\">\r\n                    <label\r\n                        class=\"progress-bar-element-name progress-bar-element-name--{{currentState}} progress-bar-element-name--{{node.nodeType}}\"\r\n                        *ngIf=\"!isHTML(node.name) && node.states[currentState].state_style !== 'icon'\" (click)=\"navigate(node)\"\r\n                        [style.color]=\"node.states[currentState].state_color\">\r\n                        {{node.name}}\r\n                    </label>\r\n                    <label\r\n                        class=\"progress-bar-element-name progress-bar-element-name--{{currentState}} progress-bar-element-name--{{node.nodeType}}\"\r\n                        *ngIf=\"isHTML(node.name) && node.states[currentState].state_style !== 'icon'\" [innerHTML]=\"node.name\" (click)=\"navigate(node)\"\r\n                        [style.color]=\"node.states[currentState].state_color\"></label>\r\n            </ng-container>\r\n        </div>\r\n    </ng-template>\r\n</div>", styles: [".progress-bar-element-image{width:20px;margin-right:10px}[data-display=false]{display:none!important}.cee-tree-invisible{display:none}.navigationPanel .mat-nested-tree-node div[role=group]{padding-left:40px}.navigationPanel div[role=group]>.mat-tree-node{padding-left:40px}\n"] }]
    }], () => [{ type: i11.Router }, { type: AppDataService }, { type: ApiDataService }, { type: SharedEventsServiceService }], { progressBlock: [{
            type: Input
        }], stateIdMap: [{
            type: Input
        }], currentStep: [{
            type: Input
        }], tree: [{
            type: ViewChild,
            args: ['tree', { static: false }]
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(ProgressBarRendererComponent, { className: "ProgressBarRendererComponent", filePath: "lib\\components\\progress-bar-renderer\\progress-bar-renderer.component.ts", lineNumber: 56 }); })();

const _c0$3 = ["modal"];
const _c1$3 = ["dial"];
function DrawerComponent_div_4_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9)(1, "button", 10);
    i0.ɵɵlistener("click", function DrawerComponent_div_4_div_3_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r1.closeModal()); });
    i0.ɵɵtext(2, "Close");
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("stepModalButtons stepModalButtons-", ctx_r1.stepId, "");
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("stepModalClose stepModalClose-", ctx_r1.stepId, "");
} }
function DrawerComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div")(1, "div", 6);
    i0.ɵɵelement(2, "app-step-renderer", 7);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(3, DrawerComponent_div_4_div_3_Template, 3, 6, "div", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("stepModalContent stepModalContent-", ctx_r1.data.stepId, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("stepId", ctx_r1.stepId)("startSession", ctx_r1.startSession);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.startSession !== false);
} }
function DrawerComponent_div_5_label_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "label");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(ctx_r1.data.modal.modalMessage);
} }
function DrawerComponent_div_5_label_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "label", 13);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("innerHTML", ctx_r1.data.modal.modalMessage, i0.ɵɵsanitizeHtml);
} }
function DrawerComponent_div_5_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-block-renderer", 14);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("stepId", ctx_r1.stepId)("templateId", ctx_r1.templateId)("blockId", ctx_r1.data.modal.inputFormFields)("blockPosition", "modal")("rootData", ctx_r1.rootData);
} }
function DrawerComponent_div_5_div_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "button", 10);
    i0.ɵɵlistener("click", function DrawerComponent_div_5_div_9_ng_container_1_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r3); const ctx_r1 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r1.closeModal()); });
    i0.ɵɵtext(2, "Cancel");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("eventModalClose eventModalClose-", ctx_r1.data.modal.modalId, "");
} }
function DrawerComponent_div_5_div_9_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-cee-button", 17);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r4 = ctx.$implicit;
    const bi_r5 = ctx.index;
    const ctx_r1 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", bi_r5, "");
    i0.ɵɵproperty("stepId", ctx_r1.stepId)("fieldData", field_r4)("rootData", ctx_r1.rootData)("rowData", ctx_r1.rowData)("mandatoryCondition", ctx_r1.mandatoryCondition)("editableCondition", ctx_r1.editableCondition)("visibleCondition", ctx_r1.visibleCondition);
} }
function DrawerComponent_div_5_div_9_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, DrawerComponent_div_5_div_9_ng_template_2_ng_container_0_Template, 2, 10, "ng-container", 16);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngForOf", ctx_r1.modalButtons);
} }
function DrawerComponent_div_5_div_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtemplate(1, DrawerComponent_div_5_div_9_ng_container_1_Template, 3, 3, "ng-container", 15)(2, DrawerComponent_div_5_div_9_ng_template_2_Template, 1, 1, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const buttonsModal_r6 = i0.ɵɵreference(3);
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("eventModalButtons eventModalButtons-", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.data.modal.buttons.length === 0)("ngIfElse", buttonsModal_r6);
} }
function DrawerComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div")(1, "div")(2, "div")(3, "h3", 11);
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd()();
    i0.ɵɵelementStart(5, "div", 6);
    i0.ɵɵtemplate(6, DrawerComponent_div_5_label_6_Template, 2, 1, "label", 4)(7, DrawerComponent_div_5_label_7_Template, 1, 1, "label", 12)(8, DrawerComponent_div_5_ng_container_8_Template, 2, 5, "ng-container", 4);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(9, DrawerComponent_div_5_div_9_Template, 4, 5, "div", 8);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("event-body ", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("float-left modalTitle modalTitle-", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r1.data.modal.modalTitle);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("eventModalContent eventModalContent-", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !ctx_r1.isHTML(ctx_r1.data.modal.modalMessage));
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.isHTML(ctx_r1.data.modal.modalMessage));
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.data.modal.type == "form");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.startSession !== false);
} }
class DrawerComponent {
    sharedEventsService;
    loaderService;
    modal;
    dial;
    autoPreviewConfigPath = localStorage.getItem('ENABLE_AUTO_PREVIEW')?.toLowerCase() == "true" && localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') ? localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') : 'assets/config';
    configBlockPath = this.autoPreviewConfigPath + '/application_blocks/application_blocks_';
    stepId;
    templateId;
    rootData;
    rowData;
    data;
    variableObj = {};
    lastClickedElement = null;
    mandatoryCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    editableCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    visibleCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    startSession;
    modalButtons = [];
    commonUtil;
    isLoadingState = false;
    loadingSubscription;
    constructor(sharedEventsService, loaderService) {
        this.sharedEventsService = sharedEventsService;
        this.loaderService = loaderService;
        this.startSession = this.data?.startSession;
        let jsonval = null;
        this.data?.modal && this.data?.modal?.buttons.forEach((button, i) => {
            jsonval = {
                field_label: button.label,
                unique_id: "modal_button_" + i,
                is_mandatory: 0,
                is_editable: 1,
                is_display: 1,
                is_conditional_value: 0,
                field_type: "Button",
                validation_messages: [],
                validation_regex: "",
                additional_parameters: [],
                api_key: "",
                request_api_key: "",
                response_api_key: "",
                tooltip: "",
                possible_values: [],
                event_list: button.event_list,
            };
            this.modalButtons.push(jsonval);
        });
        this.sharedEventsService.closeDrawerOnClickExternalUrl.subscribe(res => {
            if (res) {
                this.modal.nativeElement.close();
            }
        });
        this.commonUtil = new CommonUtil();
    }
    ngOnInit() {
        // Subscribe to loading state
        this.loadingSubscription = this.loaderService.isLoading.subscribe(loading => this.isLoadingState = loading);
    }
    // Close modal
    closeModal() {
        localStorage.setItem('isDrawerOpen', '0');
        if (this.modal.nativeElement && this.modal.nativeElement.open) {
            this.modal.nativeElement.close();
            this.commonUtil.moveMatDialogToBody();
            this.sharedEventsService.modelEmitter.emit({ data: { stepId: "", config: { disableClose: true } }, id: ``, panelClass: `` });
        }
    }
    // Listen for ESC key press
    onEscapeKey(event) {
        this.onDialogClose();
    }
    // Handle dialog close event
    onDialogClose() {
        if (this.modal.nativeElement && this.modal.nativeElement.open) {
            this.modal.nativeElement.close();
            this.commonUtil.moveMatDialogToBody();
            this.sharedEventsService.modelEmitter.emit({ data: { stepId: "", config: { disableClose: true } }, id: ``, panelClass: `` });
        }
    }
    openModal() {
        localStorage.setItem('isDrawerOpen', '1');
        if (this.modal.nativeElement && !this.modal.nativeElement.open) {
            this.lastClickedElement = null;
            this.modal.nativeElement.showModal();
        }
    }
    handleDocumentClick(event) {
        // Check if loading - if yes, don't close modal
        if (this.isLoadingState) {
            return;
        }
        const targetElement = event.target, isModalOpen = this.modal?.nativeElement?.open, clickedOutside = this.dial.nativeElement.contains(targetElement), shouldDismiss = this.data.config.dismissModal === 0, 
        //Check if target has class and to resist dropdown clicks as it renders outside component's DOM tree
        targetHasClass = targetElement.classList.contains('dropdown-item');
        if (isModalOpen && !clickedOutside && !targetHasClass && shouldDismiss) {
            this.modal.nativeElement.close();
            this.commonUtil.moveMatDialogToBody();
            this.sharedEventsService.modelEmitter.emit({ data: { stepId: "", config: { disableClose: true } }, id: ``, panelClass: `` });
        }
    }
    ngAfterViewInit() {
        // Only after the view is initialized can we access the nativeElement
        if (this.modal && this.modal.nativeElement && this.stepId) {
            this.modal.nativeElement.addEventListener('close', this.onDialogClose.bind(this));
            this.openModal();
        }
    }
    // Clean up event listeners to prevent memory leaks
    ngOnDestroy() {
        localStorage.setItem('isDrawerOpen', '0');
        if (this.modal && this.modal.nativeElement) {
            this.modal.nativeElement.removeEventListener('close', this.onDialogClose);
        }
        if (this.loadingSubscription) {
            this.loadingSubscription.unsubscribe();
        }
    }
    isHTML(value) {
        const regex = /(<([^>]+)>)/ig;
        return regex.test(value);
    }
    static ɵfac = function DrawerComponent_Factory(t) { return new (t || DrawerComponent)(i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(LoaderService)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DrawerComponent, selectors: [["cee-drawer-renderer"]], viewQuery: function DrawerComponent_Query(rf, ctx) { if (rf & 1) {
            i0.ɵɵviewQuery(_c0$3, 5);
            i0.ɵɵviewQuery(_c1$3, 5);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.modal = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dial = _t.first);
        } }, hostBindings: function DrawerComponent_HostBindings(rf, ctx) { if (rf & 1) {
            i0.ɵɵlistener("keydown.escape", function DrawerComponent_keydown_escape_HostBindingHandler($event) { return ctx.onEscapeKey($event); }, false, i0.ɵɵresolveDocument)("click", function DrawerComponent_click_HostBindingHandler($event) { return ctx.handleDocumentClick($event); }, false, i0.ɵɵresolveDocument);
        } }, inputs: { stepId: "stepId", templateId: "templateId", rootData: "rootData", rowData: "rowData", data: "data" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 6, vars: 4, consts: [["modal", ""], ["dial", ""], ["buttonsModal", ""], [1, "drawer", 3, "id"], [4, "ngIf"], [3, "class", 4, "ngIf"], ["mat-dialog-content", ""], [3, "stepId", "startSession"], ["mat-dialog-actions", "", 3, "class", 4, "ngIf"], ["mat-dialog-actions", ""], ["mat-button", "", "aria-label", "Select Close", 3, "click"], ["mat-dialog-title", ""], [3, "innerHTML", 4, "ngIf"], [3, "innerHTML"], [1, "modal-form-content", 3, "stepId", "templateId", "blockId", "blockPosition", "rootData"], [4, "ngIf", "ngIfElse"], [4, "ngFor", "ngForOf"], [3, "stepId", "fieldData", "rootData", "rowData", "mandatoryCondition", "editableCondition", "visibleCondition"]], template: function DrawerComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementStart(0, "dialog", 3, 0)(2, "div", null, 1);
            i0.ɵɵtemplate(4, DrawerComponent_div_4_Template, 4, 6, "div", 4)(5, DrawerComponent_div_5_Template, 10, 14, "div", 5);
            i0.ɵɵelementEnd()();
        } if (rf & 2) {
            i0.ɵɵpropertyInterpolate1("id", "stepModal-", ctx.data.stepId, "");
            i0.ɵɵadvance(4);
            i0.ɵɵproperty("ngIf", ctx.stepId);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.data == null ? null : ctx.data.modal == null ? null : ctx.data.modal.modalId);
        } }, dependencies: () => [StepRendererComponent, BlockRendererComponent, CeeButtonComponent, CommonModule, i13.NgForOf, i13.NgIf], styles: [".drawer[_ngcontent-%COMP%]{position:fixed;margin-top:2rem;display:flex;justify-content:center;background:#fff;box-shadow:0 0 10px #00000080;overflow:auto;border-radius:.375rem;z-index:9999;display:block;border:0;border:1px solid gray;padding:0!important}dialog[_ngcontent-%COMP%]::backdrop{background:var(--neutral-black, #666);opacity:.7}p[_ngcontent-%COMP%]{font-family:Lato}dialog[_ngcontent-%COMP%]{padding:10px}dialog[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{margin:10px}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DrawerComponent, [{
        type: Component,
        args: [{ selector: 'cee-drawer-renderer', standalone: true, imports: [forwardRef(() => StepRendererComponent), forwardRef(() => BlockRendererComponent), CeeButtonComponent, CommonModule], template: "<dialog #modal id=\"stepModal-{{data.stepId}}\" class=\"drawer\">\r\n    <div #dial>\r\n        <div *ngIf=\"stepId\">\r\n            <div mat-dialog-content class=\"stepModalContent stepModalContent-{{data.stepId}}\">\r\n                <app-step-renderer [stepId]=\"stepId\" [startSession]=\"startSession\"></app-step-renderer>\r\n            </div>\r\n            <div mat-dialog-actions class=\"stepModalButtons stepModalButtons-{{stepId}}\" *ngIf=\"startSession!==false\">\r\n                <button mat-button class=\"stepModalClose stepModalClose-{{stepId}}\" (click)=\"closeModal()\" aria-label=\"Select Close\">Close</button>\r\n            </div>\r\n        </div>\r\n        <div *ngIf=\"data?.modal?.modalId\" class=\"event-body {{data.modal.modalId}}\">\r\n            <div>\r\n                <div class=\"float-left modalTitle modalTitle-{{data.modal.modalId}}\">\r\n                    <h3 mat-dialog-title>{{data.modal.modalTitle}}</h3>\r\n                </div>\r\n\r\n                <div mat-dialog-content class=\"eventModalContent eventModalContent-{{data.modal.modalId}}\">\r\n\r\n                    <label *ngIf=\"!isHTML(data.modal.modalMessage)\">{{data.modal.modalMessage}}</label>\r\n                    <label *ngIf=\"isHTML(data.modal.modalMessage)\" [innerHTML]=\"data.modal.modalMessage\"></label>\r\n                    <ng-container *ngIf=\"data.modal.type == 'form'\">\r\n                        <app-block-renderer [stepId]=\"stepId\" [templateId]=\"templateId\" [blockId]=\"data.modal.inputFormFields\" class=\"modal-form-content\" [blockPosition]=\"'modal'\" [rootData]=\"rootData\">\r\n                        </app-block-renderer>\r\n                    </ng-container>\r\n\r\n                </div>\r\n                <div mat-dialog-actions class=\"eventModalButtons eventModalButtons-{{data.modal.modalId}}\" *ngIf=\"startSession!==false\">\r\n\r\n                    <ng-container *ngIf=\"data.modal.buttons.length === 0; else buttonsModal\">\r\n                        <button mat-button class=\"eventModalClose eventModalClose-{{data.modal.modalId}}\" (click)=\"closeModal()\" aria-label=\"Select Close\">Cancel</button>\r\n                    </ng-container>\r\n                    <ng-template #buttonsModal>\r\n                        <ng-container *ngFor=\"let field of modalButtons; index as bi;\">\r\n                            <app-cee-button [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ bi }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n                            </app-cee-button>\r\n                        </ng-container>\r\n                    </ng-template>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</dialog>\r\n", styles: [".drawer{position:fixed;margin-top:2rem;display:flex;justify-content:center;background:#fff;box-shadow:0 0 10px #00000080;overflow:auto;border-radius:.375rem;z-index:9999;display:block;border:0;border:1px solid gray;padding:0!important}dialog::backdrop{background:var(--neutral-black, #666);opacity:.7}p{font-family:Lato}dialog{padding:10px}dialog div{margin:10px}\n"] }]
    }], () => [{ type: SharedEventsServiceService }, { type: LoaderService }], { modal: [{
            type: ViewChild,
            args: ['modal']
        }], dial: [{
            type: ViewChild,
            args: ['dial']
        }], stepId: [{
            type: Input
        }], templateId: [{
            type: Input
        }], rootData: [{
            type: Input
        }], rowData: [{
            type: Input
        }], data: [{
            type: Input
        }], onEscapeKey: [{
            type: HostListener,
            args: ['document:keydown.escape', ['$event']]
        }], handleDocumentClick: [{
            type: HostListener,
            args: ['document:click', ['$event']]
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(DrawerComponent, { className: "DrawerComponent", filePath: "lib\\components\\drawer-renderer\\drawer-renderer.component.ts", lineNumber: 22 }); })();

class AccordionService {
    // ✅ Existing observable for sectionId (used by old components)
    sectionOpenSource = new Subject();
    sectionOpen$ = this.sectionOpenSource.asObservable();
    // ✅ New observable for section info with parentId
    sectionOpenWithParentSource = new Subject();
    sectionOpenWithParent$ = this.sectionOpenWithParentSource.asObservable();
    // ✅ Old single section logic (unchanged)
    openSection(sectionId) {
        //console.log(`📢 Emitting section open request: ${sectionId}`);
        this.sectionOpenSource.next(sectionId);
    }
    // ✅ Old multi-section logic (still supported)
    openMultipleSections(sectionIds) {
        sectionIds.forEach(sectionId => {
            //console.log(`📢 Emitting API-triggered section open request: ${sectionId}`);
            this.sectionOpenSource.next(sectionId);
        });
    }
    // ✅ New method with parentId support (does not affect old components )
    openMultipleSectionsWithParent(sectionIds, parentId, defaultValue, iCounter) {
        //console.log(`📢 Emitting with parent:`, { sectionIds, parentId, defaultValue,iCounter });
        this.sectionOpenWithParentSource.next({ sectionIds, parentId, defaultValue, iCounter });
    }
    static ɵfac = function AccordionService_Factory(t) { return new (t || AccordionService)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AccordionService, factory: AccordionService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AccordionService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();

class SocketioService {
    socket;
    eventResponseHandler;
    wfeStepLoaderService;
    config = {
        url: '',
        options: {
            transports: ["websocket"],
            path: ''
        }
    };
    dataSocketDetails = [];
    constructor(socket, eventResponseHandler, wfeStepLoaderService) {
        this.socket = socket;
        this.eventResponseHandler = eventResponseHandler;
        this.wfeStepLoaderService = wfeStepLoaderService;
        setTimeout(() => {
            // console.log("Setting: ", localStorage.getItem('socket_settings'))
            if (localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 0) {
                this.dataSocketDetails = localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 0 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] : [];
                this.dataSocketDetails.forEach((val, index) => {
                    this.socketConnect(val, index);
                });
            }
            else {
                for (let i = this.dataSocketDetails.length; i < 5; i++) {
                    this.socketDisconnect(i);
                }
            }
        }, 200);
    }
    socketConnect(socketDetails, index) {
        this.config['url'] = socketDetails['dataSocketUrl'] ? socketDetails['dataSocketUrl'] : '';
        this.config['options']['transports'] = socketDetails['dataSocketOptions'] && socketDetails['dataSocketOptions']['transports'] ? socketDetails['dataSocketOptions']['transports'] : '';
        this.config['options']['path'] = socketDetails['dataSocketOptions'] && socketDetails['dataSocketOptions']['path'] ? socketDetails['dataSocketOptions']['path'] : '';
        if (typeof this.config === 'object' && this.config !== null && this.config['url'] && this.config['url'] != "") {
            let accessToken = this.returnAccessToken();
            if (accessToken) {
                this.config['options']['auth'] = { token: accessToken };
                this.socket = new Socket(this.config, new ApplicationRef());
                this.socket.on('disconnect', () => {
                    console.log('user disconnected');
                });
                this.socket.on('connect_error', function (err) {
                    if (typeof console !== "undefined" && console !== null) {
                        if (err && typeof (err) == 'string' && err == 'Invalid namespace') {
                            console.warn("Attempted to connect to invalid namespace");
                        }
                        else {
                            try {
                                let errorObj = JSON.parse(err.message);
                                switch (Number(errorObj['status'])) {
                                    case 500:
                                        console.log("Error 500: ", errorObj['message']);
                                        break;
                                    case 401:
                                        console.log("Error 401: ", errorObj['message']);
                                        break;
                                    case 404:
                                        console.log("Error 404: ", errorObj['message']);
                                        break;
                                    case 400:
                                        console.log("Error 400: ", errorObj['message']);
                                        break;
                                    default:
                                        console.log("Error " + errorObj['status'] + ": ", errorObj['message']);
                                        break;
                                }
                            }
                            catch (error) {
                            }
                        }
                    }
                });
            }
        }
    }
    returnAccessToken() {
        const accessToken = `${this.getCookie('headerPayload')}.${this.getCookie('signature')}`;
        return accessToken;
    }
    getCookie(name) {
        const ca = document.cookie.split(';');
        const caLen = ca.length;
        const cookieName = `${name}=`;
        let c;
        for (let i = 0; i < caLen; i += 1) {
            c = ca[i].replace(/^\s+/g, '');
            if (c.indexOf(cookieName) === 0) {
                return c.substring(cookieName.length, c.length);
            }
        }
        return '';
    }
    socketDisconnect(index) {
        this.socket.disconnect();
    }
    ngOnDestroy() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }
    listenToTheSocket(stepId, wfeEventListHandler) {
        // console.log("dataSocketDetails: ",this.dataSocketDetails)
        this.dataSocketDetails.forEach((socketDetails, index) => {
            if (socketDetails['dataSocketUrl'] && socketDetails['dataSocketUrl'] != '') {
                // console.log("socketDetails: ",socketDetails['dataSocketUrl']);   
                this.getMessage(stepId, wfeEventListHandler, socketDetails, index);
            }
        });
    }
    getMessage(stepId, wfeEventListHandler, socketDetails, index) {
        if (!Array.isArray(socketDetails['dataSocketChannel'])) {
            socketDetails['dataSocketChannel'] = [socketDetails['dataSocketChannel']];
        }
        socketDetails['dataSocketChannel'].forEach((channel, number) => {
            this.socket.fromEvent(channel).subscribe((data) => {
                // console.log("Auth Error: ", data)
                // Socket Data Emit on Akita
                const response = {
                    handler: socketDetails['dataSocketHandler'][number],
                    response: data,
                    event_success: true,
                    storageType: localStorage.getItem('storageType'),
                    statusCode: 0
                };
                this.eventResponseHandler.emitAPIDATA(response);
                // Event Callback on Socket Data Emit
                this.wfeStepLoaderService.loadStepById(window['currentStepId'] ? window['currentStepId'] : stepId).subscribe((data) => {
                    let eventList = data.event_list.filter(event => event.event_name === 'OnSocketEmit');
                    if (eventList.length > 0) {
                        for (const event of JSON.parse(JSON.stringify(eventList))) {
                            // console.log("event event: ",event)
                            let socketHandler = event['event_params'][0]['invoke_event_config']['additional_parameters'].filter(function (el) { return el.parameter_type == 'SocketChannel'; }).length > 0 ? event['event_params'][0]['invoke_event_config']['additional_parameters'].filter(function (el) { return el.parameter_type == 'SocketChannel'; })[0].value : '';
                            if (event.isDefault === true && socketHandler === socketDetails['dataSocketHandler'][number]) {
                                // console.log("event event: ",event)
                                wfeEventListHandler.switchEventDisplayType(event, eventList, {}, true);
                            }
                        }
                    }
                });
            });
        });
    }
    static ɵfac = function SocketioService_Factory(t) { return new (t || SocketioService)(i0.ɵɵinject(i1$1.Socket), i0.ɵɵinject(EventResponseHandlerService), i0.ɵɵinject(WfeStepLoaderService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: SocketioService, factory: SocketioService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SocketioService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: i1$1.Socket }, { type: EventResponseHandlerService }, { type: WfeStepLoaderService }], null); })();

function StepRendererComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 3)(1, "div", 4);
    i0.ɵɵelement(2, "div", 5);
    i0.ɵɵelementEnd()();
} }
function StepRendererComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "cee-drawer-renderer", 6);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("stepId", ctx_r0.drawerRenderer == null ? null : ctx_r0.drawerRenderer.data == null ? null : ctx_r0.drawerRenderer.data.stepId)("data", ctx_r0.drawerRenderer == null ? null : ctx_r0.drawerRenderer.data)("rootData", ctx_r0.rootData);
} }
function StepRendererComponent_ng_container_3_section_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "section", 7);
    i0.ɵɵelement(1, "app-block-renderer", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("sub-menu-container ", ctx_r0.hamburgermenuBlockAdditionalParameter["displayPosition"] || "left", "");
    i0.ɵɵpropertyInterpolate1("id", "navblock-", ctx_r0.stepData.tid, "");
    i0.ɵɵattribute("aria-label", ctx_r0.additionalParameter["Aria-Label"] ? ctx_r0.additionalParameter["Aria-Label"] : undefined)("role", ctx_r0.additionalParameter["Aria-Role"]);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("block-0 hamburgermenu hamburgermenu-", ctx_r0.hamburgermenuBlockData.block_id, " hamburgermenu-0");
    i0.ɵɵproperty("stepId", ctx_r0.stepData.tid)("templateId", ctx_r0.templateId)("blockId", ctx_r0.hamburgermenuBlockData)("blockPosition", 0)("rootData", ctx_r0.rootData);
} }
function StepRendererComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, StepRendererComponent_ng_container_3_section_1_Template, 2, 15, "section", 2);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.stepData && ctx_r0.blocksData);
} }
function StepRendererComponent_section_4_app_block_renderer_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "app-block-renderer", 8);
} if (rf & 2) {
    const block_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate4("block-", i_r3, " header header-", block_r2.block_id, " header-", i_r3, " ", ctx_r0.is_bootstrap ? "col-12" : "", "");
    i0.ɵɵproperty("stepId", ctx_r0.stepData.tid)("templateId", ctx_r0.templateId)("blockId", block_r2)("blockPosition", i_r3)("rootData", ctx_r0.rootData);
} }
function StepRendererComponent_section_4_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelement(1, "app-dynamic-renderer", 11);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("cee_loader cee_loader_", ctx_r0.stepId, "");
} }
function StepRendererComponent_section_4_ng_container_3_app_section_renderer_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "app-section-renderer", 13);
} if (rf & 2) {
    const section_r4 = ctx.$implicit;
    const pos_r5 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate3("section-", pos_r5, " block-main-", pos_r5, " ", section_r4.section_style ? ctx_r0.commonUtil.bootstrapColClass(ctx_r0.commonUtil.implodeClassName(section_r4.section_style.bootstrap_class_name), ctx_r0.is_bootstrap, "", ctx_r0.conditionalUtil.evaluteBootstrapCondition(section_r4)) : "", "");
    i0.ɵɵproperty("hidden", ctx_r0.loader.showSection)("templateId", ctx_r0.templateId)("sectionData", section_r4)("stepPosition", pos_r5)("stepId", ctx_r0.stepData.tid)("stepName", ctx_r0.stepData.step_name)("sideBarData", ctx_r0.sideBarData)("rootData", ctx_r0.rootData);
} }
function StepRendererComponent_section_4_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, StepRendererComponent_section_4_ng_container_3_app_section_renderer_1_Template, 1, 13, "app-section-renderer", 12);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.stepData.section)("ngForTrackBy", ctx_r0.trackBySection);
} }
function StepRendererComponent_section_4_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div")(2, "div");
    i0.ɵɵelement(3, "app-progress-bar-renderer", 14);
    i0.ɵɵelementEnd()();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵclassMap(ctx_r0.progressBlock["progress"]["bootstrap_class_name"] ? ctx_r0.progressBlock["progress"]["bootstrap_class_name"] : "col-12");
    i0.ɵɵadvance();
    i0.ɵɵclassMap(ctx_r0.progressBlock["progress"]["custom_class_name"]);
    i0.ɵɵadvance();
    i0.ɵɵproperty("progressBlock", ctx_r0.progressBlock["progress"])("stateIdMap", ctx_r0.progressBlock["steps"])("currentStep", ctx_r0.stepId);
} }
function StepRendererComponent_section_4_app_block_renderer_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "app-block-renderer", 8);
} if (rf & 2) {
    const block_r6 = ctx.$implicit;
    const i_r7 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate4("block-", i_r7, " footer footer-", block_r6.block_id, " footer-", i_r7, " ", ctx_r0.is_bootstrap ? "col-12" : "", "");
    i0.ɵɵproperty("stepId", ctx_r0.stepData.tid)("templateId", ctx_r0.templateId)("blockId", block_r6)("blockPosition", i_r7)("rootData", ctx_r0.rootData);
} }
function StepRendererComponent_section_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "section", 7);
    i0.ɵɵtemplate(1, StepRendererComponent_section_4_app_block_renderer_1_Template, 1, 11, "app-block-renderer", 9)(2, StepRendererComponent_section_4_div_2_Template, 2, 3, "div", 10)(3, StepRendererComponent_section_4_ng_container_3_Template, 2, 2, "ng-container", 1)(4, StepRendererComponent_section_4_ng_container_4_Template, 4, 9, "ng-container", 1)(5, StepRendererComponent_section_4_app_block_renderer_5_Template, 1, 11, "app-block-renderer", 9);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate3("step-body step-", ctx_r0.stepData ? ctx_r0.stepData.tid : "", " ", ctx_r0.stepData && ctx_r0.stepData.step_style ? ctx_r0.commonUtil.implodeClassName(ctx_r0.stepData.step_style.custom_class_name) : "", " ", ctx_r0.is_bootstrap ? "row" : "", "");
    i0.ɵɵpropertyInterpolate1("id", "stepblock-", ctx_r0.stepData ? ctx_r0.stepData.tid : "", "");
    i0.ɵɵattribute("aria-label", ctx_r0.additionalParameter["Aria-Label"] ? ctx_r0.additionalParameter["Aria-Label"] : undefined)("role", ctx_r0.additionalParameter["Aria-Role"]);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.headerBlocksData);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.loader.showSection);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.stepData);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.progressBlock["progress"] && ctx_r0.progressBlock["progress"]["MapToStep"]);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.footerBlocksData);
} }
// if you want to use $ as an alias
const $ = jQuery;
class StepRendererComponent {
    router;
    location;
    route;
    ceeApiService;
    sharedEventsService;
    storageService;
    accordionService;
    titleService;
    idle;
    keepalive;
    wfeStepLoaderService;
    appDataService;
    apiDataService;
    http;
    dialog;
    snackBar;
    locationStrategy;
    loaderService;
    interCEEEmitter;
    metaService;
    socketService;
    eventResponseHandler;
    ceeInitService;
    wfeConditionalExecuter;
    keyValueMap = new Map();
    borrowerIdMap = new Map();
    stepId;
    startSession;
    drawerComponent;
    templateId = '';
    stepDataBody = {};
    blockJsonData = {};
    drawerRenderer = {
        data: {
            stepId: ""
        }
    };
    stepData;
    blocksData = [];
    headerBlocksData = [];
    hamburgermenuBlockData = null;
    hamburgermenuBlockAdditionalParameter = {};
    footerBlocksData = [];
    sequenceData;
    updatedSeqData;
    showLoading = true;
    defaultStepId;
    visible = true;
    stepIsComplete;
    seqArray = [];
    modalStepId;
    modalIds = [];
    rootData = {};
    additionalParameter = {};
    globalParameters = {}; // variable to store the global parameters on step load
    variableObj = {};
    globalPath = localStorage.getItem('ENABLE_AUTO_PREVIEW')?.toLowerCase() == "true" && localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') ? localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') : 'assets/config';
    configBlockPath = '/application_blocks/application_blocks_';
    sessionTimeoutUtil;
    esbRequestBodyUtil;
    flatUnflat;
    wfeEventListHandler;
    applicationStateStore;
    overrideBackButtonValue;
    navigateStepName = false;
    navigateStepNameOnly = false;
    is_bootstrap = false;
    hasOnLeaveEvent = false;
    container_type;
    commonUtil;
    sidemenuUtil;
    conditionalUtil;
    externalRequestResponseUtil;
    setApiCallBackUtil;
    apiConfigPath = 'assets/jsons/api_config.json';
    checkEmpty;
    redirectionUtil;
    progressBlock = {};
    loader = {
        name: 'CEE_LOADER',
        showSection: false
    };
    showStepLoader = false;
    stepLoaderTimeout;
    rbs = [];
    lastRBRendered = false;
    isReloadPage = false;
    modalGenericCssClass = '';
    warnOnMultiTabsMsg = '';
    intervalId;
    stopCacheLoader = () => { };
    enableSubdomainHandling = false;
    sideBarData = {};
    responseResult;
    constructor(router, location, route, ceeApiService, sharedEventsService, storageService, accordionService, titleService, idle, keepalive, wfeStepLoaderService, appDataService, apiDataService, http, dialog, snackBar, locationStrategy, loaderService, interCEEEmitter, metaService, socketService, eventResponseHandler, ceeInitService, wfeConditionalExecuter) {
        this.router = router;
        this.location = location;
        this.route = route;
        this.ceeApiService = ceeApiService;
        this.sharedEventsService = sharedEventsService;
        this.storageService = storageService;
        this.accordionService = accordionService;
        this.titleService = titleService;
        this.idle = idle;
        this.keepalive = keepalive;
        this.wfeStepLoaderService = wfeStepLoaderService;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.http = http;
        this.dialog = dialog;
        this.snackBar = snackBar;
        this.locationStrategy = locationStrategy;
        this.loaderService = loaderService;
        this.interCEEEmitter = interCEEEmitter;
        this.metaService = metaService;
        this.socketService = socketService;
        this.eventResponseHandler = eventResponseHandler;
        this.ceeInitService = ceeInitService;
        this.wfeConditionalExecuter = wfeConditionalExecuter;
        // ******************* Start: To warn user before openning site in multiple tabs **********************
        if (this.globalParameters["CEE_WARN_ON_MULTI_TABS"] && this.globalParameters["CEE_WARN_ON_MULTI_TABS"] != "") {
            this.warnOnMultiTabsMsg = this.globalParameters["CEE_WARN_ON_MULTI_TABS"] ? this.globalParameters["CEE_WARN_ON_MULTI_TABS"] : "Site already opened in another tab, data can be lost! Would you want to continue?";
            if (window.location.origin == localStorage.getItem('domain')) {
                const dialogRef = this.dialog.open(AlertModalComponent, {
                    data: {
                        message: this.warnOnMultiTabsMsg
                    }
                });
                dialogRef.afterClosed().subscribe(result => {
                    if (!result) {
                        this.router.navigateByUrl('/wfe/step/404');
                    }
                });
            }
            else {
                localStorage.setItem('domain', window.location.origin);
            }
            window.onbeforeunload = function () {
                localStorage.removeItem('domain');
                return '';
            };
        }
        // ******************* End: To warn user before openning site in multiple tabs **********************
        this.sessionTimeoutUtil = new SessionTimeoutUtil(idle, keepalive, router, dialog, wfeStepLoaderService, appDataService, apiDataService);
        this.esbRequestBodyUtil = new ESBRequestBodyUtil(apiDataService);
        this.flatUnflat = new FlatUnflat(appDataService);
        this.setApiCallBackUtil = new SetAPICallbackData(apiDataService, appDataService);
        this.externalRequestResponseUtil = new ExternalRequestResponseUtil(http, appDataService, apiDataService, sharedEventsService);
        this.wfeEventListHandler = new WFEEventListHandler(ceeApiService, router, sharedEventsService, interCEEEmitter, wfeStepLoaderService, appDataService, apiDataService, dialog, snackBar, http);
        this.commonUtil = new CommonUtil();
        this.sidemenuUtil = new SidemenuUtil(apiDataService);
        this.checkEmpty = new EmptyUtil();
        this.applicationStateStore = new ApplicationStateStoreUtil(this.appDataService);
        this.conditionalUtil = new ConditionalUtil(false, appDataService, apiDataService);
        this.redirectionUtil = new RedirectionUtil(router);
        if (this.wfeStepLoaderService.rootData && Object.keys(this.wfeStepLoaderService.rootData).length) {
            this.rootData = this.wfeStepLoaderService.rootData;
        }
        if (!Object.keys(this.rootData).length) {
            this.rootData = {};
            this.wfeStepLoaderService.rootData = this.rootData;
            this.rootData['FieldLoadStack'] = {
                add: function () {
                    loaderService.loadingStack++;
                    loaderService.isLoading.next(true);
                },
                remove: function () {
                    loaderService.loadingStack--;
                    if (loaderService.loadingStack === 0) {
                        loaderService.isLoading.next(false);
                    }
                    else {
                        loaderService.isLoading.next(true);
                    }
                }
            };
            this.rootData['sectionFields'] = {};
            this.rootData['blockFields'] = {};
            this.rootData['templateClass'] = '';
            this.rootData['FieldErrorFunctions'] = {};
            this.rootData['ArithmeticNames'] = {};
            this.rootData['_ArithmeticNames'] = {};
        }
        // this.location.onUrlChange(x => this.urlChange(x));
        setTimeout(async () => {
            // ############## Auto Save Handler Data  ##############
            // console.log("###############processBaseJSON###################",this.globalParameters["AutoSaveAPI"],"  ",this.globalParameters["AutoSaveTime"])
            const handler = this.globalParameters["AutoSaveAPI"] ? this.globalParameters["AutoSaveAPI"] : '';
            const timeInterval = this.globalParameters["AutoSaveTime"] ? Number(this.globalParameters["AutoSaveTime"]) : 60; // given in seconds
            if (handler && timeInterval) {
                const appConfigData = await this.http.get(this.apiConfigPath).toPromise();
                const handlerConfig = appConfigData['config'] ? appConfigData['config'].filter((item) => { return (item.id === handler); })[0] : null;
                const accessToken = this.commonUtil.returnAccessToken();
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                }
                if (!handlerConfig['hasAuthorisation'] || (handlerConfig['hasAuthorisation'] && (accessToken && accessToken != "."))) {
                    this.intervalId = setInterval(() => {
                        this.runAutoSaveProcess(handlerConfig);
                    }, timeInterval * 1000);
                    // console.log("Constructor::interval id: ",this.intervalId)
                }
            }
            // ############## Connect to Socket  ##############
            if (localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 0 && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][0]['dataSocketUrl'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][0]['dataSocketUrl'] != "") {
                this.socketService.listenToTheSocket(this.stepId, this.wfeEventListHandler);
            }
        }, 1000);
        this.variableObj['exitWorkflowRes_' + this.stepId] = this.sharedEventsService.exitWorkflowSameStepRedirectEmmiter.subscribe(() => {
            this.setInitData();
        });
        router.events.subscribe((event) => {
            if (event instanceof NavigationEnd) {
                let executeOnLoadEvents = this.router.getCurrentNavigation()?.extras.state?.executeOnLoadEvents;
                if (executeOnLoadEvents) {
                    this.handleStepEvent('onload');
                }
                if (event.id === 1) { // reload page
                    this.isReloadPage = true;
                }
                else { // route navigate(No reload)
                    this.isReloadPage = false;
                }
                window['blockLogs'] = [];
                window['blockDataLogs'] = [];
            }
            else if (event instanceof NavigationStart) {
                // Check if this is actual page navigation, not just hash/fragment change
                const currentUrlWithoutFragment = this.router.url.split('#')[0];
                const targetUrlWithoutFragment = event.url.split('#')[0];
                // Only trigger onunload for actual page changes, not hash navigation
                if (currentUrlWithoutFragment !== targetUrlWithoutFragment) {
                    this.handleStepEvent('onunload');
                }
            }
        });
        this.sharedEventsService.oidcCheckLoginStatusEmitter.subscribe((res) => {
            this.wfeEventListHandler.emitLoginStateDataToStore(res['handler'], { loginStatus: res['loginStatus'] });
            // ########################### OIDC Check Login Status Emitter ##############################
            const OIDCConnect = localStorage.getItem('OIDCConnect');
            const _this = this;
            const ocIntervel = setInterval(() => {
                if (OIDCConnect) {
                    switch (OIDCConnect) {
                        case 'checkloginstatus':
                            // console.log("checkloginstatus: ", apiData);
                            if (res['loginStatus']) {
                                setTimeout(() => {
                                    _this.handleStepEvent('afterOIDCLogin');
                                }, 500);
                            }
                            else {
                                setTimeout(() => {
                                    _this.handleStepEvent('onLoginStatusFalse');
                                }, 500);
                            }
                            // localStorage.removeItem('columnRstructuringConfig');
                            break;
                    }
                }
            }, 100);
        });
        this.sharedEventsService.oidcApiEmitter.subscribe((apiData) => {
            const OIDCConnect = localStorage.getItem('OIDCConnect');
            if (OIDCConnect) {
                localStorage.removeItem('OIDCConnect');
                const _this = this;
                const ocIntervel = setInterval(() => {
                    if (this.stepData) {
                        switch (OIDCConnect) {
                            case 'login':
                                if (apiData && apiData.response && Object.keys(apiData.response).length > 0) {
                                    const LandingStepId = this.getCookie('LandingStepId');
                                    const postUrl = this.getCookie('postUrl');
                                    let route_Id = window.sessionStorage.getItem('CEE_last_route_id');
                                    let primaryFieldData = {
                                        id: route_Id,
                                        editable: false,
                                        visible: false,
                                        mandatory: false,
                                        value: LandingStepId ? 1 : 0,
                                        apiKey: '',
                                        isValid: true,
                                        stepId: this.stepId,
                                        requestApiKey: [],
                                        responseApiKey: []
                                    };
                                    this.appDataService.setAppData(primaryFieldData);
                                    if (LandingStepId) {
                                        this.setCookie('TargetStepId', LandingStepId, 1);
                                        setTimeout(() => {
                                            // console.log("calling  afterOIDCLogin 1 on: ", new Date().toLocaleString());
                                            _this.handleStepEvent('afterOIDCLogin');
                                        }, 500);
                                        localStorage.removeItem('columnRstructuringConfig');
                                        if (!postUrl) {
                                            this.redirectionUtil.redirectTo(LandingStepId);
                                        }
                                        else {
                                            this.redirectionUtil.redirectTo(LandingStepId, null, postUrl);
                                        }
                                        this.deleteCookie('LandingStepId');
                                        this.deleteCookie('postUrl');
                                    }
                                    else {
                                        setTimeout(() => {
                                            // console.log("calling  afterOIDCLogin 2 on: ", new Date().toLocaleString());
                                            _this.handleStepEvent('afterOIDCLogin');
                                        }, 500);
                                        localStorage.removeItem('columnRstructuringConfig');
                                    }
                                }
                                break;
                            case 'checkloginstatus':
                                if (apiData && apiData.response && Object.keys(apiData.response).length > 0) {
                                    const LandingStepId = this.getCookie('LandingStepId');
                                    const postUrl = this.getCookie('postUrl');
                                    if (LandingStepId) {
                                        this.setCookie('TargetStepId', LandingStepId, 1);
                                        setTimeout(() => {
                                            _this.handleStepEvent('afterOIDCLogin');
                                        }, 500);
                                        localStorage.removeItem('columnRstructuringConfig');
                                        if (!postUrl) {
                                            this.redirectionUtil.redirectTo(LandingStepId);
                                        }
                                        else {
                                            this.redirectionUtil.redirectTo(LandingStepId, "_self", postUrl);
                                        }
                                        this.deleteCookie('LandingStepId');
                                        this.deleteCookie('postUrl');
                                    }
                                }
                                break;
                            case 'logininpopup':
                                apiData && apiData.response && Object.keys(apiData.response).length > 0 &&
                                    _this.handleStepEvent('afterOIDCLogin');
                                localStorage.removeItem('columnRstructuringConfig');
                                break;
                            case 'logout':
                                //
                                break;
                            default:
                                break;
                        }
                        clearInterval(ocIntervel);
                    }
                }, 1000);
            }
        });
        this.variableObj['stepLoader_' + this.stepId] = this.sharedEventsService.stepLoaderEmitter.subscribe((data) => {
            if (!this.showStepLoader)
                return;
            if (this.rbs.length == 0)
                return;
            // console.log("- blockId:", data.blockId);
            if (this.stepLoaderTimeout) {
                clearTimeout(this.stepLoaderTimeout);
            }
            this.stepLoaderTimeout = setTimeout(() => {
                this.showStepLoader = false;
            }, 2000);
        });
        this.variableObj['targetStepRedirection_'] = this.sharedEventsService.targetStepRedirection.subscribe(res => {
            if (res?.event_handler.includes('overRideWorkflow')) {
                this.handleStepEvent('onunload');
            }
        });
        //cee core version update process
        const ceeCoreVersion = localStorage.getItem('CEE_CORE_VERSION');
        const ceeCoreVersionOld = localStorage.getItem('CEE_CORE_VERSION_OLD');
        let reloadFlag = false;
        if (ceeCoreVersion && ceeCoreVersionOld && ceeCoreVersion !== ceeCoreVersionOld) {
            localStorage.clear();
            sessionStorage.clear();
            reloadFlag = true;
        }
        ceeCoreVersion && localStorage.setItem('CEE_CORE_VERSION_OLD', ceeCoreVersion);
        if (reloadFlag) {
            window.location.reload();
        }
    }
    /* urlChange(x) {
        console.log(x);
        this.urlChangedManually = false
    } */
    // *************************************************
    // private returnAccessToken() {
    //     const accessToken = `${this.getCookie('headerPayload')}.${this.getCookie('signature')}`
    //     return accessToken;
    // }
    // private getCookie(name: string) {
    //     const ca: Array<string> = document.cookie.split(';');
    //     const caLen: number = ca.length;
    //     const cookieName = `${name}=`;
    //     let c: string;
    //     for (let i = 0; i < caLen; i += 1) {
    //       c = ca[i].replace(/^\s+/g, '');
    //       if (c.indexOf(cookieName) === 0) {
    //         return c.substring(cookieName.length, c.length);
    //       }
    //     }
    //     return '';
    // }
    setCookie(name, value, daysToExpire) {
        // Encode name and value
        let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
        // Set expiration if provided
        if (daysToExpire) {
            const date = new Date();
            date.setTime(date.getTime() + (daysToExpire * 24 * 60 * 60 * 1000));
            cookieString += `; expires=${date.toUTCString()}`;
        }
        // Add security attributes
        cookieString += '; path=/';
        cookieString += '; Secure'; // Only sent over HTTPS
        cookieString += '; SameSite=Strict'; // or 'Lax' if you need some cross-site usage
        // Note: HttpOnly cannot be set via JavaScript - must be set server-side
        // The parameter is included for documentation purposes
        document.cookie = cookieString;
    }
    // setCookie(name: string, value: string, daysToExpire?: number): void {
    //     let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
    //     if (daysToExpire) {
    //         const date = new Date();
    //         date.setTime(date.getTime() + (daysToExpire * 24 * 60 * 60 * 1000));
    //         cookieString += `; expires=${date.toUTCString()}`;
    //     }
    //     cookieString += '; path=/';
    //     document.cookie = cookieString;
    // }
    getCookie(name) {
        const nameEQ = encodeURIComponent(name) + "=";
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            let cookie = cookies[i];
            while (cookie.charAt(0) === ' ') {
                cookie = cookie.substring(1, cookie.length);
            }
            if (cookie.indexOf(nameEQ) === 0) {
                return decodeURIComponent(cookie.substring(nameEQ.length, cookie.length));
            }
        }
        return null;
    }
    deleteCookie(name, path = '/', domain) {
        // Set the cookie expiration to a past date
        const pastDate = new Date(0).toUTCString();
        // Build the cookie string
        let cookieString = `${encodeURIComponent(name)}=; expires=${pastDate}; path=${path}`;
        // Add domain if specified
        if (domain) {
            cookieString += `; domain=${domain}`;
        }
        // Set the cookie
        document.cookie = cookieString;
        // Some browsers require sameSite attribute for proper deletion
        if (typeof document.cookie === 'string' && document.cookie.indexOf(name) >= 0) {
            cookieString += '; sameSite=strict';
            document.cookie = cookieString;
        }
    }
    runAutoSaveProcess(apiConfigData) {
        const response = {
            handler: apiConfigData.handler,
            response: null,
            event_success: true,
            storageType: apiConfigData.storageType,
            statusCode: 0
        };
        // console.log("*****************",apiConfigData)
        this.ceeApiCallingService(apiConfigData).subscribe(res => {
            // console.log("@@@@@@@@@@@@@@@",res);
            this.emitDataToCee(response, res, apiConfigData, true);
        }, error => {
            console.error(`Error Occurred for handler: ${apiConfigData.handler} and ${JSON.stringify(error)}`);
        });
    }
    /**
   * function that emits back the api response for a particular api
   * @param response the response object
   * @param res the response
   * @param isEvent if the handler is called from an event
   * @param success if the api res is success
   */
    emitDataToCee(response, res, apiConfigData, success) {
        response.statusCode = res.status;
        response.response = res.body || res.error;
        response.event_success = success;
        /* ESB API INTIGRATION */
        if (apiConfigData.isESB && response.response.api_response) {
            response.response = JSON.parse(response.response.api_response);
        }
        /* ESB API INTIGRATION (END) */
        if (apiConfigData.isEvent) {
            this.sharedEventsService.eventResponseSubscriber.emit(response);
        }
        else {
            this.eventResponseHandler.emitAPIDATA(response);
        }
    }
    /**
   * CEE internal API Service that hits the api
   * @param apiConfigData the api config data for the handler
   * via internal libraries of CEE
   */
    ceeApiCallingService(apiConfigData) {
        //
        const headers = apiConfigData['headers'] ? apiConfigData['headers'] : {};
        // set header request type
        switch (apiConfigData.requestType) {
            case 'application/json':
            case 'multipart/form-data':
            case 'application/x-www-form-urlencoded':
            case 'text/plain':
                headers['Content-Type'] = apiConfigData.requestType;
                break;
            default:
                console.error(`Invalid request type in returnHeaders: ${apiConfigData.requestType}`);
        }
        let apiURL = apiConfigData.url;
        // set url param
        for (const key of Object.keys(apiConfigData.urlParams)) {
            if (apiURL.includes(`{${key}}`)) {
                apiURL = apiURL.split(`{${key}}`).join(apiConfigData.urlParams[key]);
            }
        }
        // set query param
        for (const key of Object.keys(apiConfigData.queryParams)) {
            if (apiURL.includes(`{${key}}`)) {
                apiURL = apiURL.split(`{${key}}`).join(apiConfigData.queryParams[key]);
            }
        }
        // set request body
        let requestBody = this.formRequestBody(apiConfigData.requestBody, apiConfigData.requestType);
        /* ESB API INTIGRATION */
        if (apiConfigData.isESB) {
            requestBody = {
                api_request: JSON.stringify(requestBody)
            };
        }
        /* ESB API INTIGRATION (END) */
        switch (apiConfigData.methodType.toUpperCase()) {
            case 'POST':
            case 'PUT':
            case 'PATCH':
                return this.http[apiConfigData.methodType.toLowerCase()](apiURL, requestBody, { headers, observe: 'response' });
            case 'DELETE':
            case 'GET':
                return this.http[apiConfigData.methodType.toLowerCase()](apiURL, { headers, observe: 'response' });
        }
    }
    formRequestBody(requestData, type) {
        switch (type) {
            case 'text/plain':
            case 'application/json':
                return requestData;
            case 'multipart/form-data':
                const fd = new FormData();
                for (const key of Object.keys(requestData)) {
                    fd.append(key, requestData[key]);
                }
                return fd;
            case 'application/x-www-form-urlencoded':
                const body = new URLSearchParams();
                for (const key of Object.keys(requestData)) {
                    body.set(key, requestData[key]);
                }
                return body.toString();
            default:
                console.error(`Invalid request type in formRequestBody: ${type}`);
                return {};
        }
    }
    // *************************************************
    get hasUnsavedData() {
        return localStorage.getItem('has_unsaved_data') === 'true' ? true : false;
    }
    get modalOnPageLeave() {
        return localStorage.getItem('modal_on_page_leave') ? localStorage.getItem('modal_on_page_leave') : false;
    }
    // @HostListener('window:beforeunload', ['$event'])
    // unloadNotification($event: any) {
    //     // if (this.globalParameters["externalSitePrompt"] && $event.srcElement.activeElement.localName === 'a') {
    //     //     this.wfeEventListHandler.displayModal({ event_handler: this.globalParameters["externalSitePrompt"] });
    //     //     $event.preventDefault();
    //     //     $event.returnValue = true;
    //     // } else
    //     if (this.hasUnsavedData && this.modalOnPageLeave) {
    //         $event.returnValue = true;
    //     } else { }
    // }
    unloadNotification($event) {
        // Only show dialog if we have unsaved data and modal flag is on
        if (this.hasUnsavedData && this.modalOnPageLeave) {
            // console.log('Showing beforeunload dialog - unsaved data exists');
            // This is the modern standard way to trigger the dialog
            $event.preventDefault();
            // For older browsers
            $event.returnValue = true;
            localStorage.setItem('has_unsaved_data', 'false');
            return true;
        }
        // For all other cases, attempt to prevent the dialog with all known methods
        // console.log('Preventing beforeunload dialog - no unsaved data');
        // Explicitly return null and don't call preventDefault
        return null;
    }
    handleKeyboardEvent(event) {
        if (this.rootData['BindKey'][String(event.key)]) {
            this.rootData['BindKey'][String(event.key)]();
        }
    }
    openDialog(data) {
        this.dialog.open(ModalRendererComponent, { data: { stepId: data.tid }, id: `stepModal-${data.tid}`, panelClass: `stepModal-${data.tid}` });
    }
    onPopState(event) {
        if (this.hasOnLeaveEvent) {
            history.pushState(null, document.title, document.location.toString());
            this.handleStepEvent('onLeave');
        }
        else {
            this.onBackButton();
        }
    }
    onBackButton() {
        if (localStorage.getItem('forceOnBack')) {
            localStorage.removeItem('forceOnBack');
        }
        else if (this.overrideBackButtonValue) {
            history.pushState(null, document.title, document.location.toString());
            this.variableObj['loadStep_' + this.stepId] = this.wfeStepLoaderService.loadStepById(this.overrideBackButtonValue).subscribe((data) => {
                if (data !== undefined && data.display_as_modal === 1) {
                    this.openDialog(data);
                }
            });
        }
        else if (this.modalOnPageLeave && !(this.additionalParameter['OnPageLeaveCheckType'] === 'saved' && !this.hasUnsavedData)) {
            history.pushState(null, document.title, document.location.toString());
            this.variableObj['loadStep_' + this.stepId] = this.wfeStepLoaderService.loadStepById(this.modalOnPageLeave).subscribe((data) => {
                if (data !== undefined && data.display_as_modal === 1) {
                    this.openDialog(data);
                }
            });
        }
        // console.log("onPopState intervalId:",this.intervalId)
        if (this.intervalId && !this.globalParameters["AutoSaveAPI"]) {
            clearInterval(this.intervalId);
        }
        // Uncomment it End
    }
    slugify(value) {
        // https://medium.com/@mhagemann/the-ultimate-way-to-slugify-a-url-string-in-javascript-b8e4a0d849e1
        return value.toString().toLowerCase()
            .replace(/\s+/g, '-');
    }
    getSubdomain(url) {
        try {
            const parsedUrl = new URL(url);
            const hostnameParts = parsedUrl.hostname.split('.');
            // Special handling for localhost
            if (parsedUrl.hostname.includes('localhost') && hostnameParts.length > 1) {
                return hostnameParts[0]; // Return the first part before ".localhost"
            }
            // Standard handling for subdomains
            if (hostnameParts.length > 2) {
                return hostnameParts[0]; // Return the first part (subdomain)
            }
            return ''; // No subdomain found
        }
        catch (error) {
            console.error('Invalid URL', error);
            return '';
        }
    }
    getAgentName() {
        this.enableSubdomainHandling = localStorage.getItem('ENABLE_SUBDOMAIN_HANDLING') === 'true' ? true : false;
        if (this.enableSubdomainHandling == true) {
            const subdomainkey = window.sessionStorage.getItem('CEE_subdomain');
            if (subdomainkey) {
                const subdomain = this.getSubdomain(window.location.href); // Pass a full URL
                // console.log('subdomain***', subdomain);
                // console.log('subdomainkey**', subdomainkey)
                if (subdomainkey.includes('##')) {
                    const valT = {};
                    valT[subdomainkey] = subdomain;
                    valT['handler_name'] = subdomainkey.split('##')[0];
                    const apiData = {
                        id: subdomainkey.split('##')[0],
                        apiUrl: subdomainkey.split('##')[0],
                        apiKey: subdomainkey.split('##')[0],
                        value: valT
                    };
                    this.apiDataService.setApiData(Object.assign({}, apiData));
                }
            }
        }
    }
    ngOnInit() {
        if (this.wfeStepLoaderService.defaultLang) {
            $('html').attr('lang', this.wfeStepLoaderService.defaultLang.replace('/', ''));
        }
        // reset root data
        this.rootData['BindKey'] = {};
        this.rootData['langChanged'] = false; // set the language changed to false
        this.rootData['FieldLoadStack']['count'] = 0;
        this.stepIsComplete = undefined;
        this.navigateStepName = localStorage.getItem('navigateStepName') === 'true' ? true : false;
        this.navigateStepNameOnly = localStorage.getItem('navigateStepNameOnly') === 'true' ? true : false;
        // console.log("&&&&&&&&&&&&&&&&&& Step Render &&&&&&&&&&&&&&&&&&&&&",this.stepId)
        // console.log("%%%%%%%%%%%% intervalId: %%%%%%%%%%%%",this.intervalId)
        if (this.intervalId && !this.globalParameters["AutoSaveAPI"]) {
            clearInterval(this.intervalId);
        }
        if (this.stepId) {
            this.showLoading = true;
            Promise.resolve(this.wfeStepLoaderService.prefetchBaseJSON()).then(() => {
                this.getAgentName();
                this.stepId = this.returnStepId(this.stepId);
                let configCopy = this.wfeStepLoaderService.baseJSONData && this.wfeStepLoaderService.baseJSONData.sidemenu_block ? JSON.parse(JSON.stringify(this.wfeStepLoaderService.baseJSONData.sidemenu_block)) : '';
                if (configCopy) {
                    this.sideBarData = this.sidemenuUtil.setSidemenuBlockStateOnDataEmit({}, configCopy, this.stepId);
                    this.sideBarDataProcess();
                }
                // check if the user is logged in or not
                const userRole = this.apiDataService.getUserRoleValue(this.storageService.getFieldData('UserRole')) || '';
                let stepDataCache = this.wfeStepLoaderService.getStepDataFromCache(this.stepId);
                if (stepDataCache) {
                    if (!this.ceeInitService.appConfigData['SKIP_JSON_LOADER']) {
                        this.loaderService.loadingStack++;
                        this.loaderService.isLoading.next(true);
                        this.stopCacheLoader = () => {
                            setTimeout(() => {
                                this.loaderService.loadingStack--;
                                if (this.loaderService.loadingStack === 0) {
                                    this.loaderService.isLoading.next(false);
                                }
                                else {
                                    this.loaderService.isLoading.next(true);
                                }
                            }, 0);
                        };
                    }
                    this.wfeStepLoaderService.checkUserRoleAccess(userRole, stepDataCache, async (stepData, error) => {
                        this.proceessStepData(stepData, error, userRole);
                    });
                    // setTimeout(() => {  
                    //     this.proceessStepData(stepDataCache, "", userRole);                        
                    // }, 0);
                }
                else {
                    this.stopCacheLoader = () => { };
                    this.wfeStepLoaderService.getWFEStepData(userRole, this.stepId, async (stepData, error) => {
                        this.wfeStepLoaderService.setStepDataInCache(this.stepId, stepData);
                        this.proceessStepData(stepData, error, userRole);
                    });
                }
                this.variableObj['emitApiSuccessRes_' + this.stepId] = this.sharedEventsService.emitApiSuccessResponse.subscribe(res => {
                    this.setGlobalConstantsOnDataEmit(res);
                    this.setProgressBlockStateOnDataEmit(res);
                    let configCopy = this.wfeStepLoaderService.baseJSONData && this.wfeStepLoaderService.baseJSONData.sidemenu_block ? JSON.parse(JSON.stringify(this.wfeStepLoaderService.baseJSONData.sidemenu_block)) : '';
                    if (configCopy) {
                        this.sideBarData = this.sidemenuUtil.setSidemenuBlockStateOnDataEmit(res, configCopy, this.stepId);
                        this.sideBarDataProcess();
                    }
                });
                this.variableObj['emitModalRes_' + this.stepId] = this.sharedEventsService.modelEmitter.subscribe(res => {
                    this.drawerRenderer = res;
                });
                // listen to language change
                this.variableObj['languageChange_' + this.stepId] = this.interCEEEmitter.languageChangeEmitter.subscribe(res => {
                    this.wfeStepLoaderService.stepDataStore = {};
                    this.wfeStepLoaderService.blockDataStore = {};
                    // localStorage.removeItem('stepDataCache');
                    // localStorage.removeItem('lastBlockLoaded');
                    // localStorage.removeItem('blockDataCache');
                    // load only when the language does not match
                    if (this.wfeStepLoaderService.defaultLang !== res) {
                        this.wfeStepLoaderService.defaultLang = res;
                        // fetch the base wfe json
                        // fetch the step
                        // map the message object
                        this.wfeStepLoaderService.loadOnLangChange(this.returnStepId(this.stepId), res).subscribe((result) => {
                            this.wfeStepLoaderService.baseJSONData = result[1];
                            this.wfeStepLoaderService.mapData(userRole, result, async (stepData, error) => {
                                if (error) {
                                    console.error('Step Loading Error', error);
                                    this.router.navigateByUrl('/wfe/step/404');
                                }
                                else {
                                    this.stepData = stepData;
                                    this.headerBlocksData = [];
                                    this.hamburgermenuBlockData = null;
                                    this.footerBlocksData = [];
                                    this.setAdditionalParameterOnStepLoad(this.stepData, res);
                                    this.rootData = { ...this.rootData, ...{ langChanged: true } };
                                    this.handleStepEvent('onload');
                                }
                            });
                        });
                    }
                });
            }).catch(err => {
                console.error('Step Loading Error', err);
                this.router.navigateByUrl('/wfe/step/404');
            });
        }
        const _this = this;
        $(document).off().on('click', "label.col-form-label a:not(.no-popup-link)", function (e) {
            const link = $(this).prop('href');
            const target = $(this).prop('target');
            if (_this.globalParameters["externalSitePrompt"]) {
                e.preventDefault();
                _this.pageLeaveStepId && localStorage.removeItem('page_leave_step_id');
                localStorage.setItem('page_leave_href', link);
                if (target) {
                    localStorage.setItem('page_leave_href_target', target);
                }
                _this.displayModal({ event_handler: _this.globalParameters['externalSitePrompt'] });
            }
        });
        localStorage.setItem('isButtonInvokeApi', '0');
    }
    sideBarDataProcess() {
        if (this.sideBarData && typeof this.sideBarData === 'object' && this.sideBarData !== null && this.sideBarData.sidemenuBlock) {
            this.sideBarData.sidemenuBlock.submenu = this.recusivelyCheckMenuDependency(this.sideBarData?.sidemenuBlock?.submenu);
            // console.log("sidemenuData after>>>>>", this.sideBarData);
            // let customEvent = {
            //     type : "sideBarData",
            //     data : this.sideBarData
            // }
            // this.sharedEventsService.emitToreactEmitter.emit(customEvent);
            sessionStorage.setItem("sideBarData", JSON.stringify(this.sideBarData));
        }
    }
    recusivelyCheckMenuDependency(menuData) {
        if (menuData && menuData.length == 0) {
            return menuData;
        }
        menuData.forEach((menuDataItem, index) => {
            menuData[index]['isVisible'] = true;
            if (menuDataItem && menuDataItem.menu_condition && menuDataItem.menu_condition.length > 0 && menuDataItem.menu_condition[0].query != "") {
                menuData[index]['isVisible'] = this.checkMenuDependency(menuDataItem.menu_condition[0]);
            }
            menuData[index]['submenu'] = this.recusivelyCheckMenuDependency(menuDataItem.submenu);
        });
        return menuData;
    }
    checkMenuDependency(dependencyCondition) {
        return this.wfeConditionalExecuter.evaluateConditionQuery(dependencyCondition.query, dependencyCondition.condition);
    }
    trackBySection(index, item) {
        return item.section_id;
    }
    extractAfterFirstSegment(url) {
        const parts = url.split('/').filter(Boolean); // removes empty strings from "//"
        if (parts.length <= 1)
            return null;
        return '/' + parts.slice(1).join('/');
    }
    /**
     * Traverses the step data tree and builds a hierarchical object representing
     * the structure: step_name -> section_name -> (nested sections) -> fields.
     * While traversing, it also collects all linked_block_id values of fields
     * with field_type "Repeatable Block" into the `rbs` array.
     *
     * @param stepData The step data object containing sections and fields.
     * @returns An object representing the hierarchical tree of the step.
    */
    traverseStepTree(stepData) {
        if (!stepData || !stepData.step_name || !stepData.section) {
            console.warn('Invalid stepData provided');
            return null;
        }
        const stepName = stepData.step_name;
        const tree = {};
        tree[stepName] = {};
        this.rbs = [];
        // Recursive function to process sections and nested sections
        const processSections = (sections, parentNode) => {
            for (const section of sections) {
                const sectionName = section.section_name || `Unnamed Section (${section.section_id})`;
                parentNode[sectionName] = {};
                // Process fields in the current section and
                // Collect block_id for "Repeatable Block", "List-V2" fields
                if (section.fields && Array.isArray(section.fields)) {
                    //parentNode[sectionName]['fields'] = section.fields.map(field => field.field_type || 'Unknown Field Type');
                    const arrRBS = section.fields.filter(field => field.field_type == "Repeatable Block").map(field => field.repeatable_block_configuration.linked_block_id || 'Unknown Block ID');
                    this.rbs = this.rbs.concat(arrRBS);
                    const arrLists = section.fields.filter(field => field.field_type == "List-V2");
                    var arrListBlocks = [];
                    for (let field of arrLists) {
                        // extract default_value from additional_parameters
                        const defaultValue = field.additional_parameters?.find(param => param.parameter_type === 'default_value')?.value;
                        if (defaultValue) {
                            arrListBlocks.push(defaultValue);
                        }
                    }
                    this.rbs = this.rbs.concat(arrListBlocks);
                    // parentNode[sectionName]['rbs'] = arrRBS;
                }
                // Recursively process nested sections
                if (section.sections && Array.isArray(section.sections)) {
                    processSections(section.sections, parentNode[sectionName]);
                }
            }
        };
        // Start processing sections
        processSections(stepData.section, tree[stepName]);
        // console.log('Generated Tree:', JSON.stringify(tree));
        // console.log('Generated Tree:', this.rbs);
        return tree;
    }
    checkurlPresent(inputString) {
        const arr = inputString.split(',');
        const currentUrl = this.router.url;
        let isPresent = arr.some(value => currentUrl.includes(value));
        return isPresent;
    }
    proceessStepData(stepData, error, userRole = "") {
        // const TargetStepId = localStorage.getItem('TargetStepId');
        const TargetStepId = this.getCookie('TargetStepId');
        this.showLoading = false;
        if (stepData && stepData.section) {
            // ########### Support for section within a section ############
            stepData.section.forEach((stepSection, index) => {
                let sectionList = stepData.section.filter((sec) => { return sec.parent_section_id == stepSection.section_id; });
                stepData.section[index]['sections'] = sectionList;
            });
            stepData.section = stepData.section.filter((el) => { return !el.parent_section_id || el.parent_section_id == ''; });
            // ############################################################
        }
        if (stepData && stepData.display_as_modal !== 1) {
            this.wfeStepLoaderService.lastStepRootData = this.rootData;
        }
        if (!this.stepData || this.fixLayout) {
            this.modalGenericCssClass = 'modal-step-' + this.stepId;
            // console.log(error);
            // console.log(!this.getCookie('LandingStepId'));
            if (error) {
                if (TargetStepId && error === "No step found for the given user role.") {
                    this.router.navigateByUrl(this.wfeStepLoaderService.getDefaultStepByRole(userRole));
                }
                else if (this.ceeInitService.appConfigData['CEE_FORCE_LOGIN'] &&
                    !this.getCookie('LandingStepId') && error === "No step found for the given user role.") {
                    if (this.checkurlPresent(this.ceeInitService.appConfigData['CEE_FORCE_LOGIN_URL'])) {
                        let postUrl = this.extractAfterFirstSegment(this.router.url);
                        if (postUrl) {
                            // localStorage.setItem('postUrl', postUrl);
                            this.setCookie('postUrl', postUrl, 1);
                        }
                        // localStorage.setItem('LandingStepId', this.stepId);
                        this.setCookie('LandingStepId', this.stepId, 1);
                    }
                    this.appDataService.removeAllAppData();
                    // localStorage.clear();
                    this.router.navigateByUrl(this.ceeInitService.appConfigData['CEE_FORCE_LOGIN'], {
                        skipLocationChange: true,
                    });
                }
                else if (this.wfeStepLoaderService.baseJSONData && this.wfeStepLoaderService.baseJSONData.step_error) {
                    if (error === "No step found for the given user role." && this.wfeStepLoaderService.baseJSONData.step_error["403"]) {
                        this.wfeEventListHandler.eventConfig({
                            display_step: this.wfeStepLoaderService.baseJSONData.step_error["403"]
                        }, { event_handler: '' });
                    }
                    else if (this.wfeStepLoaderService.baseJSONData.step_error["404"]) {
                        this.wfeEventListHandler.eventConfig({
                            display_step: this.wfeStepLoaderService.baseJSONData.step_error["404"]
                        }, { event_handler: '' });
                    }
                    else {
                        console.error('Step Loading Error', error);
                        this.router.navigateByUrl('/wfe/step/404');
                    }
                }
                else {
                    console.error('Step Loading Error', error);
                    this.router.navigateByUrl('/wfe/step/404');
                }
            }
            else {
                // get step Id
                if (stepData.display_as_modal !== 1) {
                    window['currentModalId'] = '';
                    window['currentStepId'] = stepData.tid;
                    const workflowDetails = this.wfeStepLoaderService.getWorkflowDetails(stepData.tid);
                    if (workflowDetails && workflowDetails?.sequence_id) {
                        window['currentWorkflowId'] = workflowDetails.sequence_id;
                    }
                }
                else {
                    window['currentModalId'] = stepData.tid;
                }
                let currStep = this.stepId;
                let loadStep = true;
                if (stepData.conditional) {
                    if (stepData.dependency_condition.query) {
                        const dependencyCondition = this.conditionalUtil.checkStepDependency(stepData.dependency_condition);
                        if (!dependencyCondition) {
                            // set the current step as completed
                            // const progressBar = this.wfeStepLoaderService.progressBarMap[
                            //     this.wfeStepLoaderService.getWorkflowSequenceIndexFromStep(currStep).sequence];
                            // if (progressBar && progressBar['progress']) {
                            //     this.applicationStateStore.setComplete(progressBar['progress'].progress_bar_id, currStep);
                            // }
                            this.getSequenceIdAndSetData(currStep);
                            this.stepId = this.wfeStepLoaderService.getNextStepInCurrentSequence(currStep);
                            loadStep = false;
                            this.redirectionUtil.redirectTo(this.stepId);
                        }
                    }
                }
                if (loadStep) {
                    // reset Page on leave data
                    if (stepData.display_as_modal === 0) {
                        this.overrideBackButtonValue = null;
                        localStorage.removeItem('has_unsaved_data');
                        localStorage.removeItem('modal_on_page_leave');
                        localStorage.removeItem('page_leave_step_id');
                        localStorage.removeItem('page_leave_href');
                        localStorage.removeItem('page_leave_href_target');
                        localStorage.removeItem('save_handler');
                    }
                    if (localStorage.getItem('is_bootstrap') === 'true') {
                        this.is_bootstrap = true;
                        this.container_type = localStorage.getItem('container_type');
                    }
                    else {
                        this.container_type = 'container-wrapper';
                    }
                    // Set Application Name
                    const WebsiteTitle = this.storageService.getFieldData('WebsiteTitle');
                    if (WebsiteTitle) {
                        this.titleService.setTitle(WebsiteTitle);
                    }
                    else if (stepData.meta_title) {
                        this.titleService.setTitle(stepData.meta_title);
                    }
                    if (stepData.meta_title) {
                        this.metaService.updateTag({ name: 'title', content: stepData.meta_title });
                    }
                    if (stepData.meta_description) {
                        this.metaService.updateTag({ name: 'description', content: stepData.meta_description });
                    }
                    this.stepData = stepData;
                    this.showStepLoader = this.isToShowStepLoader();
                    if (this.showStepLoader) {
                        this.traverseStepTree(stepData);
                    }
                    var timeDelay = 1000;
                    if (this.stepData.display_as_modal === 1) {
                        timeDelay = 10;
                    }
                    /* istanbul ignore next */
                    setTimeout(() => {
                        this.handleStepAction();
                        this.handleStepEvent('onload');
                        this.stopCacheLoader();
                        if (this.isReloadPage) {
                            this.handleStepEvent('OnReload');
                        }
                        this.hasOnLeaveEvent = this.stepData.event_list && this.stepData.event_list.find(i => i.event_name.toLowerCase() === 'onleave') ? true : false;
                        setTimeout(() => {
                            const scrollTarget = localStorage.getItem('scrollTarget');
                            if (scrollTarget) {
                                if (document.getElementById(scrollTarget)) {
                                    document.getElementById(scrollTarget).scrollIntoView({ behavior: 'smooth' });
                                }
                                localStorage.removeItem('scrollTarget');
                            }
                        }, 0);
                        if (this.showStepLoader && this.rbs.length == 0) {
                            // console.log("No RB, so hiding step loader");
                            this.showStepLoader = this.additionalParameter['CEE_ShowModalLoader_Table']?.toLowerCase() === 'true';
                        }
                    }, timeDelay);
                    // get sequence and map progress bar
                    this.progressBlock = this.wfeStepLoaderService.progressBarMap[this.wfeStepLoaderService.getWorkflowSequenceIndexFromStep(currStep).sequence] || {};
                    // store global parameters
                    this.globalParameters = this.wfeStepLoaderService.additionalParameters;
                    this.setGlobalConstantsOnDataEmit();
                    // this.handleStepAction();
                    // this.handleStepEvent();
                    // this.setTemplates();  //deprecated feature
                    if (userRole !== '' && this.startSession !== false) {
                        this.sessionTimeoutUtil.sessionTimeout();
                    }
                    // call the set additional parameter method to set the
                    // additional parameter
                    this.setAdditionalParameterOnStepLoad(stepData, this.wfeStepLoaderService.defaultLang);
                    if (this.additionalParameter['Loader Handler name']) {
                        this.variableObj[this.stepId + '_customSectionLoaderEmitter'] =
                            this.sharedEventsService.customSectionLoaderEmitter.subscribe((res) => {
                                if (this.additionalParameter['Loader Handler name']
                                    .split('|').map(str => str.trim()).includes(res.handlerName)) {
                                    this.loader.showSection = res.loading;
                                }
                            });
                    }
                    // check step valid or not
                    this.variableObj['buttonValidation_' + this.stepId] =
                        this.sharedEventsService.buttonValidationEmitter.pipe(take(1)).subscribe(() => {
                            const oldComplete = this.stepIsComplete;
                            this.stepIsComplete = this.checkValidateANDCheckMandatory({ mandatory: true, valid: true });
                            const progressBar = this.wfeStepLoaderService.progressBarMap[this.wfeStepLoaderService.getWorkflowSequenceIndexFromStep(currStep) ?
                                this.wfeStepLoaderService.getWorkflowSequenceIndexFromStep(currStep).sequence : undefined];
                            if (progressBar && progressBar['progress'] && oldComplete !== this.stepIsComplete) {
                                this.stepIsComplete ?
                                    this.applicationStateStore.setComplete(progressBar['progress'].progress_bar_id, currStep) :
                                    this.applicationStateStore.setIncomplete(progressBar['progress'].progress_bar_id, currStep);
                            }
                        });
                    // bootstrap_class_name configuration
                    if (this.is_bootstrap && this.stepData && this.stepData.step_style && this.stepData.step_style.bootstrap_class_name) {
                        for (let i = 0; i < this.stepData.section.length; i++) {
                            const section = this.stepData.section[i];
                            if (section.section_style && !section.section_style.bootstrap_class_name) {
                                section.section_style.bootstrap_class_name = this.stepData.step_style.bootstrap_class_name;
                            }
                        }
                    }
                    // ############## Auto Save Handler Data  ##############
                    setTimeout(async () => {
                        // console.log("###############Step: processBaseJSON###################",this.additionalParameter["AutoSaveAPI"],"  ",this.additionalParameter["AutoSaveTime"])
                        const handler = this.stepData.step_action.additional_parameters.filter(e => e.parameter_type === "AutoSaveAPI").length > 0 ? this.stepData.step_action.additional_parameters.filter(e => e.parameter_type === "AutoSaveAPI")[0]['value'] : '';
                        const timeInterval = this.stepData.step_action.additional_parameters.filter(e => e.parameter_type === "AutoSaveTime").length > 0 ? this.stepData.step_action.additional_parameters.filter(e => e.parameter_type === "AutoSaveTime")[0]['value'] : 60; // given in seconds
                        if (handler && timeInterval && !this.globalParameters["AutoSaveAPI"]) {
                            const appConfigData = await this.http.get(this.apiConfigPath).toPromise();
                            const handlerConfig = appConfigData['config'] ? appConfigData['config'].filter((item) => { return (item.id === handler); })[0] : null;
                            const accessToken = this.commonUtil.returnAccessToken();
                            if (this.intervalId && !this.globalParameters["AutoSaveAPI"]) {
                                clearInterval(this.intervalId);
                            }
                            if (!handlerConfig['hasAuthorisation'] || (handlerConfig['hasAuthorisation'] && (accessToken && accessToken != "."))) {
                                this.intervalId = setInterval(() => {
                                    this.runAutoSaveProcess(handlerConfig);
                                }, timeInterval * 1000);
                                // console.log("processstepdata::interval id: ",this.intervalId)
                            }
                        }
                    }, 100);
                }
                else {
                    this.stopCacheLoader();
                }
                // Pushing the current URL in history to prevent back button for events
                if (this.hasOnLeaveEvent) {
                    history.pushState(null, document.title, document.location.toString());
                }
                // Predefine Templates configuration
                if (this.is_bootstrap && stepData.template) {
                    const gridClass = [];
                    for (const tGrid of stepData.template) {
                        switch (tGrid.device_type) {
                            case 'web':
                                gridClass.push(this.generateTemplateClass('col-lg-', tGrid.template_id));
                                break;
                            case 'tab':
                                gridClass.push(this.generateTemplateClass('col-md-', tGrid.template_id));
                                break;
                            case 'mobile':
                                gridClass.push(this.generateTemplateClass('col-sm-', tGrid.template_id));
                                break;
                            default:
                                gridClass.push(this.generateTemplateClass('col-', tGrid.template_id));
                                break;
                        }
                    }
                    this.rootData.templateClass = gridClass.join(' ');
                }
                if (stepData.display_as_modal == 1) {
                    this.toggleModalCssClass();
                }
            }
            if (TargetStepId) {
                // localStorage.removeItem('TargetStepId')
                this.deleteCookie('TargetStepId');
            }
        }
    }
    get pageLeaveStepId() {
        return localStorage.getItem('page_leave_step_id') ? localStorage.getItem('page_leave_step_id') : false;
    }
    // special event handler to handle the Display Modal event
    displayModal(handler) {
        let modals = JSON.parse(localStorage.getItem('modals'));
        modals.forEach((modal, i) => {
            if (modal.modalId == handler.event_handler) {
                const dialogRef = this.dialog.open(ModalRendererComponent, { data: { modal: modal }, id: `eventModal-${handler.event_handler}`, panelClass: `eventModal-${handler.event_handler}` });
                this.variableObj['afterClosed_' + this.stepId] = dialogRef.afterClosed().subscribe(result => {
                    // console.log('The dialog ' + modal.modalId + ' was closed.');
                });
            }
        });
    }
    isToShowStepLoader() {
        for (const paramter of this.stepData.step_action.additional_parameters) {
            if (paramter.parameter_type == "CEE_ShowStepLoader" || paramter.parameter_type == "CEE_ShowModalLoader_Table") {
                return paramter.value.toLowerCase() === "true";
            }
        }
        return false;
    }
    async setAdditionalParameterOnStepLoad(stepData, lang = '') {
        this.loaderService.loadingTextSet.next('');
        if (stepData && stepData.step_action && stepData.step_action.additional_parameters && stepData.step_action.additional_parameters.length > 0) {
            const headerBlocksData = [];
            const footerBlocksData = [];
            for (const paramter of stepData.step_action.additional_parameters) {
                this.additionalParameter[paramter.parameter_type] = paramter.value;
                switch (paramter.parameter_type) {
                    case 'stepBlocks':
                        for (const blockId of paramter.value.split('|')) {
                            if (blockId) {
                                const blocks = await this.fetchHeaderFooter(lang, blockId);
                                if (blocks && blocks.block_name && blocks.block_name.toLowerCase() === 'header') {
                                    if (headerBlocksData.findIndex(hBlockData => hBlockData.block_id == blocks.block_id) == -1) {
                                        headerBlocksData.push(blocks);
                                    }
                                }
                                if (blocks && blocks.block_name && blocks.block_name.toLowerCase() === 'hamburgermenu') {
                                    this.hamburgermenuBlockData = blocks;
                                    blocks.additional_parameters.forEach((i) => {
                                        this.hamburgermenuBlockAdditionalParameter[i.parameter_type] = i.value;
                                    });
                                }
                                if (blocks && blocks.block_name && blocks.block_name.toLowerCase() === 'footer') {
                                    if (footerBlocksData.findIndex(fBlockData => fBlockData.block_id == blocks.block_id) == -1) {
                                        footerBlocksData.push(blocks);
                                    }
                                }
                            }
                        }
                        break;
                    case 'URLParameters':
                        this.handleUrlParameters(paramter.value.split('|'));
                        break;
                    case 'OverrideBackButton':
                        history.pushState(null, document.title, document.location.toString());
                        this.overrideBackButtonValue = paramter.value;
                        break;
                    case 'ModalOnPageLeave':
                        localStorage.setItem('modal_on_page_leave', paramter.value);
                        break;
                    case 'OnPageLeaveCheckType':
                        localStorage.setItem('OnPageLeaveCheckType', paramter.value);
                        break;
                    case 'SaveHandler':
                        localStorage.setItem('save_handler', paramter.value);
                        break;
                    case 'WebsiteTitle':
                        this.titleService.setTitle(paramter.value);
                        break;
                    case 'LoaderText':
                        this.loaderService.loadingTextSet.next(paramter.value);
                        break;
                    default:
                        break;
                }
            }
            // rander header and footer          
            if (this.fixLayout) {
                if (JSON.stringify(headerBlocksData) !== JSON.stringify(this.headerBlocksData)) {
                    this.headerBlocksData = headerBlocksData;
                }
                if (JSON.stringify(footerBlocksData) !== JSON.stringify(this.footerBlocksData)) {
                    this.footerBlocksData = footerBlocksData;
                }
            }
            else {
                this.headerBlocksData = headerBlocksData;
                this.footerBlocksData = footerBlocksData;
            }
        }
    }
    /**
     * function to fetch Header Footer
     * @param lang have language of application
     * @param blockId block id that need to load
     */
    async fetchHeaderFooter(lang, blockId) {
        if (!this.blockJsonData[lang]) {
            this.blockJsonData[lang] = {};
        }
        if (this.blockJsonData[lang][blockId]) {
            return this.blockJsonData[lang][blockId];
        }
        else {
            const jsonData = await this.http.get(`${this.globalPath}${lang}${this.configBlockPath}${blockId}.json`).toPromise();
            this.blockJsonData[lang][blockId] = jsonData;
            return jsonData;
        }
    }
    /**
     * function to get class name of template
     * @param classNamePart class name part
     * @param columnType single_column/two_column
     */
    generateTemplateClass(classNamePart, columnType) {
        let resultClass = '';
        switch (columnType) {
            case 'single_column':
                resultClass = classNamePart + '12';
                break;
            case 'two_column':
                resultClass = classNamePart + '6';
                break;
            default:
                resultClass = classNamePart + '12';
                break;
        }
        return resultClass;
    }
    /**
     * function to emit the if the loading is needed to not
     * @param handlerName event handler or external api or api_information
     * @param loading true or false
     */
    showOrHideLoader(handlerName, loading) {
        this.sharedEventsService.customSectionLoaderEmitter.emit({
            handlerName,
            loading
        });
    }
    handleUrlParameters(urlParameters) {
        const array = urlParameters.map((el) => {
            return el.trim();
        });
        this.route.queryParamMap.subscribe(params => {
            for (const param of array) {
                if (params.get(param) !== null) {
                    // save the api data
                    const apiData = {
                        id: param,
                        apiUrl: '',
                        apiKey: param,
                        value: params.get(param)
                    };
                    this.apiDataService.setApiData(Object.assign({}, apiData));
                }
            }
        });
        this.route.paramMap.subscribe(params => {
            for (const param of array) {
                if (params.get(param) !== null) {
                    // save the api data
                    const apiData = {
                        id: param,
                        apiUrl: '',
                        apiKey: param,
                        value: params.get(param)
                    };
                    this.apiDataService.setApiData(Object.assign({}, apiData));
                }
            }
        });
    }
    closeModal(id) {
        this.modalIds.splice(this.modalIds.indexOf(id), 1);
    }
    scrollToSection(blockName) {
        if (!blockName)
            return;
        // Find the element with the matching ID sad
        const targetElement = document.getElementById(blockName);
        if (targetElement) {
            // console.log("Scrolling to:", blockName); 
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
        }
        else {
            console.warn("Element not found:", blockName);
        }
    }
    ngAfterViewInit() {
        this.http.get('./assets/jsons/lender_mapping.json').subscribe({
            next: (response) => {
                if (response && response.result && Array.isArray(response.result)) {
                    this.keyValueMap.clear(); // Clear previous data
                    this.responseResult = response.result;
                    response.result.forEach(obj => {
                        const key = obj.response_value; // Extract response_value as key
                        const value = obj.unique_id; // Extract unique_id as value
                        this.keyValueMap.set(key, value); // Store in Map
                    });
                }
            },
            error: (error) => {
                console.error("Error fetching API data:", error);
            }
        });
        let isScroll = localStorage.getItem('isScroll') === 'true';
        if (isScroll) {
            localStorage.setItem('isScroll', "false");
            setTimeout(() => {
                const startTime = Date.now();
                const maxTime = 180000; // Keep checking for 50 seconds
                const checkInterval = 15000; // Check every 10 seconds
                let lastScrollTop = 0; // Track last scroll position
                const checkAndScroll = () => {
                    //console.log("Checking for target ID...");
                    let borrowerIdEntries = Object.entries(JSON.parse(localStorage.getItem('borrowerIdMap') || '{}'));
                    let keyValueEntries = Object.entries(JSON.parse(localStorage.getItem('keyValueMap') || '{}'));
                    this.borrowerIdMap = new Map(borrowerIdEntries);
                    this.keyValueMap = new Map(keyValueEntries);
                    //console.log("📍 localStorage.getItem('borrowerIdMap')  :", localStorage.getItem('borrowerIdMap'));
                    let lenderData = localStorage.getItem('lender-data');
                    let node = lenderData ? JSON.parse(lenderData) : null;
                    let customEvent = {
                        type: "error_actions",
                        data: node
                    };
                    this.sharedEventsService.emitToreactEmitter.emit(customEvent);
                    localStorage.removeItem('lender-data');
                    if (!node) {
                        //console.warn("No lender data found in localStorage");
                        return;
                    }
                    let finalScrollTarget = null;
                    let mainParentName = node.borrower_id || "";
                    let borrowerIndex = null;
                    const isFieldLevel = localStorage.getItem('isFieldLevel') === 'true';
                    const hasBorrowerId = !!node.borrower_id;
                    // console.log('mainParentName:', mainParentName);
                    // console.log('isFieldLevel:', isFieldLevel);
                    if (!hasBorrowerId && isFieldLevel) {
                        // ✅ Check parent_id from mapping
                        const mappingEntry = this.responseResult.find(entry => entry.response_value === node.api_key);
                        const hasParentId = mappingEntry && !!mappingEntry.parent_id;
                        if (hasParentId) {
                            // console.log("🔁 Field-level edit: Parent ID found. Beginning nested lookup...");
                            // Step 1: Load the block using parent_id
                            this.wfeStepLoaderService.loadBlockByName(mappingEntry.parent_id).subscribe((parentBlockData) => {
                                // console.log("📦 Loaded Parent Block:", parentBlockData);
                                // Step 2: Find the field using mappingEntry.unique_id
                                const targetField = parentBlockData?.block_fields?.find((field) => field.unique_id === mappingEntry.unique_id);
                                if (targetField) {
                                    // console.log("✅ Field matched by unique_id:", targetField);
                                    // Step 3: Extract default_value from additional_parameters
                                    const defaultParam = targetField.additional_parameters?.find(param => param.parameter_type === 'default_value');
                                    const defaultValue = defaultParam?.value;
                                    if (defaultValue) {
                                        // console.log("📍 Found dasdefault_value for child block:", defaultValue);
                                        // console.log("📍 mappingEntry.unique_id:", mappingEntry.unique_id);
                                        // console.log("📍 mappingEntry.parent_id:", mappingEntry.parent_id);
                                        // console.log("📍 node.borrower_id :", node.borrower_id);
                                        borrowerIndex = this.borrowerIdMap.get(mainParentName);
                                        // console.log("📍 borrowerIndex:", borrowerIndex);
                                        // Step 4: Open accordion and load + scrolling
                                        this.accordionService.openMultipleSectionsWithParent(mappingEntry.unique_id, mappingEntry.parent_id, defaultValue, borrowerIndex);
                                        this.loadBlockAndScrollToField(defaultValue, node.api_key, true, borrowerIndex);
                                    }
                                    else {
                                        console.warn("⚠️ No default_value found in additional_parameters of target field.");
                                    }
                                }
                                else {
                                    console.warn(`❌ No field found in parent block '${mappingEntry.parent_id}' matching unique_id: ${mappingEntry.unique_id}`);
                                }
                            });
                            return;
                        }
                        else {
                            // console.log("🚨 Field-level edit with no borrower_id detected, and parent_id exists.");
                            const sectionsToOpen = [mappingEntry.unique_id]; // Dynamically use parent_id
                            this.accordionService.openMultipleSections(sectionsToOpen);
                            //this.scrollWithRetry(mappingEntry.unique_id); 
                            this.loadBlockAndScrollToField(mappingEntry.unique_id, node.api_key, false, 0);
                            return;
                        }
                    }
                    else if (hasBorrowerId && isFieldLevel) {
                        const mappingEntry = this.responseResult.find(entry => entry.response_value === node.api_key);
                        const hasParentId = mappingEntry && !!mappingEntry.parent_id;
                        if (hasParentId) {
                            //  console.log("🔁 Field-level edit: Parent ID found. Beginning nested lookup...");
                            // Step 1: Load the block using parent_id
                            this.wfeStepLoaderService.loadBlockByName(mappingEntry.parent_id).subscribe((parentBlockData) => {
                                //  console.log("📦 Loaded Parent Block:", parentBlockData);
                                // Step 2: Find the field using mappingEntry.unique_id
                                const targetField = parentBlockData?.block_fields?.find((field) => field.unique_id === mappingEntry.unique_id);
                                if (targetField) {
                                    //  console.log("✅ Field matched by unique_id:", targetField);
                                    // Step 3: Extract default_value from additional_parameters
                                    const defaultParam = targetField.additional_parameters?.find(param => param.parameter_type === 'default_value');
                                    const defaultValue = defaultParam?.value;
                                    if (defaultValue) {
                                        // console.log("📍 Found default_value for child block:", defaultValue);
                                        // console.log("📍 mappingEntry.unique_id:", mappingEntry.unique_id);
                                        // console.log("📍 mappingEntry.parent_id:", mappingEntry.parent_id);
                                        // console.log("📍 node.borrower_id :", node.borrower_id);
                                        borrowerIndex = this.borrowerIdMap.get(mainParentName);
                                        //  console.log("📍 borrowerIndex:", borrowerIndex);
                                        // Step 4: Open accordion and load + scrolling
                                        this.accordionService.openMultipleSectionsWithParent(mappingEntry.unique_id, mappingEntry.parent_id, defaultValue, borrowerIndex);
                                        this.loadBlockAndScrollToField(defaultValue, node.api_key, true, borrowerIndex);
                                    }
                                    else {
                                        console.warn("⚠️ No default_value found in additional_parameters of target field.");
                                    }
                                }
                                else {
                                    console.warn(`❌ No field found in parent block '${mappingEntry.parent_id}' matching unique_id: ${mappingEntry.unique_id}`);
                                }
                            });
                            return;
                        }
                    }
                    else {
                        // ✅ Check if borrower_id is present and retrieve borrower_index
                        if (mainParentName && this.borrowerIdMap.has(mainParentName)) {
                            borrowerIndex = this.borrowerIdMap.get(mainParentName);
                            //  console.log(`✅ Borrower ID matched! Borrower Index: ${borrowerIndex}`);
                            // ✅ Retrieve label_info_heading from mapping file
                            if (this.keyValueMap.has(node.blockName)) {
                                let mappedValue = this.keyValueMap.get(node.blockName);
                                // ✅ Append borrowerIndex to mapped value
                                finalScrollTarget = `${mappedValue}-${borrowerIndex}`;
                                //  console.log(`✅ Direct Final Scroll Target: ${finalScrollTarget}`);
                            }
                            if (finalScrollTarget) {
                                this.scrollToSection(finalScrollTarget);
                                return; // ✅ Stop further processing since direct scrolling is handled
                            }
                        }
                        // ✅ Fallback to the existing logic if borrower_id is missing
                        if (!finalScrollTarget) {
                            if (node.blockName && this.keyValueMap.has(node.blockName)) {
                                finalScrollTarget = this.keyValueMap.get(node.blockName);
                                //  console.log("Using default mapped scroll target:", finalScrollTarget);
                                if (finalScrollTarget) {
                                    this.scrollToSection(finalScrollTarget);
                                    return; // ✅ Stop further processing since direct scrolling is handled
                                }
                            }
                            else {
                                console.warn("No valid scroll target found for node:", node.name);
                            }
                        }
                    }
                    if (Date.now() - startTime < maxTime) {
                        //  console.log("❌ Target not stable yet. Retrying in 10 seconds...");
                        setTimeout(checkAndScroll, checkInterval);
                    }
                    else {
                        console.warn("⏳ Timeout reached! Stopping retries.");
                    }
                };
                checkAndScroll(); // Start checking asd
            }, 8000); // Initial 8-second delay
        }
    }
    loadBlockAndScrollToField(uniqueId, apiKey, isFieldLevelWithParent, borrowerIndex) {
        //this.wfeStepLoaderService.loadBlockByName(uniqueId).subscribe((blockData) => {
        this.wfeStepLoaderService.loadBlockByName(uniqueId).subscribe((blockData) => {
            // console.log("📦 Loaded Blo ck Data:", blockData);
            let loadedBlock = blockData;
            // Find the field with the given api_key
            const targetField = loadedBlock?.block_fields?.find(field => field.api_key === apiKey);
            if (targetField) {
                // console.log("🎯 Field matched with API Key:", targetField);
                const scrollTargetId = targetField.unique_id;
                if (isFieldLevelWithParent) {
                    this.scrollWithRetryParent(scrollTargetId, borrowerIndex);
                }
                else {
                    this.scrollWithRetry(scrollTargetId);
                }
            }
            else {
                console.warn(`❌ No field found in block '${uniqueId}' matching api_key: ${apiKey}`);
            }
        }, (error) => {
            console.error(`❌ Error loading block by name (${uniqueId}):`, error);
        });
    }
    scrollWithRetryParent(elementId, borrowerIndex, retries = 30, delay = 3000) {
        if (!elementId)
            return;
        const fullId = `${elementId}$${borrowerIndex}`;
        const allElements = document.querySelectorAll('[id]');
        let target = null;
        allElements.forEach(el => {
            if (el.id.includes(fullId)) {
                target = el;
            }
        });
        if (target) {
            // console.log("✅ Element found, scrolling into view:", target.id);
            this.scrollToSection(target.id); // ✅ Use existing scrolling method
        }
        else if (retries > 0) {
            console.warn(`⏳ Waiting for element containing "${fullId}" to appear. Retries left: ${retries}`);
            setTimeout(() => this.scrollWithRetryParent(elementId, borrowerIndex, retries - 1, delay), delay);
        }
        else {
            console.error(`❌ Element containing "${fullId}" not found after multiple retries.`);
        }
    }
    scrollWithRetry(elementId, retries = 30, delay = 3000) {
        if (!elementId)
            return;
        const target = document.getElementById(elementId);
        if (target) {
            // console.log("✅ Element found,   scrolling into view:", elementId);
            this.scrollToSection(elementId); // ✅ Reuse your existing method
        }
        else if (retries > 0) {
            console.warn(`⏳ Waiting for element "${elementId}" to appear. Retries left: ${retries}`);
            setTimeout(() => this.scrollWithRetry(elementId, retries - 1, delay), delay);
        }
        else {
            console.error(`❌ Element "${elementId}" not found after multiple retries.`);
        }
    }
    ngOnChanges(changes) {
        // load the wfe and call the ngonit if the step gets changed
        // default page rendering
        if (!changes.stepId.currentValue) {
            Promise.resolve(this.wfeStepLoaderService.prefetchBaseJSON()).then(() => {
                const defaultStep = this.wfeStepLoaderService.getDefaultStep();
                if (defaultStep) {
                    window.localStorage.clear();
                    window.location.href = (this.navigateStepName || this.navigateStepNameOnly) ? defaultStep.stepName : `/wfe/step/${defaultStep.tid}`;
                }
            });
        }
        if (changes.stepId.previousValue) {
            if (changes.stepId.currentValue !== changes.stepId.previousValue) {
                this.getSequenceIdAndSetData(this.returnStepId(changes.stepId.currentValue));
                this.setInitData();
            }
        }
    }
    setInitData() {
        this.blocksData = [];
        this.hamburgermenuBlockData = null;
        if (!this.fixLayout) {
            this.stepData = undefined;
            this.headerBlocksData = [];
            this.footerBlocksData = [];
        }
        this.ngOnInit();
    }
    returnStepId(stepId) {
        if (parseInt(stepId)) {
            return stepId;
        }
        else {
            const routeMap = JSON.parse(localStorage.getItem('CEE_ROUTE_MAP'));
            if (this.navigateStepNameOnly && routeMap) {
                return Object.keys(routeMap).find(key => routeMap[key] === stepId);
            }
            else {
                const data = stepId.split('-');
                return data[data.length - 1];
            }
        }
    }
    getSequenceIdAndSetData(stepID) {
        if (stepID) {
            const sequenceId = this.wfeStepLoaderService.getWorkflowSequenceIndexFromStep(stepID).sequence;
            this.setSequenceAndStepId(this.globalParameters['SequenceID'], sequenceId); // setting sequenceId
            this.setSequenceAndStepId(this.globalParameters['StepID'], stepID); // setting current value as per HLD (change on: 15/09/2020)
        }
    }
    setSequenceAndStepId(paramValue, value) {
        if (paramValue && paramValue.includes('$$')) {
            this.setApiData(paramValue.split('$$')[1], value);
        }
    }
    executeSequenceData() {
        for (const seqData in this.sequenceData) {
            if (seqData === 'workflow_progress') {
                for (const workflowData in this.sequenceData[seqData]) {
                    if (workflowData === 'progress_bar_type') {
                        if (this.sequenceData[seqData][workflowData] === 'Default' ||
                            this.sequenceData[seqData][workflowData] === '') {
                            this.visible = false;
                        }
                        else {
                            this.visible = true;
                            // this.updatedSeqData = this.sequenceData;
                            // this.WfeFieldDataService.getSequenceData(this.updatedSeqData);
                        }
                    }
                }
            }
        }
    }
    async handleStepAction() {
        let body = {};
        if (this.stepData && this.stepData.step_action && this.stepData.step_action.api_information) {
            const apiType = localStorage.getItem('API_TYPE');
            switch (apiType) {
                case 'ESB':
                    body = this.esbRequestBodyUtil.getESBRequestBody();
                    this.variableObj['ESBRequestHandler_' + this.stepId] = this.ceeApiService.ESBRequestHandler(this.stepData.step_action.api_information, body).subscribe(res => {
                        if (res['status'] === 'ok') {
                            const appBaseResult = window.sessionStorage.getItem('ApplicationBaseResultPath');
                            let apiResponse = JSON.parse(res['api_response'])[appBaseResult];
                            if (Array.isArray(apiResponse)) {
                                // TODO UNFLATTEn With Class
                            }
                            else {
                                apiResponse = this.flatUnflat.flattenJSON(apiResponse);
                            }
                            this.sharedEventsService.emitApiSuccessResponse.emit(apiResponse);
                        }
                        else {
                            this.sharedEventsService.emitApiErrorResponse.emit(res);
                        }
                    });
                    break;
                case 'INTERNAL':
                case 'EXTERNAL':
                    this.externalRequestResponseUtil.prepareObjectToBeSent(this.stepData.step_action.api_information, apiType === 'INTERNAL' ? 'internal' : '');
                    break;
                default:
                    let appData = [];
                    let apiData = [];
                    // store the appData
                    this.variableObj['getAllAppData_' + this.stepId] = this.appDataService.getAllAppData().subscribe(res => {
                        appData = res;
                    });
                    // store the apiData
                    this.variableObj['getAllApiData_' + this.stepId] = this.apiDataService.getAllApiData().subscribe(res => {
                        // console.log('apiData', res);
                        apiData = res;
                    });
                    const eventHandlerEmitterObject = {
                        handler: this.stepData.step_action.api_information,
                        appData,
                        apiData
                    };
                    this.sharedEventsService.eventHandlerEmitter.emit(eventHandlerEmitterObject);
                    break;
            }
        }
    }
    /**
     * function that sets the global parameters to default value or api response
     * @param res api response if present
     */
    setGlobalConstantsOnDataEmit(res) {
        for (const param of Object.keys(this.globalParameters)) {
            if (param === 'UserRole') {
                continue;
            }
            // Non Pre-defined API Key with and without value
            if (param.includes('##')) {
                const keys = param.includes('|') ? param.split('|').map(str => str.trim()) : [param];
                for (const key of keys) {
                    let val;
                    if (this.globalParameters[param].includes('||')) {
                        const values = this.globalParameters[param].split('||').map(str => str.trim());
                        val = values[0];
                        // remove data at first index
                        values.shift();
                        if (res) {
                            for (const singleVal of values) {
                                const multipleVal = singleVal.split('|').map(str => str.trim());
                                for (const apiKey of multipleVal) {
                                    const apiVal = this.setApiCallBackUtil.setApiCallBackData(apiKey.split('$$')[1], res);
                                    if (apiVal !== null) {
                                        val = apiVal;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        val = this.globalParameters[param].trim();
                    }
                    this.setApiData(key, val);
                }
            }
            else {
                if (this.globalParameters[param] && this.globalParameters[param].includes('##')) {
                    // Pre-defined parameter and value with api key
                    if (this.globalParameters[param].includes('|')) {
                        let val;
                        const multipleValues = this.globalParameters[param].split('|').map(str => str.trim());
                        for (const values of multipleValues) {
                            if (values.includes('##')) {
                                const key = values.includes('$$') ? values.split('$$')[1] : values;
                                // const apiValue = this.setApiCallBackUtil.setApiCallBackData(key,
                                //     this.getValues(values, res));
                                const apiValue = this.setApiCallBackUtil.setApiCallBackData(key, res);
                                if (apiValue !== null) {
                                    val = apiValue;
                                    this.setApiData(key, val);
                                }
                            }
                            else {
                                val = values;
                            }
                        }
                        // set value in the session storage
                        if (val !== undefined) {
                            window.sessionStorage.setItem(param, val);
                        }
                    }
                    else {
                        // Pre-defined Parameter and API Key
                        // set the api key in the session storage
                        if (this.globalParameters[param].includes('$$')) {
                            let apiKey = this.globalParameters[param].split('$$')[1].trim();
                            // check for sub or prn for OIDC
                            if (window.sessionStorage.getItem('CEE_OIDC') === '1' &&
                                window.sessionStorage.getItem('CEE_Token') &&
                                (param === 'CEE_SUB' || param === 'CEE_PRN')) {
                                const tokenHandlerName = window.sessionStorage.getItem('CEE_Token').split('##')[0];
                                apiKey = param === 'CEE_SUB' ? `${tokenHandlerName}##cee_sub` : `${tokenHandlerName}##cee_prn`;
                            }
                            // const val = this.setApiCallBackUtil.setApiCallBackData(
                            //     apiKey, this.getValues(this.globalParameters[param], res));
                            const val = this.setApiCallBackUtil.setApiCallBackData(apiKey, res);
                            this.setApiData(apiKey, val);
                            window.sessionStorage.setItem(param, apiKey);
                        }
                    }
                }
            }
        }
    }
    setApiData(key, val) {
        if (val) {
            const apiData = {
                id: key,
                apiUrl: '',
                apiKey: key,
                value: val
            };
            this.apiDataService.setApiData(Object.assign({}, apiData));
        }
    }
    /**
     * function returns values from api data store and if not present sends the response back
     * @param values the api key
     * @param res the values  from api data store or if not present sends the response back
     */
    getValues(values, res) {
        if (res) {
            const data = this.setApiCallBackUtil.returnValueFromApiStoreUsingHandlerName(values.split('$$')[1].split('##')[0]);
            return data || res;
        }
        return undefined;
    }
    /**
     * to support event list that is configured in the step
     * only supports onLoad Event
     */
    handleStepEvent(eventName) {
        if (this.stepData.event_list && this.stepData.event_list.length > 0) {
            let warningOverwriteLocalDataHandlerArray = this.additionalParameter && this.additionalParameter['WarningOverwriteLocalDataHandler'] ? this.additionalParameter['WarningOverwriteLocalDataHandler'].split('||') : [];
            let dataLossHandlerArray = warningOverwriteLocalDataHandlerArray[0] ? warningOverwriteLocalDataHandlerArray[0].split('|') : [];
            let dataLossWarningMessage = warningOverwriteLocalDataHandlerArray.length > 1 ? warningOverwriteLocalDataHandlerArray[1] : 'Are you sure, locally updated data will be lost!';
            let priventOverwriteLocalDataHandler = this.additionalParameter && this.additionalParameter['PriventOverwriteLocalDataHandler'] ? this.additionalParameter['PriventOverwriteLocalDataHandler'] : '';
            let isOverwriteLocalData = (priventOverwriteLocalDataHandler != '') ? false : true;
            let localDataHandlerArray = [];
            priventOverwriteLocalDataHandler.split('||').forEach(handler => {
                if (handler) {
                    localDataHandlerArray.push(handler.split('##')[0]);
                }
            });
            for (const event of JSON.parse(JSON.stringify(this.stepData.event_list))) {
                let eventHandler = event && event['event_params'].length > 0 && event['event_params'][0]['event_handler'] ? event['event_params'][0]['event_handler'] : '';
                let apiData = this.apiDataService.getApiDataByHandler(eventHandler);
                if (event.isDefault && event.event_name.toLowerCase() === eventName.toLowerCase() && dataLossHandlerArray && dataLossHandlerArray.includes(eventHandler) && apiData) {
                    if (confirm(dataLossWarningMessage) != true) {
                        continue;
                    }
                }
                if (event.isDefault && event.event_name.toLowerCase() === eventName.toLowerCase() && (isOverwriteLocalData || !localDataHandlerArray.includes(eventHandler) || (!isOverwriteLocalData && localDataHandlerArray.includes(eventHandler) && !apiData))) {
                    if (eventName.toLowerCase() === 'onleave') {
                        this.hasOnLeaveEvent = true;
                    }
                    else {
                        this.wfeEventListHandler.switchEventDisplayType(event, this.stepData.event_list);
                    }
                }
            }
        }
    }
    setTemplates() {
        if (this.stepData.template) {
            for (const template of this.stepData.template) {
                if (template.device_type.toLowerCase() === 'web') {
                    this.templateId = template.template_id;
                }
            }
        }
    }
    // check if step is complete
    checkValidateANDCheckMandatory({ mandatory, valid }) {
        const allStepData = this.appDataService.getAllAppStoreData();
        for (const fieldData of allStepData) {
            if (this.stepId === fieldData.stepId) {
                if (mandatory && fieldData.mandatory && this.checkEmpty.isEmpty(fieldData.value)) {
                    return false;
                }
                if (valid && !fieldData.isValid) {
                    return false;
                }
            }
        }
        return true;
    }
    setProgressBlockStateOnDataEmit(res) {
        if (this.wfeStepLoaderService.baseJSONData && this.wfeStepLoaderService.baseJSONData.progress_block) {
            for (const progressBlock of this.wfeStepLoaderService.baseJSONData.progress_block) {
                const result = this.setApiCallBackUtil.setApiCallBackData(progressBlock, res);
                if (result) {
                    const data = JSON.parse(atob(result));
                    this.applicationStateStore.setStateValue(progressBlock.progress_bar_id, data);
                }
            }
        }
    }
    onDestroy() {
        for (const key in this.variableObj) {
            if (this.variableObj[key]) {
                this.variableObj[key].unsubscribe();
            }
        }
        // console.log("interval cleared: ",this.intervalId)
        clearInterval(this.intervalId);
        // this.toggleModalCssClass();
        $(document).off('click');
    }
    ngOnDestroy() {
        for (const key in this.variableObj) {
            if (this.variableObj[key]) {
                this.variableObj[key].unsubscribe();
            }
        }
        // console.log("interval cleared: ",this.intervalId)
        clearInterval(this.intervalId);
        // this.toggleModalCssClass();
        $(document).off('click');
    }
    // Add class to the element with '.cdk-overlay-pane' class selector of a modal.
    toggleModalCssClass() {
        const modalWrapper = window.document.querySelector('.cdk-overlay-pane');
        if (modalWrapper) {
            modalWrapper.classList.toggle('modal-step-wrapper');
            modalWrapper.classList.toggle(this.modalGenericCssClass);
        }
    }
    // all getter and setters go here
    get fixLayout() {
        return localStorage.getItem('fixLayout') === 'true' ? true : false;
    }
    static ɵfac = function StepRendererComponent_Factory(t) { return new (t || StepRendererComponent)(i0.ɵɵdirectiveInject(i11.Router), i0.ɵɵdirectiveInject(i13.Location), i0.ɵɵdirectiveInject(i11.ActivatedRoute), i0.ɵɵdirectiveInject(CeeApiService), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(UserDataHandlerService), i0.ɵɵdirectiveInject(AccordionService), i0.ɵɵdirectiveInject(i1.Title), i0.ɵɵdirectiveInject(i8$1.Idle), i0.ɵɵdirectiveInject(i9$1.Keepalive), i0.ɵɵdirectiveInject(WfeStepLoaderService), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(i9.HttpClient), i0.ɵɵdirectiveInject(i7$1.MatDialog), i0.ɵɵdirectiveInject(i8.MatSnackBar), i0.ɵɵdirectiveInject(i13.LocationStrategy), i0.ɵɵdirectiveInject(LoaderService), i0.ɵɵdirectiveInject(CEEInternalEmitterService), i0.ɵɵdirectiveInject(i1.Meta), i0.ɵɵdirectiveInject(SocketioService), i0.ɵɵdirectiveInject(EventResponseHandlerService), i0.ɵɵdirectiveInject(CeeInitServiceService), i0.ɵɵdirectiveInject(WFEConditionalExecuter)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: StepRendererComponent, selectors: [["app-step-renderer"]], viewQuery: function StepRendererComponent_Query(rf, ctx) { if (rf & 1) {
            i0.ɵɵviewQuery(DrawerComponent, 5);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drawerComponent = _t.first);
        } }, hostBindings: function StepRendererComponent_HostBindings(rf, ctx) { if (rf & 1) {
            i0.ɵɵlistener("beforeunload", function StepRendererComponent_beforeunload_HostBindingHandler($event) { return ctx.unloadNotification($event); }, false, i0.ɵɵresolveWindow)("keypress", function StepRendererComponent_keypress_HostBindingHandler($event) { return ctx.handleKeyboardEvent($event); }, false, i0.ɵɵresolveDocument)("popstate", function StepRendererComponent_popstate_HostBindingHandler($event) { return ctx.onPopState($event); }, false, i0.ɵɵresolveWindow);
        } }, inputs: { stepId: "stepId", startSession: "startSession" }, standalone: true, features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature], decls: 5, vars: 7, consts: [["class", "loader-overlay", 4, "ngIf"], [4, "ngIf"], [3, "id", "class", 4, "ngIf"], [1, "loader-overlay"], [1, "loader-content"], [1, "spinner"], [3, "stepId", "data", "rootData"], [3, "id"], [3, "stepId", "templateId", "blockId", "blockPosition", "rootData"], [3, "stepId", "templateId", "blockId", "blockPosition", "class", "rootData", 4, "ngFor", "ngForOf"], [3, "class", 4, "ngIf"], ["moduleName", "CEE_LOADER"], [3, "hidden", "templateId", "sectionData", "stepPosition", "stepId", "stepName", "sideBarData", "class", "rootData", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "hidden", "templateId", "sectionData", "stepPosition", "stepId", "stepName", "sideBarData", "rootData"], [3, "progressBlock", "stateIdMap", "currentStep"]], template: function StepRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, StepRendererComponent_div_0_Template, 3, 0, "div", 0);
            i0.ɵɵelementStart(1, "main");
            i0.ɵɵtemplate(2, StepRendererComponent_ng_container_2_Template, 2, 3, "ng-container", 1)(3, StepRendererComponent_ng_container_3_Template, 2, 1, "ng-container", 1)(4, StepRendererComponent_section_4_Template, 6, 14, "section", 2);
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            i0.ɵɵproperty("ngIf", ctx.showStepLoader);
            i0.ɵɵadvance();
            i0.ɵɵclassMapInterpolate1("main-body ", ctx.container_type, "");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.drawerRenderer == null ? null : ctx.drawerRenderer.data == null ? null : ctx.drawerRenderer.data.stepId);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.hamburgermenuBlockData);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.stepData || ctx.headerBlocksData || ctx.footerBlocksData);
        } }, dependencies: () => [DynamicRendererComponent, MatDialogModule, DrawerComponent, MatFormFieldModule, MatInputModule, CommonModule, i13.NgForOf, i13.NgIf, ProgressBarRendererComponent, BlockRendererComponent, SectionRendererComponent], styles: [".main-body[_ngcontent-%COMP%]{background-color:#fff;position:relative}.align-center[_ngcontent-%COMP%]{margin:50vh auto;text-align:center}.lds-ripple[_ngcontent-%COMP%]{display:inline-block;position:relative;width:64px;height:64px}.lds-ripple[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{position:absolute;border:4px solid #0071EB;opacity:1;border-radius:50%;animation:_ngcontent-%COMP%_lds-ripple 1s cubic-bezier(0,.2,.8,1) infinite}.lds-ripple[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(2){animation-delay:-.5s}@keyframes _ngcontent-%COMP%_lds-ripple{0%{top:28px;left:28px;width:0;height:0;opacity:1}to{top:-1px;left:-1px;width:58px;height:58px;opacity:0}}.modal[_ngcontent-%COMP%]{display:block;position:fixed;z-index:1;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:#000;background-color:#0006}.modal-content[_ngcontent-%COMP%]{background-color:#fefefe;margin:15% auto;padding:20px;border:1px solid #888;width:80%}.sub-menu-container[_ngcontent-%COMP%]{position:absolute;z-index:9}.sub-menu-container.left[_ngcontent-%COMP%]{top:0}.sub-menu-container.right[_ngcontent-%COMP%]{right:0}.sub-menu-bar[_ngcontent-%COMP%]{width:250px;background-color:#333;color:#fff;height:100vh;position:fixed;clear:both;float:left}.with-sub-menu-bar[_ngcontent-%COMP%]{margin-left:250px;padding:0}.loader-overlay[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:9999}.loader-content[_ngcontent-%COMP%]{background-color:#fff;padding:2rem;border-radius:8px;text-align:center}.spinner[_ngcontent-%COMP%]{border:5px solid #f3f3f3;border-top:5px solid #3498db;border-radius:50%;width:50px;height:50px;animation:_ngcontent-%COMP%_spin 1s linear infinite;margin:0 auto 1rem}@keyframes _ngcontent-%COMP%_spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(StepRendererComponent, [{
        type: Component,
        args: [{ selector: 'app-step-renderer', standalone: true, imports: [DynamicRendererComponent, MatDialogModule, DrawerComponent, MatFormFieldModule, MatInputModule, CommonModule, ProgressBarRendererComponent, forwardRef(() => BlockRendererComponent), forwardRef(() => SectionRendererComponent), forwardRef(() => ProgressBarRendererComponent)], template: "<div *ngIf=\"showStepLoader\" class=\"loader-overlay\">\r\n    <div class=\"loader-content\">\r\n        <div class=\"spinner\"></div>\r\n        <!-- <p>Loading...</p> -->\r\n        <!-- <app-dynamic-renderer moduleName=\"CEE_LOADER\"></app-dynamic-renderer> -->\r\n    </div>\r\n</div>\r\n<main class=\"main-body {{container_type}}\">\r\n    <!-- <app-loading-renderer></app-loading-renderer> -->\r\n     <!-- drawerRenderer -->\r\n    <ng-container *ngIf=\"drawerRenderer?.data?.stepId\">\r\n        <cee-drawer-renderer [stepId]=\"drawerRenderer?.data?.stepId\" [data]=\"drawerRenderer?.data\" [rootData]=\"rootData\"></cee-drawer-renderer>\r\n    </ng-container>\r\n\r\n    <!-- hamburgermenuBlock -->\r\n    <ng-container *ngIf=\"hamburgermenuBlockData\">\r\n        <section [attr.aria-label]=\"additionalParameter['Aria-Label'] ? additionalParameter['Aria-Label'] : undefined\"\r\n            [attr.role]=\"additionalParameter['Aria-Role']\" *ngIf=\"stepData && blocksData\" id=\"navblock-{{stepData.tid}}\"\r\n            class=\"sub-menu-container {{hamburgermenuBlockAdditionalParameter['displayPosition']||'left'}}\">\r\n\r\n            <app-block-renderer [stepId]=\"stepData.tid\" [templateId]=\"templateId\" [blockId]=\"hamburgermenuBlockData\"\r\n                [blockPosition]=\"0\"\r\n                class=\"block-0 hamburgermenu hamburgermenu-{{hamburgermenuBlockData.block_id}} hamburgermenu-0\"\r\n                [rootData]=\"rootData\">\r\n            </app-block-renderer>\r\n        </section>  \r\n    </ng-container>\r\n    <!-- hamburgermenuBlock End -->\r\n    <!-- Sidemenu Blocks -->\r\n    <!-- <ng-container *ngIf=\"sideBarData.sidemenuBlockOn && sideBarData.sidemenuBlock\">\r\n        <section class=\"sub-menu-bar {{sideBarData.sidemenuBlock ? sideBarData.sidemenuBlock ?.side_menu_class: ''}}\">\r\n            <app-sidemenu-bar-renderer [sidemenuBlockElements]=\"sideBarData.sidemenuBlock.submenu\" [sidemenuBlock]=\"sideBarData.sidemenuBlock\"\r\n            [currentStep]=\"stepId\"></app-sidemenu-bar-renderer>{{sideBarData.sidemenuBlock ? 'with-sub-menu-bar': ''}}\r\n        </section>\r\n    </ng-container> -->\r\n    \r\n    <section [attr.aria-label]=\"additionalParameter['Aria-Label'] ? additionalParameter['Aria-Label'] : undefined\"\r\n        [attr.role]=\"additionalParameter['Aria-Role']\" *ngIf=\"stepData || headerBlocksData || footerBlocksData\"\r\n        id=\"stepblock-{{stepData?stepData.tid:''}}\"\r\n        class=\"step-body step-{{stepData?stepData.tid:''}} {{stepData&&stepData.step_style?commonUtil.implodeClassName(stepData.step_style.custom_class_name):''}} {{is_bootstrap?'row':''}}\">\r\n\r\n\r\n        <!-- Header Blocks -->\r\n        <app-block-renderer [stepId]=\"stepData.tid\" [templateId]=\"templateId\" [blockId]=\"block\"\r\n            *ngFor=\"let block of headerBlocksData; index as i\" [blockPosition]=\"i\"\r\n            class=\"block-{{i}} header header-{{block.block_id}} header-{{i}} {{is_bootstrap?'col-12':''}}\"\r\n            [rootData]=\"rootData\">\r\n        </app-block-renderer>\r\n\r\n        <div *ngIf=\"loader.showSection\" class=\"cee_loader cee_loader_{{stepId}}\">\r\n            <app-dynamic-renderer moduleName=\"CEE_LOADER\"></app-dynamic-renderer>\r\n        </div>\r\n        <ng-container *ngIf=\"stepData\">\r\n            <app-section-renderer [hidden]=\"loader.showSection\" [templateId]=\"templateId\" [sectionData]=\"section\"\r\n                [stepPosition]=\"pos\" [stepId]=\"stepData.tid\" [stepName]=\"stepData.step_name\" [sideBarData]=\"sideBarData\"\r\n                *ngFor=\"let section of stepData.section; let pos = index; trackBy: trackBySection;\"\r\n                class=\"section-{{pos}} block-main-{{pos}} {{section.section_style?commonUtil.bootstrapColClass(commonUtil.implodeClassName(section.section_style.bootstrap_class_name), is_bootstrap, '', conditionalUtil.evaluteBootstrapCondition(section)):''}}\"\r\n                [rootData]=\"rootData\">\r\n            </app-section-renderer>\r\n        </ng-container>\r\n        <!-- Progress Blocks -->\r\n        <ng-container *ngIf=\"progressBlock['progress'] && progressBlock['progress']['MapToStep']\">\r\n            <div\r\n                class=\"{{progressBlock['progress']['bootstrap_class_name']?progressBlock['progress']['bootstrap_class_name']:'col-12'}}\">\r\n                <div class=\"{{progressBlock['progress']['custom_class_name']}}\">\r\n                    <app-progress-bar-renderer [progressBlock]=\"progressBlock['progress']\"\r\n                        [stateIdMap]=\"progressBlock['steps']\" [currentStep]=\"stepId\"></app-progress-bar-renderer>\r\n                </div>\r\n            </div>\r\n        </ng-container>\r\n        <!-- Footer Blocks -->\r\n        <app-block-renderer [stepId]=\"stepData.tid\" [templateId]=\"templateId\" [blockId]=\"block\"\r\n            *ngFor=\"let block of footerBlocksData; index as i\" [blockPosition]=\"i\"\r\n            class=\"block-{{i}} footer footer-{{block.block_id}} footer-{{i}} {{is_bootstrap?'col-12':''}}\"\r\n            [rootData]=\"rootData\">\r\n        </app-block-renderer>\r\n    </section>\r\n</main>\r\n", styles: [".main-body{background-color:#fff;position:relative}.align-center{margin:50vh auto;text-align:center}.lds-ripple{display:inline-block;position:relative;width:64px;height:64px}.lds-ripple div{position:absolute;border:4px solid #0071EB;opacity:1;border-radius:50%;animation:lds-ripple 1s cubic-bezier(0,.2,.8,1) infinite}.lds-ripple div:nth-child(2){animation-delay:-.5s}@keyframes lds-ripple{0%{top:28px;left:28px;width:0;height:0;opacity:1}to{top:-1px;left:-1px;width:58px;height:58px;opacity:0}}.modal{display:block;position:fixed;z-index:1;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:#000;background-color:#0006}.modal-content{background-color:#fefefe;margin:15% auto;padding:20px;border:1px solid #888;width:80%}.sub-menu-container{position:absolute;z-index:9}.sub-menu-container.left{top:0}.sub-menu-container.right{right:0}.sub-menu-bar{width:250px;background-color:#333;color:#fff;height:100vh;position:fixed;clear:both;float:left}.with-sub-menu-bar{margin-left:250px;padding:0}.loader-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:9999}.loader-content{background-color:#fff;padding:2rem;border-radius:8px;text-align:center}.spinner{border:5px solid #f3f3f3;border-top:5px solid #3498db;border-radius:50%;width:50px;height:50px;animation:spin 1s linear infinite;margin:0 auto 1rem}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"] }]
    }], () => [{ type: i11.Router }, { type: i13.Location }, { type: i11.ActivatedRoute }, { type: CeeApiService }, { type: SharedEventsServiceService }, { type: UserDataHandlerService }, { type: AccordionService }, { type: i1.Title }, { type: i8$1.Idle }, { type: i9$1.Keepalive }, { type: WfeStepLoaderService }, { type: AppDataService }, { type: ApiDataService }, { type: i9.HttpClient }, { type: i7$1.MatDialog }, { type: i8.MatSnackBar }, { type: i13.LocationStrategy }, { type: LoaderService }, { type: CEEInternalEmitterService }, { type: i1.Meta }, { type: SocketioService }, { type: EventResponseHandlerService }, { type: CeeInitServiceService }, { type: WFEConditionalExecuter }], { stepId: [{
            type: Input
        }], startSession: [{
            type: Input
        }], drawerComponent: [{
            type: ViewChild,
            args: [DrawerComponent]
        }], unloadNotification: [{
            type: HostListener,
            args: ['window:beforeunload', ['$event']]
        }], handleKeyboardEvent: [{
            type: HostListener,
            args: ['document:keypress', ['$event']]
        }], onPopState: [{
            type: HostListener,
            args: ['window:popstate', ['$event']]
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(StepRendererComponent, { className: "StepRendererComponent", filePath: "lib\\components\\step-renderer\\step-renderer.component.ts", lineNumber: 77 }); })();

var stepRenderer_component = /*#__PURE__*/Object.freeze({
    __proto__: null,
    StepRendererComponent: StepRendererComponent
});

function ModalRendererComponent_ng_container_0_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 6)(1, "button", 7);
    i0.ɵɵlistener("click", function ModalRendererComponent_ng_container_0_div_3_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r1.closeDialog()); });
    i0.ɵɵtext(2, "Close");
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("stepModalButtons stepModalButtons-", ctx_r1.data.stepId, "");
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("stepModalClose stepModalClose-", ctx_r1.data.stepId, "");
} }
function ModalRendererComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div", 3);
    i0.ɵɵelement(2, "app-step-renderer", 4);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(3, ModalRendererComponent_ng_container_0_div_3_Template, 3, 6, "div", 5);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("stepModalContent stepModalContent-", ctx_r1.data.stepId, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("stepId", ctx_r1.data.stepId)("startSession", ctx_r1.startSession);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.startSession !== false);
} }
function ModalRendererComponent_ng_template_1_label_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "label", 13);
    i0.ɵɵtext(1, "\u00D7");
    i0.ɵɵelementEnd();
} }
function ModalRendererComponent_ng_template_1_label_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "label", 13);
    i0.ɵɵelement(1, "img", 14);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵpropertyInterpolate1("src", "../../../../assets/images/", ctx_r1.data.modal.closeButtonImgUrl, "", i0.ɵɵsanitizeUrl);
} }
function ModalRendererComponent_ng_template_1_label_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "label");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(ctx_r1.data.modal.modalMessage);
} }
function ModalRendererComponent_ng_template_1_label_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "label", 15);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("innerHTML", ctx_r1.data.modal.modalMessage, i0.ɵɵsanitizeHtml);
} }
function ModalRendererComponent_ng_template_1_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-block-renderer", 16);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("stepId", ctx_r1.stepId)("templateId", ctx_r1.templateId)("blockId", ctx_r1.data.modal.inputFormFields)("blockPosition", "modal")("rootData", ctx_r1.rootData);
} }
function ModalRendererComponent_ng_template_1_div_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "button", 7);
    i0.ɵɵlistener("click", function ModalRendererComponent_ng_template_1_div_12_ng_container_1_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r4); const ctx_r1 = i0.ɵɵnextContext(3); return i0.ɵɵresetView(ctx_r1.closeDialog()); });
    i0.ɵɵtext(2, "Cancel");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("eventModalClose eventModalClose-", ctx_r1.data.modal.modalId, "");
} }
function ModalRendererComponent_ng_template_1_div_12_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-cee-button", 18);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r5 = ctx.$implicit;
    const bi_r6 = ctx.index;
    const ctx_r1 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("field-", bi_r6, "");
    i0.ɵɵproperty("stepId", ctx_r1.stepId)("fieldData", field_r5)("rootData", ctx_r1.rootData)("rowData", ctx_r1.rowData)("mandatoryCondition", ctx_r1.mandatoryCondition)("editableCondition", ctx_r1.editableCondition)("visibleCondition", ctx_r1.visibleCondition);
} }
function ModalRendererComponent_ng_template_1_div_12_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, ModalRendererComponent_ng_template_1_div_12_ng_template_2_ng_container_0_Template, 2, 10, "ng-container", 17);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngForOf", ctx_r1.modalButtons);
} }
function ModalRendererComponent_ng_template_1_div_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 6);
    i0.ɵɵtemplate(1, ModalRendererComponent_ng_template_1_div_12_ng_container_1_Template, 3, 3, "ng-container", 2)(2, ModalRendererComponent_ng_template_1_div_12_ng_template_2_Template, 1, 1, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const buttonsModal_r7 = i0.ɵɵreference(3);
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("eventModalButtons eventModalButtons-", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.data.modal.buttons.length === 0)("ngIfElse", buttonsModal_r7);
} }
function ModalRendererComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div")(1, "div")(2, "div")(3, "h3", 8);
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd()();
    i0.ɵɵelementStart(5, "div", 9);
    i0.ɵɵlistener("click", function ModalRendererComponent_ng_template_1_Template_div_click_5_listener() { i0.ɵɵrestoreView(_r3); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.closeDialog()); });
    i0.ɵɵtemplate(6, ModalRendererComponent_ng_template_1_label_6_Template, 2, 0, "label", 10)(7, ModalRendererComponent_ng_template_1_label_7_Template, 2, 2, "label", 10);
    i0.ɵɵelementEnd()();
    i0.ɵɵelementStart(8, "div", 3);
    i0.ɵɵtemplate(9, ModalRendererComponent_ng_template_1_label_9_Template, 2, 1, "label", 11)(10, ModalRendererComponent_ng_template_1_label_10_Template, 1, 1, "label", 12)(11, ModalRendererComponent_ng_template_1_ng_container_11_Template, 2, 5, "ng-container", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(12, ModalRendererComponent_ng_template_1_div_12_Template, 4, 5, "div", 5);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("event-body ", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("float-left modalTitle modalTitle-", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r1.data.modal.modalTitle);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("float-right modalCloseCrossButton modalTitle-", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !ctx_r1.data.modal.closeButtonImgUrl);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.data.modal.closeButtonImgUrl);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("eventModalContent eventModalContent-", ctx_r1.data.modal.modalId, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !ctx_r1.isHTML(ctx_r1.data.modal.modalMessage));
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.isHTML(ctx_r1.data.modal.modalMessage));
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.data.modal.type == "form");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.startSession !== false);
} }
class ModalRendererComponent {
    dialogRef;
    data;
    autoPreviewConfigPath = localStorage.getItem('ENABLE_AUTO_PREVIEW')?.toLowerCase() == "true" && localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') ? localStorage.getItem('AUTO_PREVIEW_CONFIG_PATH') : 'assets/config';
    configBlockPath = this.autoPreviewConfigPath + '/application_blocks/application_blocks_';
    stepId;
    templateId;
    rootData;
    rowData;
    mandatoryCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    editableCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    visibleCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    startSession;
    modalButtons = [];
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
        if (data.config && data.config.disableClose) {
            dialogRef.disableClose = data.config.disableClose;
        }
        this.startSession = data.startSession;
        if (this.startSession === false) {
            dialogRef.disableClose = true;
        }
        let jsonval = null;
        data.modal && data.modal.buttons.forEach((button, i) => {
            jsonval = {
                field_label: button.label,
                unique_id: "modal_button_" + i,
                is_mandatory: 0,
                is_editable: 1,
                is_display: 1,
                is_conditional_value: 0,
                field_type: "Button",
                validation_messages: [],
                validation_regex: "",
                additional_parameters: [],
                api_key: "",
                request_api_key: "",
                response_api_key: "",
                tooltip: "",
                possible_values: [],
                event_list: button.event_list,
            };
            this.modalButtons.push(jsonval);
        });
    }
    closeDialog() {
        this.dialogRef.close();
    }
    isHTML(value) {
        const regex = /(<([^>]+)>)/ig;
        return regex.test(value);
    }
    toggleModalCssClass(cssclass) {
        const modalWrapper = window.document.querySelector('.cdk-overlay-pane');
        if (modalWrapper) {
            modalWrapper.classList.add('modal-wrapper');
            modalWrapper.classList.add(cssclass);
        }
    }
    static ɵfac = function ModalRendererComponent_Factory(t) { return new (t || ModalRendererComponent)(i0.ɵɵdirectiveInject(i7$1.MatDialogRef), i0.ɵɵdirectiveInject(MAT_DIALOG_DATA)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ModalRendererComponent, selectors: [["lib-modal-renderer"]], hostAttrs: [1, "stepModal"], inputs: { stepId: "stepId", templateId: "templateId", rootData: "rootData", rowData: "rowData" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 3, vars: 2, consts: [["eventModal", ""], ["buttonsModal", ""], [4, "ngIf", "ngIfElse"], ["mat-dialog-content", ""], [3, "stepId", "startSession"], ["mat-dialog-actions", "", 3, "class", 4, "ngIf"], ["mat-dialog-actions", ""], ["mat-button", "", "aria-label", "Select Close", 3, "click"], ["mat-dialog-title", ""], [3, "click"], ["mat-button", "", 4, "ngIf"], [4, "ngIf"], [3, "innerHTML", 4, "ngIf"], ["mat-button", ""], ["alt", "close-button", 3, "src"], [3, "innerHTML"], [1, "modal-form-content", 3, "stepId", "templateId", "blockId", "blockPosition", "rootData"], [4, "ngFor", "ngForOf"], [3, "stepId", "fieldData", "rootData", "rowData", "mandatoryCondition", "editableCondition", "visibleCondition"]], template: function ModalRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, ModalRendererComponent_ng_container_0_Template, 4, 6, "ng-container", 2)(1, ModalRendererComponent_ng_template_1_Template, 13, 19, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        } if (rf & 2) {
            const eventModal_r8 = i0.ɵɵreference(2);
            i0.ɵɵproperty("ngIf", ctx.data.stepId)("ngIfElse", eventModal_r8);
        } }, dependencies: () => [StepRendererComponent, BlockRendererComponent, MatDialogModule, i7$1.MatDialogTitle, i7$1.MatDialogActions, i7$1.MatDialogContent, CeeButtonComponent, CommonModule, i13.NgForOf, i13.NgIf], encapsulation: 2 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ModalRendererComponent, [{
        type: Component,
        args: [{ selector: 'lib-modal-renderer', standalone: true, imports: [forwardRef(() => StepRendererComponent), forwardRef(() => BlockRendererComponent), MatDialogModule, CeeButtonComponent, CommonModule], host: { class: 'stepModal' }, encapsulation: ViewEncapsulation.None, template: "<ng-container *ngIf=\"data.stepId; else eventModal\">\r\n    <div mat-dialog-content class=\"stepModalContent stepModalContent-{{data.stepId}}\">\r\n        <app-step-renderer [stepId]=\"data.stepId\" [startSession]=\"startSession\"></app-step-renderer>\r\n    </div>\r\n    <div mat-dialog-actions class=\"stepModalButtons stepModalButtons-{{data.stepId}}\" *ngIf=\"startSession!==false\">\r\n        <button mat-button class=\"stepModalClose stepModalClose-{{data.stepId}}\" (click)=\"closeDialog()\" aria-label=\"Select Close\">Close</button>\r\n    </div>\r\n</ng-container>\r\n<ng-template #eventModal>\r\n    <div class=\"event-body {{data.modal.modalId}}\">\r\n\r\n        <div>\r\n            <div class=\"float-left modalTitle modalTitle-{{data.modal.modalId}}\">\r\n                <h3 mat-dialog-title>{{data.modal.modalTitle}}</h3>\r\n            </div>\r\n            <div (click)=\"closeDialog()\" class=\"float-right modalCloseCrossButton modalTitle-{{data.modal.modalId}}\">\r\n                <label mat-button *ngIf=\"!data.modal.closeButtonImgUrl\">&times;</label>\r\n                <label mat-button *ngIf=\"data.modal.closeButtonImgUrl\">\r\n\t\t\t\t\t<img alt=\"close-button\" src=\"../../../../assets/images/{{data.modal.closeButtonImgUrl}}\" />\r\n\t\t\t\t</label>\r\n\r\n            </div>\r\n        </div>\r\n\r\n        <div mat-dialog-content class=\"eventModalContent eventModalContent-{{data.modal.modalId}}\">\r\n\r\n            <label *ngIf=\"!isHTML(data.modal.modalMessage)\">{{data.modal.modalMessage}}</label>\r\n            <label *ngIf=\"isHTML(data.modal.modalMessage)\" [innerHTML]=\"data.modal.modalMessage\"></label>\r\n            <ng-container *ngIf=\"data.modal.type == 'form'\">\r\n                <app-block-renderer [stepId]=\"stepId\" [templateId]=\"templateId\" [blockId]=\"data.modal.inputFormFields\" class=\"modal-form-content\" [blockPosition]=\"'modal'\" [rootData]=\"rootData\">\r\n                </app-block-renderer>\r\n            </ng-container>\r\n\r\n        </div>\r\n        <div mat-dialog-actions class=\"eventModalButtons eventModalButtons-{{data.modal.modalId}}\" *ngIf=\"startSession!==false\">\r\n\r\n            <ng-container *ngIf=\"data.modal.buttons.length === 0; else buttonsModal\">\r\n                <button mat-button class=\"eventModalClose eventModalClose-{{data.modal.modalId}}\" (click)=\"closeDialog()\" aria-label=\"Select Close\">Cancel</button>\r\n            </ng-container>\r\n            <ng-template #buttonsModal>\r\n                <ng-container *ngFor=\"let field of modalButtons; index as bi;\">\r\n                    <!-- <button mat-button class=\"eventModalButton eventModalButton-{{data.modal.modalId}}\"\r\n\t\t\t\t\t\t(click)=\"handleButtonEvent(button.event_list)\"\r\n\t\t\t\t\t\t[attr.aria-label]=\"button.label\">{{button.label}}</button> -->\r\n                    <app-cee-button [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" class=\"field-{{ bi }}\" [rowData]=\"rowData\" [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\" [visibleCondition]=\"visibleCondition\">\r\n                    </app-cee-button>\r\n                </ng-container>\r\n\r\n            </ng-template>\r\n\r\n\r\n        </div>\r\n    </div>\r\n</ng-template>" }]
    }], () => [{ type: i7$1.MatDialogRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }], { stepId: [{
            type: Input
        }], templateId: [{
            type: Input
        }], rootData: [{
            type: Input
        }], rowData: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(ModalRendererComponent, { className: "ModalRendererComponent", filePath: "lib\\components\\modal-renderer\\modal-renderer.component.ts", lineNumber: 21 }); })();

class UndoRedo {
    constructor() { }
    historyStack = [];
    currentIndex = -1;
    name = 'StateHistory';
    currentId = 'currentId';
    push(id, values) {
        const obj = {};
        const data = this.getData();
        if (data) {
            if (data[id]) {
                this.historyStack = [];
                this.historyStack = data[id];
            }
        }
        this.historyStack.push(values);
        obj[id] = this.historyStack;
        this.setData(obj);
    }
    forward() {
        // TODO
        // if (this.currentIndex < this.historyStack.length - 1) {
        //     this.currentIndex++;
        //     return this.historyStack[this.currentIndex];
        // }
        // return this.historyStack[this.currentIndex];
    }
    undo(id) {
        if (id === this.getCurrentId()) {
            const obj = {};
            const data = this.getData();
            if (data) {
                if (data[id]) {
                    // this.historyStack = [];
                    const arr = data[id];
                    arr.pop();
                    obj[id] = arr;
                    this.setData(obj);
                }
            }
        }
    }
    undoCurrentId() {
        const id = this.getCurrentId();
        const obj = {};
        const data = this.getData();
        if (data) {
            if (data[id]) {
                // this.historyStack = [];
                const arr = data[id];
                arr.pop();
                obj[id] = arr;
                this.setData(obj);
            }
        }
    }
    getPresentValue(id) {
        const data = this.getData() ? this.getData()[id] : undefined;
        return data ? data[data.length - 1] : null;
    }
    setData(data) {
        let obj = data;
        const prevData = this.getData();
        if (prevData) {
            obj = { ...prevData, ...obj };
        }
        window.sessionStorage.setItem(this.name, btoa(JSON.stringify(obj)));
    }
    getData() {
        const data = window.sessionStorage.getItem(this.name);
        return data !== null ? JSON.parse(atob(data)) : undefined;
    }
    setCurrentId(id) {
        window.sessionStorage.setItem(this.currentId, btoa(id));
    }
    getCurrentId() {
        const currentId = window.sessionStorage.getItem(this.currentId);
        return currentId !== null ? atob(currentId) : null;
    }
    deletById(id) {
        const data = this.getData();
        if (data) {
            const sessionArray = Object.keys(data);
            const newArray = sessionArray.filter(item => {
                return !id.includes(item);
            });
            const obj = {};
            for (const key of newArray) {
                if (data[key] !== undefined) {
                    obj[key] = data[key];
                }
            }
            window.sessionStorage.setItem(this.name, btoa(JSON.stringify(obj)));
        }
    }
    removeAll() {
        window.sessionStorage.removeItem(this.currentId);
        window.sessionStorage.removeItem(this.name);
    }
}

/**
 * TODO: Remove this file and update the code once the associated map comes from the WFE End.
 */
class AssociatedMapUtil {
    name = 'AssociatedMap';
    get() {
        const data = window.sessionStorage.getItem(this.name);
        return data !== null ? JSON.parse(atob(data)) : undefined;
    }
    getAssociatedBlockById(fieldId) {
        const data = this.get();
        let item = '';
        if (data) {
            for (const key of Object.keys(data)) {
                if (data[key].includes(fieldId)) {
                    item = key;
                    break;
                }
            }
        }
        return item;
    }
    set(key, values) {
        const obj = {};
        let data = this.get();
        obj[key] = values;
        let success = false;
        if (data) {
            if (Object.keys(data).length > 0) {
                if (!Object.keys(data).includes(key)) {
                    data = { ...data, ...obj };
                    this.storeData(data);
                    return;
                }
            }
            else {
                success = true;
            }
        }
        else {
            success = true;
        }
        if (success) {
            this.storeData(obj);
        }
    }
    storeData(data) {
        window.sessionStorage.setItem(this.name, btoa(JSON.stringify(data)));
    }
    deleteByIds(ids) {
        const data = this.get();
        if (data) {
            const sessionArray = Object.keys(data);
            const newArray = sessionArray.filter(item => {
                return !ids.includes(item);
            });
            const obj = {};
            for (const key of newArray) {
                if (data[key] !== undefined) {
                    obj[key] = data[key];
                }
            }
            window.sessionStorage.setItem(this.name, btoa(JSON.stringify(obj)));
        }
    }
    deleteAll() {
        window.sessionStorage.removeItem(this.name);
    }
}

class InternalResponseUtil {
    http;
    appDataService;
    apiDataService;
    constructor(http, appDataService, apiDataService) {
        this.http = http;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.flatAndNestUtil = new FlatUnflat(appDataService);
        this.commonUtil = new CommonUtil();
    }
    flatAndNestUtil;
    commonUtil;
    /**
     * this function save field data on response handler
     * so that can consume on field load
     * @required @param handler WFE Event handler
     */
    saveResponseData(stepId) {
        const appStoreData = this.getAppData(stepId);
        this.saveApiData(appStoreData);
    }
    /**
     * function returns an object which is the mapping of the  apiKey and the value in a field.
     */
    getAppData(stepId) {
        let obj = {};
        const appStoreData = this.appDataService.getAllAppStoreData();
        for (const data of appStoreData) {
            if (data.responseApiKey.length > 0 && data.stepId === stepId) {
                for (const key of data.responseApiKey) {
                    if (key) {
                        if (data.dataFormatSeparator) {
                            // tslint:disable-next-line: no-unused-expression
                            ((key.includes(':::')) && (obj = {
                                ...this.checkForDateOrTimePicker(key.split(':::'), data.value.split(data.dataFormatSeparator)), ...obj
                            }));
                        }
                        obj[key] = data.value;
                    }
                }
            }
        }
        return obj;
    }
    checkForDateOrTimePicker(keys, apiValue) {
        const obj = {};
        for (const [index, value] of keys.entries()) {
            obj[value] = apiValue[index] || '';
        }
        return obj;
    }
    saveApiData(data) {
        // console.log(data)
        let obj = {};
        for (const key in data) {
            const value = data[key];
            const handlerName = this.commonUtil.getHandlerName(key);
            if (obj[handlerName]) {
            }
            else {
                const handlerData = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(key));
                obj[handlerName] = handlerData ? JSON.parse(JSON.stringify(handlerData.value)) : {};
            }
            obj[handlerName][key] = value;
        }
        // console.log(obj)
        for (const handlerName in obj) {
            const handlerData = {
                apiKey: '',
                id: handlerName,
                apiUrl: handlerName,
                value: obj[handlerName]
            };
            const isPresent = this.apiDataService.getApiDataByHandler(handlerName);
            if (isPresent) {
                this.apiDataService.updateApiData(Object.assign({}, handlerData));
            }
            else {
                this.apiDataService.addApiData(Object.assign({}, handlerData));
            }
        } // setApiData
    }
    static ɵfac = function InternalResponseUtil_Factory(t) { return new (t || InternalResponseUtil)(i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(AppDataService), i0.ɵɵinject(ApiDataService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: InternalResponseUtil, factory: InternalResponseUtil.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(InternalResponseUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], () => [{ type: i9.HttpClient }, { type: AppDataService }, { type: ApiDataService }], null); })();

class InBuildFunctionsUtil {
    commonUtil;
    constructor() {
        this.commonUtil = new CommonUtil();
    }
    /* Validate for dd/mm/yyyy format */
    ValidateAge(cnf) {
        let result = false;
        if (cnf && cnf.targets && cnf.targets.length === 1 && cnf.variables && Object.keys(cnf.variables).length === 1) {
            const targetAge = cnf.targets[0];
            for (const field_id in cnf.variables) {
                let currentDate = new Date();
                const inputDate = this.commonUtil.adjustTZ(new Date(cnf.variables[field_id]));
                const targetDate = new Date(currentDate.setFullYear(currentDate.getFullYear() - targetAge));
                if (inputDate.getTime() <= targetDate.getTime()) {
                    result = true;
                }
            }
        }
        return result;
    }
    /* Validate for mm/dd/yyyy format */
    ValidateAgeFormat(cnf) {
        // console.log(cnf);        
        let result = false;
        if (cnf && cnf.targets && cnf.targets.length === 1 && cnf.variables && Object.keys(cnf.variables).length === 1) {
            const targetAge = cnf.targets[0];
            for (const field_id in cnf.variables) {
                let currentDate = new Date();
                let setFormat = this.interchangeDateFormat(cnf.variables[field_id]);
                const inputDate = this.commonUtil.adjustTZ(new Date(setFormat));
                const targetDate = new Date(currentDate.setFullYear(currentDate.getFullYear() - targetAge));
                if (inputDate.getTime() <= targetDate.getTime()) {
                    result = true;
                }
            }
        }
        return result;
    }
    interchangeDateFormat(dateString) {
        // let [day, month, year] = dateString.split('/');
        // let newDateString = `${month}/${day}/${year}`;
        // return newDateString;
        return moment__default(dateString, 'DD/MM/YYYY').format('MM/DD/YYYY');
    }
    ScrolledToBottom(cnf) {
        return new Promise(function (myResolve) {
            if (cnf && cnf.targets && cnf.targets.length === 1) {
                const targetQuery = cnf.targets[0];
                setTimeout(() => {
                    const targetElement = document.querySelector(targetQuery);
                    if (targetElement) {
                        if (targetElement.scrollHeight <= targetElement.offsetHeight) {
                            myResolve(true);
                        }
                        else {
                            targetElement.addEventListener("scroll", (e) => {
                                if (e.target.offsetHeight + e.target.scrollTop >= e.target.scrollHeight - 10) {
                                    myResolve(true);
                                }
                            });
                        }
                    }
                    else {
                        myResolve(false);
                    }
                }, 0);
            }
            else {
                myResolve(false);
            }
        });
    }
    static ɵfac = function InBuildFunctionsUtil_Factory(t) { return new (t || InBuildFunctionsUtil)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: InBuildFunctionsUtil, factory: InBuildFunctionsUtil.ɵfac, providedIn: 'any' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(InBuildFunctionsUtil, [{
        type: Injectable,
        args: [{
                providedIn: 'any',
            }]
    }], () => [], null); })();

class WFEEventListHandler {
    ceeApiService;
    router;
    sharedEventsServices;
    internalCEEEmitter;
    wfeStepLoaderService;
    appDataService;
    apiDataService;
    dialog;
    snackBar;
    http;
    fileUploadService;
    event_list = [];
    inputDetails = {};
    success = [];
    failure = [];
    response = [];
    exception = [];
    commonUtil;
    undoRedoUtil;
    associatedMaputil;
    externalRequestResponseUtil;
    internalResponseUtil;
    additionalParameters = [];
    esbRequestBodyUtil;
    wfeConditionalQueryExecuter;
    sessionKeyUtil;
    repeatableBlockUtil;
    emptyUtil;
    redirectionUtil;
    applicationStateStore;
    apiKeyUtil;
    downloadType = '';
    workflowService;
    // cell data to store a specific cell within list or table
    cellAppData = {
        id: '',
        stepId: '',
        apiKey: '',
        fieldLabel: '',
        linkedBlockId: '',
        isRepeatedField: false,
        repeatedBlockFieldId: '',
        requestApiKey: [],
        responseApiKey: [],
        dataFormatSeparator: '',
        mandatory: false,
        editable: false,
        visible: false,
        value: '',
        isValid: true
    };
    apiConfigPath = 'assets/jsons/api_config.json';
    event = {}; // for file service call
    payLoad; // for file service call/setting the language
    modalGenericCssClass = '';
    fileDataArray = [];
    encriptedFileArray = [];
    fieldData = {};
    uniqueFields = [];
    inBuildFunctionsUtil;
    modelValue = -1;
    eventAdditionalParams = [];
    setAPIKeyUtil;
    handlerSaveData = {};
    isClear = false;
    constructor(ceeApiService, router, sharedEventsServices, internalCEEEmitter, wfeStepLoaderService, appDataService, apiDataService, dialog, snackBar, http, fileUploadService) {
        this.ceeApiService = ceeApiService;
        this.router = router;
        this.sharedEventsServices = sharedEventsServices;
        this.internalCEEEmitter = internalCEEEmitter;
        this.wfeStepLoaderService = wfeStepLoaderService;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.dialog = dialog;
        this.snackBar = snackBar;
        this.http = http;
        this.fileUploadService = fileUploadService;
        this.esbRequestBodyUtil = new ESBRequestBodyUtil(apiDataService);
        this.wfeConditionalQueryExecuter = new WFEConditionalExecuter(appDataService, apiDataService);
        this.sessionKeyUtil = new SessionKeyUtil();
        this.commonUtil = new CommonUtil();
        this.repeatableBlockUtil = new RepeatableBlockData();
        this.undoRedoUtil = new UndoRedo();
        this.associatedMaputil = new AssociatedMapUtil();
        this.externalRequestResponseUtil = new ExternalRequestResponseUtil(http, appDataService, apiDataService, sharedEventsServices);
        this.internalResponseUtil = new InternalResponseUtil(http, appDataService, apiDataService);
        this.emptyUtil = new EmptyUtil();
        this.redirectionUtil = new RedirectionUtil(router);
        this.applicationStateStore = new ApplicationStateStoreUtil(this.appDataService);
        this.apiKeyUtil = new APIKeyUtil();
        this.workflowService = new RepeatableworkflowHandler();
        this.inBuildFunctionsUtil = new InBuildFunctionsUtil();
        this.setAPIKeyUtil = new SetAPICallbackData(apiDataService);
    }
    switchEventDisplayType(event, eventList, primaryData = {}, payLoad) {
        this.event = event;
        this.payLoad = payLoad;
        // Set whole event list data for future use
        this.event_list = eventList;
        // console.log(event)
        // Function to switch between display type step, framework and workflow
        switch (event.display_type) {
            case 'StartRepeatableWorkflow':
                this.onStartRepeatableWorkflowEvent(event);
                break;
            case 'ExitRepeatableWorkflow':
                this.onExitRepeatableWorkflowEvent(event);
                break;
            case 'Workflow':
                this.onWorkflowEvent(event);
                break;
            // Download CSV event is same as the Framework just the difference is
            // that when this event is triggered user will be able to download the file
            // according to Display Type (now only supported Download CSV)
            case 'Download CSV':
            case 'Framework':
                if (event.display_type === 'Download CSV') {
                    this.downloadType = 'csv';
                }
                this.onFrameworkEvent(event, primaryData);
                break;
            case 'Functions':
            case 'Step':
                this.onStepEvent(event);
                break;
            case 'OnBack':
                history.go(-2);
                localStorage.setItem('forceOnBack', 'true');
                break;
            case 'OnLeave':
                if (!this.pageLeaveHref && !this.pageLeaveHrefTarget) {
                    //get all fieldIds
                    let fieldIds = [];
                    const appStoreData = this.appDataService.getAllAppStoreData();
                    for (const data of appStoreData) {
                        if (data.stepId === window['currentStepId']) {
                            fieldIds.push(data.id);
                        }
                    }
                    this.switchClearenceType({ 'field': fieldIds }, { invoke_event_config: { callback_config: [] } });
                }
                localStorage.removeItem('modal_on_page_leave');
                this.dialog.closeAll();
                if (this.pageLeaveStepId) {
                    this.redirectTo(this.pageLeaveStepId);
                }
                else if (this.pageLeaveHref) {
                    this.redirectToHref(this.pageLeaveHref, null, this.pageLeaveHrefTarget);
                }
                else {
                    history.go(-2);
                    localStorage.setItem('forceOnBack', 'true');
                }
                break;
            case 'LastKnownStep':
                this.redirectToLastSavedStep();
                break;
            // On filter function that will check if the data is found
            // payload should return true
            // if true then trigger onSuccess or trigger OnFailure
            case 'OnFilter':
                // checking payload not undefined
                // will trigger the OnFilter only when the filter is
                // needed
                if (payLoad !== undefined) {
                    this.onFilter(event, payLoad);
                }
                break;
            /*
        case 'ScrollToTop':
            window.scrollTo({ top: 0, behavior: 'smooth' });
            break; */
        }
        if (event['next_event_id']) {
            this.executeEvent(event['next_event_id']);
        }
    }
    // function that only triggers onFailure or OnSuccess
    // check the condition as well if condition is given
    onFilter(event, filterSuccess) {
        for (const eventParam of event.event_params) {
            // store the failure and success response
            if (eventParam.invoke_event_config && eventParam.invoke_event_config.callback_config) {
                this.success = eventParam.invoke_event_config.callback_config.OnSuccess;
                this.failure = eventParam.invoke_event_config.callback_config.onFailure;
                this.additionalParameters = eventParam.invoke_event_config.additional_parameters;
            }
            // check if there is condition it or not
            // and check if the filter success is true
            let passed = false;
            if (this.eventCondition(eventParam.condition)) {
                if (this.wfeConditionalQueryExecuter.evaluateConditionQuery(eventParam.query, eventParam.condition, '', {}, this.fieldData)) {
                    passed = true;
                }
            }
            else {
                passed = true;
            }
            if (passed && filterSuccess) {
                this.triggerSuccessOrFailure(this.success);
            }
            else {
                this.triggerSuccessOrFailure(this.failure, false);
            }
        }
    }
    redirectToLastSavedStep() {
        const sequence = this.apiDataService.getApiDataByApiKey(this.wfeStepLoaderService.additionalParameters['SequenceID'].split('$$')[1]);
        const step = this.apiDataService.getApiDataByApiKey(this.wfeStepLoaderService.additionalParameters['StepID'].split('$$')[1]);
        if (sequence && sequence.value && step && step.value) {
            const progressBar = this.wfeStepLoaderService.progressBarMap[sequence.value];
            if (progressBar && progressBar['progress']) {
                this.applicationStateStore.setProgressStatusOnLastSavedState(progressBar['progress'].progress_bar_id, step.value, progressBar);
                // According to the discussion on 16/09/2020 user will navigate to the step that comes from the backend
                // this.redirectTo(this.wfeStepLoaderService.getNextStepInCurrentSequence(step.value));
                this.redirectTo(step.value);
            }
        }
    }
    onComponentEventBatch(fieldData, presetData, stepId, type, primaryData = {}, isDefault = true, payLoad, displayType = '') {
        this.isClear = type === 'clear' ? true : false;
        if (!this.isClear) {
            for (const event of JSON.parse(JSON.stringify(fieldData.event_list))) {
                if (event.isDefault === isDefault &&
                    event.event_name.toLowerCase() === type.toLowerCase() &&
                    (displayType ? event.display_type.toLowerCase() === displayType.toLowerCase() : true)) {
                    this.setNextStepId(event, stepId);
                    window['eventElementId'] = fieldData.html_id;
                    if (presetData && presetData.repeatedBlockFieldId) {
                        primaryData = {
                            ...primaryData,
                            value: {
                                ...primaryData.value,
                                linkedBlockId: presetData.linkedBlockId,
                                position: presetData.position,
                                parentPosition: presetData.parentPosition,
                                unique_id: presetData.unique_id,
                                isRepeatable: true
                            }
                        };
                    }
                    this.switchEventDisplayType(event, fieldData.event_list, primaryData, payLoad);
                }
            }
        }
    }
    setNextStepId(event, stepId) {
        for (const eventParam of event.event_params) {
            if (eventParam.invoke_event_config && eventParam.invoke_event_config.callback_config && eventParam.invoke_event_config.callback_config.onResponse) {
                for (const onRes of eventParam.invoke_event_config.callback_config.onResponse) {
                    if (onRes.NavigatetoNextPage) {
                        onRes.NavigatetoNextPage = this.wfeStepLoaderService.getNextStepInCurrentSequence(stepId);
                    }
                }
            }
        }
    }
    onStartRepeatableWorkflowEvent(event) {
        for (const eventParams of event.event_params) {
            if (eventParams.invoke_event_config) {
                let redirectTo = true;
                if (this.eventCondition(eventParams.condition)) {
                    if (!this.wfeConditionalQueryExecuter.evaluateConditionQuery(eventParams.query, eventParams.condition)) {
                        redirectTo = false;
                        break;
                    }
                }
                if (redirectTo) {
                    const repeatableWorkflowId = eventParams.event_config.display_step;
                    const currentworkflowId = window['currentWorkflowId'];
                    this.additionalParameters = eventParams.invoke_event_config.additional_parameters;
                    let currentWorkflowIndex = 0;
                    const currentIndex = eventParams.invoke_event_config.additional_parameters
                        .find(i => i.parameter_type === 'workflow_current_index');
                    // workflow_current_index = always start from 0.
                    if (currentIndex) {
                        currentWorkflowIndex = currentIndex.value;
                    }
                    const repeatCountStatic = eventParams.invoke_event_config.additional_parameters
                        .find(i => i.parameter_type === 'repeat_count_static');
                    if (repeatCountStatic) {
                        this.workflowService
                            .initConfig(repeatableWorkflowId, currentWorkflowIndex, repeatCountStatic.value, currentworkflowId);
                    }
                    const repeatCountField = eventParams.invoke_event_config.additional_parameters
                        .find(i => i.parameter_type === 'repeat_count_field_id');
                    if (repeatCountField) {
                        const fieldData = this.appDataService.getFieldDataByFieldId(repeatCountField.value);
                        this.workflowService
                            .initConfig(repeatableWorkflowId, currentWorkflowIndex, fieldData, currentworkflowId);
                    }
                    const repeatCountApiKey = eventParams.invoke_event_config.additional_parameters
                        .find(i => i.parameter_type === 'repeat_count_api_key');
                    if (repeatCountApiKey) {
                        // tslint:disable-next-line: max-line-length
                        const apiDataCount = this.apiDataService.getApiDataByHandler(this.commonUtil.getHandlerName(repeatCountApiKey.value));
                        // tslint:disable-next-line: max-line-length
                        this.workflowService.initConfig(repeatableWorkflowId, currentWorkflowIndex, apiDataCount.value[repeatCountApiKey.value], currentworkflowId);
                    }
                    setTimeout(() => {
                        this.wfeStepLoaderService.setSequenceProgressInit(repeatableWorkflowId);
                        this.redirectTo(this.wfeStepLoaderService.getFirstStepInSquence(this.wfeStepLoaderService.getSequenceDefaultStepIdBySequenceId(repeatableWorkflowId).sequence));
                    }, 500);
                }
            }
        }
    }
    onExitRepeatableWorkflowEvent(event) {
        for (const eventParams of event.event_params) {
            if (eventParams.invoke_event_config) {
                let redirectTo = true;
                if (this.eventCondition(eventParams.condition)) {
                    if (!this.wfeConditionalQueryExecuter.evaluateConditionQuery(eventParams.query, eventParams.condition)) {
                        redirectTo = false;
                        break;
                    }
                }
                const currentworkflowId = window['currentWorkflowId'];
                const repatableWorkflowConfig = this.workflowService.getConfigByWorkflowId(currentworkflowId);
                if (repatableWorkflowConfig) {
                    this.workflowService.incriseConfigCount(currentworkflowId);
                    if (redirectTo) {
                        let targetStepId = null;
                        if ((repatableWorkflowConfig.length - 1) == repatableWorkflowConfig.count) {
                            this.additionalParameters = eventParams.invoke_event_config.additional_parameters;
                            const targetStep = eventParams.invoke_event_config.additional_parameters
                                .find(i => i.parameter_type === 'step_id');
                            if (targetStep) {
                                targetStepId = targetStep.value;
                                // this.workflowService.removeWorkflowFromConfig(workflowDetails.sequence_id);
                            }
                        }
                        else {
                            if (currentworkflowId) {
                                targetStepId = this.wfeStepLoaderService.getFirstStepInSquence(this.wfeStepLoaderService
                                    .getSequenceDefaultStepIdBySequenceId(currentworkflowId).sequence);
                            }
                        }
                        if (targetStepId) {
                            const workflowDetails = this.wfeStepLoaderService.getWorkflowDetails(targetStepId);
                            if (workflowDetails && workflowDetails.sequence && workflowDetails.sequence.length == 1) {
                                this.sharedEventsServices.exitWorkflowSameStepRedirectEmmiter.emit();
                            }
                            this.redirectTo(targetStepId);
                        }
                    }
                }
            }
        }
    }
    onWorkflowEvent(event) {
        for (const eventParams of event.event_params) {
            let redirectTo = true;
            if (this.eventCondition(eventParams.condition)) {
                if (!this.wfeConditionalQueryExecuter.evaluateConditionQuery(eventParams.query, eventParams.condition, '', {}, this.fieldData)) {
                    redirectTo = false;
                    break;
                }
            }
            if (redirectTo) {
                this.wfeStepLoaderService.setSequenceProgressInit(eventParams.event_config.display_step);
                this.redirectTo(this.wfeStepLoaderService.getFirstStepInSquence(this.wfeStepLoaderService.getSequenceDefaultStepIdBySequenceId(eventParams.event_config.display_step).sequence));
            }
        }
    }
    onFrameworkEvent(event, primaryData = {}) {
        for (const eventParam of event.event_params) {
            // store the failure and success response
            if (eventParam.invoke_event_config && eventParam.invoke_event_config.callback_config) {
                this.success = eventParam.invoke_event_config.callback_config.OnSuccess;
                this.failure = eventParam.invoke_event_config.callback_config.onFailure;
                this.response = eventParam.invoke_event_config.callback_config.onResponse;
                this.exception = eventParam.invoke_event_config.callback_config.onException;
                this.additionalParameters = eventParam.invoke_event_config.additional_parameters;
            }
            if (this.eventCondition(eventParam.condition)) {
                if (this.wfeConditionalQueryExecuter.evaluateConditionQuery(eventParam.query, eventParam.condition, primaryData.value && primaryData.value.unique_id ? primaryData.value.unique_id : '', {}, this.fieldData)) {
                    this.eventConfig(eventParam.event_config, eventParam, primaryData);
                }
                else {
                    this.sharedEventsServices.eventConditionalFailureSubscriber.emit(eventParam);
                }
            }
            else {
                this.eventConfig(eventParam.event_config, eventParam, primaryData);
            }
        }
    }
    onStepEvent(event) {
        for (const eventParam of event.event_params) {
            // store the failure and success response
            if (eventParam.invoke_event_config && eventParam.invoke_event_config.callback_config) {
                this.success = eventParam.invoke_event_config.callback_config.OnSuccess;
                this.failure = eventParam.invoke_event_config.callback_config.onFailure;
                this.response = eventParam.invoke_event_config.callback_config.onResponse;
                this.exception = eventParam.invoke_event_config.callback_config.onException;
                this.additionalParameters = eventParam.invoke_event_config.additional_parameters;
            }
            // set active menu id on local storage
            const acitiveHamburger = this.additionalParameters ? this.additionalParameters.find(i => i.parameter_type == 'isHamburgerItemActive') : [];
            if (acitiveHamburger && acitiveHamburger['value'] == 'true' && window['eventElementId']) {
                window.localStorage.setItem('active_item', window['eventElementId']);
            }
            // ***** //
            if (this.eventCondition(eventParam.condition)) {
                if (this.wfeConditionalQueryExecuter.evaluateConditionQuery(eventParam.query, eventParam.condition, '', {}, this.fieldData)) {
                    this.eventConfig(eventParam.event_config, eventParam);
                }
                else {
                    this.sharedEventsServices.eventConditionalFailureSubscriber.emit(eventParam);
                }
            }
            else {
                this.eventConfig(eventParam.event_config, eventParam);
            }
        }
    }
    eventCondition(conditionArray) {
        // execute on condition
        if (conditionArray && conditionArray.length > 0) {
            return true;
        }
        else {
            return false;
        }
    }
    async downloadFromS3(event) {
        try {
            const fileName = this.eventAdditionalParams['CEE_FILE_NAME'] ? this.eventAdditionalParams['CEE_FILE_NAME'].toLowerCase() : "";
            const s3Url = this.fieldData.value;
            //this.apiDataService.getApiDataByApiKey(fileName);
            // console.log("download method");
            // Fetch the PDF file from the S3 bucket
            const response = await fetch(s3Url);
            // console.log("download response");
            // Check if the response is successful
            if (!response.ok) {
                throw new Error(`Failed to fetch PDF: ${response.statusText}`);
            }
            // Convert the response to a Blob
            const blob = await response.blob();
            // Create a URL for the Blob
            const link = URL.createObjectURL(blob);
            // Create a temporary anchor element
            const a = document.createElement("a");
            a.setAttribute("download", fileName); // Set the desired file name
            a.setAttribute("href", link);
            // Append the anchor to the body
            document.body.appendChild(a);
            // Programmatically click the anchor to trigger the download
            a.click();
            // Clean up: remove the anchor element and revoke the Blob URL
            document.body.removeChild(a);
            URL.revokeObjectURL(link);
            // console.log("PDF downloaded successfully!");
        }
        catch (error) {
            console.error("Error downloading PDF:", error); //error printing
        }
    }
    convertHeaderToImageFixedHeight(element) {
        return new Promise((resolve, reject) => {
            if (!element)
                return reject(new Error('Header element not found'));
            // Create a deep clone to avoid modifying the original
            const clone = element.cloneNode(true);
            // Calculate PDF dimensions 
            const pdfWidthInPoints = 595.28; // A4 width in points
            const pixelsPerPoint = 96 / 72; // Conversion from points to pixels
            const pdfWidthInPixels = pdfWidthInPoints * pixelsPerPoint; // ~794px
            // Set margin in pixels
            const marginInPixels = 10; // 50px margin on each side
            const contentWidthInPixels = pdfWidthInPixels - (marginInPixels * 2); // Width after margins
            // Fixed header height
            const headerHeightInPixels = 120;
            // Create a wrapper with proper dimensions and styling
            const wrapper = document.createElement('div');
            wrapper.style.position = 'fixed';
            wrapper.style.top = '-9999px';
            wrapper.style.left = '0';
            wrapper.style.width = contentWidthInPixels + 'px';
            wrapper.style.height = headerHeightInPixels + 'px';
            wrapper.style.background = '#fff';
            wrapper.style.padding = '0';
            wrapper.style.margin = '0';
            wrapper.style.boxSizing = 'border-box';
            wrapper.style.display = 'flex'; // Use flexbox
            wrapper.style.flexDirection = 'row';
            wrapper.style.justifyContent = 'space-between'; // Space between columns
            wrapper.style.alignItems = 'center';
            // Select elements using the correct class names
            const firstColumn = clone.querySelector('.header-two-log');
            const secondColumn = clone.querySelector('.header-label');
            // Create fresh containers for our columns
            const leftColumnContainer = document.createElement('div');
            leftColumnContainer.style.width = '48%';
            leftColumnContainer.style.height = '100%';
            leftColumnContainer.style.display = 'flex';
            leftColumnContainer.style.alignItems = 'center';
            leftColumnContainer.style.justifyContent = 'flex-start';
            leftColumnContainer.style.padding = '5px';
            leftColumnContainer.style.boxSizing = 'border-box';
            const rightColumnContainer = document.createElement('div');
            rightColumnContainer.style.width = '48%';
            rightColumnContainer.style.height = '100%';
            rightColumnContainer.style.display = 'flex';
            rightColumnContainer.style.alignItems = 'center';
            rightColumnContainer.style.justifyContent = 'flex-end';
            rightColumnContainer.style.padding = '5px';
            rightColumnContainer.style.boxSizing = 'border-box';
            rightColumnContainer.style.textAlign = 'right';
            // Process and add first column content
            if (firstColumn) {
                // Extract and clean the logo image
                const logoImg = firstColumn.querySelector('img');
                if (logoImg) {
                    const newImg = document.createElement('img');
                    newImg.src = logoImg.src;
                    newImg.alt = logoImg.alt || 'Logo';
                    newImg.style.maxHeight = '100px';
                    newImg.style.maxWidth = '100%';
                    newImg.style.objectFit = 'contain';
                    leftColumnContainer.appendChild(newImg);
                }
                else {
                    // If no image, copy the text content
                    const firstColumnContent = document.createElement('div');
                    firstColumnContent.textContent = firstColumn.textContent || '';
                    firstColumnContent.style.fontSize = '10px';
                    firstColumnContent.style.fontWeight = 'bold';
                    firstColumnContent.style.textAlign = 'left';
                    leftColumnContainer.appendChild(firstColumnContent);
                }
            }
            // Process and add second column content
            // if (secondColumn) {
            //     // Extract text content, clean it and truncate after AM/PM
            //     let textContent = secondColumn.textContent || '';
            //     // Clean the text and truncate after AM/PM
            //     textContent = textContent
            //         .replace(/\{\{[^}]*\}\}/g, '') // Remove Angular bindings
            //         .replace(/class="[^"]*"/g, '') // Remove class attributes
            //         .replace(/\[class\]="[^"]*"/g, ''); // Remove Angular class bindings
            //     // Truncate text after AM/PM
            //     const amIndex = textContent.indexOf('AM');
            //     const pmIndex = textContent.indexOf('PM');
            //     if (amIndex > -1) {
            //         textContent = textContent.substring(0, amIndex + 2);
            //     } else if (pmIndex > -1) {
            //         textContent = textContent.substring(0, pmIndex + 2);
            //     }
            //     // Create a text element for the second column
            //     const secondColumnContent = document.createElement('div');
            //     secondColumnContent.style.fontSize = '10px';
            //     secondColumnContent.style.lineHeight = '1.3';
            //     secondColumnContent.style.textAlign = 'right';
            //     // Replace newlines with <br> tags
            //     textContent = textContent.replace(/\n/g, '<br>');
            //     secondColumnContent.innerHTML = textContent;
            //     rightColumnContainer.appendChild(secondColumnContent);
            // }
            if (secondColumn) {
                // Get the content from the second column
                const contentElement = secondColumn.querySelector('.Name') || secondColumn;
                let htmlContent = contentElement.innerHTML || secondColumn.innerHTML;
                // Log the content to verify it's not empty
                // console.log("Original HTML content:", htmlContent);
                // Ensure line breaks are preserved
                htmlContent = htmlContent.replace(/<br\s*\/?>/gi, '###BR###');
                htmlContent = htmlContent.replace(/\n/g, '<br>');
                htmlContent = htmlContent.replace(/###BR###/g, '<br>');
                // console.log("Formatted HTML content:", htmlContent);
                // Create a new element to hold the formatted content
                const formattedContent = document.createElement('div');
                formattedContent.style.fontFamily = 'Quicksand';
                formattedContent.style.fontSize = '8px';
                formattedContent.style.fontWeight = 'normal';
                formattedContent.style.color = '#000'; // Ensure text is black
                formattedContent.style.lineHeight = '1.2';
                formattedContent.style.whiteSpace = 'pre-wrap';
                formattedContent.style.background = 'transparent'; // Ensure background is transparent
                formattedContent.style.padding = '5px'; // Add some padding
                formattedContent.style.width = '100%'; // Ensures it takes full width
                // Set the HTML content
                formattedContent.innerHTML = htmlContent;
                // CRITICAL: Make sure to append this to the document
                if (rightColumnContainer) {
                    rightColumnContainer.appendChild(formattedContent);
                    // console.log("Content appended to rightColumnContainer");
                }
                else {
                    // If rightColumnContainer doesn't exist, append directly to secondColumn
                    secondColumn.innerHTML = '';
                    secondColumn.appendChild(formattedContent);
                    // console.log("Content appended to secondColumn");
                }
                // Verify the content is in the DOM
                // console.log("After appending, rightColumnContainer HTML:", 
                //     rightColumnContainer ? rightColumnContainer.innerHTML : "rightColumnContainer not found");
            }
            // Add columns to wrapper
            wrapper.appendChild(leftColumnContainer);
            wrapper.appendChild(rightColumnContainer);
            // Add to DOM
            document.body.appendChild(wrapper);
            // Ensure images are loaded
            const images = wrapper.querySelectorAll('img');
            const imagePromises = Array.from(images).map(img => {
                return new Promise((resolve) => {
                    if (img.complete) {
                        resolve();
                    }
                    else {
                        img.onload = () => resolve();
                        img.onerror = () => resolve();
                    }
                });
            });
            // Wait for images to load before rendering
            Promise.all(imagePromises).then(() => {
                // Small delay to ensure all styling is applied
                setTimeout(() => {
                    html2canvas(wrapper, {
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        logging: false,
                        backgroundColor: '#fff'
                    }).then(canvas => {
                        // Get data URL
                        const dataUrl = canvas.toDataURL('image/png');
                        // Clean up
                        document.body.removeChild(wrapper);
                        // Return the data URL and dimensions
                        resolve({
                            dataUrl,
                            width: contentWidthInPixels,
                            height: headerHeightInPixels
                        });
                    }).catch(error => {
                        // Clean up on error
                        console.error('error Promise load :', error);
                        if (document.body.contains(wrapper)) {
                            document.body.removeChild(wrapper);
                        }
                        reject(error);
                    });
                }, 100); // Small delay for styles
            });
        });
    }
    async loadFontForPDF(doc) {
        try {
            //   // Fetch the font file from the root path where it's available in the browser
            //   const response = await fetch('../../assets/fonts/Quicksand/static/Quicksand-Regular.ttf'); // Adjust path as needed
            //   const fontData = await response.arrayBuffer();
            //   const response1 = await fetch('../../assets/fonts/Quicksand/static/Quicksand-Bold.ttf'); // Adjust path as needed
            //   const fontData1 = await response1.arrayBuffer();
            //   // Convert ArrayBuffer to base64
            //   const base64Font = btoa(
            //     new Uint8Array(fontData)
            //       .reduce((data, byte) => data + String.fromCharCode(byte), '')
            //   );
            //   const base64Font1 = btoa(
            //     new Uint8Array(fontData1)
            //       .reduce((data, byte) => data + String.fromCharCode(byte), '')
            //   );
            const base64Font = '';
            const base64Font1 = '';
            console.log("first");
            // Add font to jsPDF
            const fontPath = 'Quicksand-Regular.ttf';
            doc.addFileToVFS(fontPath, base64Font);
            doc.addFont(fontPath, 'Quicksand', 'normal');
            doc.setFont('Quicksand', 'normal');
            const fontPath1 = 'Quicksand-Bold.ttf';
            doc.addFileToVFS(fontPath1, base64Font1);
            doc.addFont(fontPath1, 'Quicksand', 'bold');
            doc.setFont('Quicksand', 'bold');
            return Promise.resolve();
        }
        catch (error) {
            console.error('Error loading font:', error);
            // Fallback to standard font
            doc.setFont('helvetica');
            return Promise.resolve();
        }
    }
    // Then in your PDF generation method
    async generatePDF(event, elementOrId, filename = 'mortgage_application.pdf', printUpload = true) {
        let success, failure;
        if (event.invoke_event_config) {
            success = event.invoke_event_config.callback_config.OnSuccess ||
                event.invoke_event_config.callback_config.onResponse;
            failure = event.invoke_event_config.callback_config.onFailure ||
                event.invoke_event_config.callback_config.onException;
        }
        //   console.log("generatePDF started:");
        //   console.time('PDF Render Time');
        this.showLoader("Generating PDF... Please wait.");
        const sourceElementParent = document.getElementById(elementOrId);
        const generatedId = `section-nested-${elementOrId}`;
        var element = document.getElementById(generatedId);
        this.adjustDollerPrepend();
        this.adjustPercentageSuffix();
        element = this.transformInputsToLabelsAndWrapContent(element);
        // const element = //document.querySelector('.main-section-elements'); 
        const patterns = [/^Applicant_\d+$/, /^Date_\d+$/];
        element.querySelectorAll('*').forEach(el => {
            const text = el.textContent?.trim();
            if (text && patterns.some(p => p.test(text))) {
                el.style.color = 'transparent';
            }
        });
        this.cleanUpMaterialFields(element);
        if (!element) {
            console.error('Element not found for PDF.');
            return;
        }
        const options = {
            margin: [1.5625, 0.5, 0.5, 0.5],
            filename,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, useCORS: true },
            jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' },
            pagebreak: {
                mode: ['avoid-all', 'css', 'legacy'],
                avoid: ['.no-break', '.avoid-break']
            }
        };
        const self = this; // preserve context if needed
        const doc = await html2pdf().set(options).from(element).toPdf().get('pdf');
        const totalPages = doc.internal.getNumberOfPages();
        const containerIdHeader = (event['event_handler']?.toLowerCase() === 'step')
            ? 'stepblock-' + this.eventAdditionalParams['CEE_PRINT_SOURCE_HEADER']
            : this.eventAdditionalParams['CEE_PRINT_SOURCE_HEADER'];
        const sourceHtml_header = this.adjustTextareasForPDF(containerIdHeader) || document.createElement('div');
        const headerHeightInches = 100 / 96; // ≈ 1.0417 inches
        const pageWidth = doc.internal.pageSize.getWidth(); // full width in inches
        const margin = 0.5; // in inches
        const imageWidth = pageWidth - 2 * margin; // subtract left + right margins
        const imageX = margin; // start drawing at left margin
        this.convertHeaderToImageFixedHeight(sourceHtml_header).then(({ dataUrl, width, height }) => {
            for (let i = 1; i <= totalPages - 1; i++) {
                doc.setPage(i);
                doc.addImage(dataUrl, 'PNG', imageX, 0, imageWidth, headerHeightInches);
            }
            //   doc.save(filename);
            if (printUpload) {
                const blobObj = doc.output('blob');
                blobObj.name = filename; // optional: name the blob for backend
                // Call upload function
                try {
                    self.printUpload(blobObj, filename, success, failure);
                }
                catch (err) {
                    console.error('Upload failed:', err);
                    if (failure)
                        failure(err);
                }
            }
        });
        console.timeEnd('PDF Render Time');
    }
    transformInputsToLabelsAndWrapContent(element) {
        const clonedElement = element.cloneNode(true);
        // Convert <input> elements
        clonedElement.querySelectorAll('input').forEach(input => {
            const type = input.type?.toLowerCase();
            // Only replace text-like input types
            if (['text', 'email', 'number', 'tel', 'url', 'search', 'password', 'date'].includes(type)) {
                const wrapper = document.createElement('div');
                wrapper.textContent = input.value || '';
                wrapper.style.whiteSpace = 'normal';
                wrapper.style.wordBreak = 'break-word';
                wrapper.style.width = '100%';
                wrapper.style.display = 'inline-block';
                input.replaceWith(wrapper);
            }
        });
        // Replace only textareas
        clonedElement.querySelectorAll('textarea').forEach(textarea => {
            const wrapper = document.createElement('div');
            wrapper.textContent = textarea.value || '';
            wrapper.style.whiteSpace = 'pre-wrap'; // preserves line breaks
            wrapper.style.wordBreak = 'break-word';
            wrapper.style.width = '100%';
            wrapper.style.display = 'inline-block';
            textarea.replaceWith(wrapper);
        });
        this.replaceOnlyRadioAppViewRenderers(clonedElement);
        return clonedElement;
    }
    casePdfGenerate(event) {
        const self = this;
        // console.log("Generating PDF for event:");// comment
        //this.showLoader("Generating PDF... Please wait.");
        this.eventAdditionalParams = this.getAdditionalParameter();
        const printFormat = (this.eventAdditionalParams['CEE_PRINT_FORMAT'] || 'pdf').toLowerCase();
        const source = this.eventAdditionalParams['CEE_PRINT_SOURCE'];
        const containerIds = (event['event_handler']?.toLowerCase() === 'step')
            ? source.split('||').map(id => 'stepblock-' + id)
            : source.split('||');
        const containerIdHeader = (event['event_handler']?.toLowerCase() === 'step')
            ? 'stepblock-' + this.eventAdditionalParams['CEE_PRINT_SOURCE_HEADER']
            : this.eventAdditionalParams['CEE_PRINT_SOURCE_HEADER'];
        const splitContainerIds = [...containerIds];
        const sourceId = splitContainerIds[0];
        const filename = this.eventAdditionalParams['CEE_PRINT_FILE_NAME'] || "report_pdf.pdf";
        //const sourceHtml = this.adjustTextareasForPDF(sourceId);
        this.generatePDF(event, sourceId, filename); // test
    }
    adjustTextareasForPDF(sourceElementId) {
        const sourceElementParent = document.getElementById(sourceElementId);
        const generatedId = `section-nested-${sourceElementId}`;
        const generatedElement = document.getElementById(generatedId);
        // const sourceElementParent = document.querySelector('.main-section-elements'); 
        if (!sourceElementParent)
            return null;
        const clonedSourceParent = sourceElementParent.cloneNode(true);
        const combinedContainer = document.createElement('div');
        combinedContainer.appendChild(clonedSourceParent);
        combinedContainer.appendChild(sourceElementParent);
        // if (generatedElement) {
        //     const clonedGeneratedElement = generatedElement.cloneNode(true) as HTMLElement;
        //     combinedContainer.appendChild(clonedGeneratedElement);
        // }
        this.cleanUpMaterialFields(combinedContainer);
        const test = combinedContainer.querySelectorAll('.block_field_2514572_wrapper');
        test.forEach((wrapper) => {
            // console.log("test1");
        });
        this.replaceOnlyRadioAppViewRenderers(combinedContainer);
        test.forEach((wrapper) => {
            // console.log("test2");
        });
        const formElements = combinedContainer.querySelectorAll('input, textarea, select');
        formElements.forEach((el) => {
            if (!el || !el.tagName) {
                return;
            }
            let value = '';
            let displayElement;
            if (el.tagName === 'SELECT') {
                value = el.options[el.selectedIndex]?.text || '';
                displayElement = document.createElement('span');
                displayElement.innerText = value;
                displayElement.style.fontWeight = value ? 'bold' : 'normal';
            }
            else if (el.tagName === 'INPUT' && (el.type === 'checkbox')) {
                // For radio buttons and checkboxes
                const isChecked = el.checked;
                var labelText = this.findLabelText(el);
                // Create a custom element to represent the selection states
                displayElement = document.createElement('div');
                displayElement.style.display = 'inline-flex';
                displayElement.style.alignItems = 'center';
                // Prevent indicator from being split across PDF pages
                const avoidBreakWrapper = document.createElement('div');
                avoidBreakWrapper.style.display = 'inline-block';
                // avoidBreakWrapper.style.pageBreakInside = 'avoid';
                avoidBreakWrapper.style.breakInside = 'avoid';
                avoidBreakWrapper.style.setProperty('-webkit-column-break-inside', 'avoid');
                avoidBreakWrapper.style.setProperty('-moz-column-break-inside', 'avoid');
                avoidBreakWrapper.style.breakInside = 'avoid';
                avoidBreakWrapper.style.verticalAlign = 'middle';
                // Create the visual indicator (circle for radio, square for checkbox)
                const indicator = document.createElement('span');
                indicator.style.display = 'inline-block';
                indicator.style.width = '12px';
                indicator.style.height = '12px';
                indicator.style.border = '1px solid #000';
                indicator.style.marginRight = '6px';
                // indicator.style.marginBottom = '2px';
                // if (el.type === 'radio') {
                //     indicator.style.borderRadius = '50%';
                //     if (isChecked) {
                //         indicator.style.background = '#000';
                //         indicator.style.boxShadow = 'inset 0 0 0 2px #000';
                //     }
                // } else 
                if (el.type === 'checkbox') { // checkbox
                    if (isChecked) {
                        indicator.style.backgroundColor = '#000'; // Fill with black
                        indicator.style.border = '1px solid #000';
                        indicator.innerHTML = '✓'; // Checkmark symbol
                        indicator.style.color = '#fff'; // White checkmark
                        indicator.style.textAlign = 'center';
                        indicator.style.lineHeight = '10px';
                        indicator.style.fontSize = '10px';
                        indicator.style.fontWeight = 'bold';
                    }
                }
                // Add the indicator and label to our display element
                displayElement.appendChild(indicator);
                avoidBreakWrapper.appendChild(displayElement);
                // Add the label text if available
                const textSpan = document.createElement('span');
                textSpan.innerText = '';
                textSpan.style.borderBottom = 'none'; // ✅ Always remove underline
                textSpan.style.marginBottom = '2px';
                if (isChecked) {
                    textSpan.style.fontWeight = 'bold';
                    // textSpan.style.borderBottom = 'none';
                    // textSpan.style.marginBottom = '2px';
                }
                displayElement.appendChild(textSpan);
            }
            else {
                // For text inputs, textareas, etc.
                value = el.value || el.textContent || '';
                // Create a span to display the value
                displayElement = document.createElement('span');
                displayElement.innerText = value;
            }
            displayElement.style.display = 'inline-block';
            // displayElement.style.minHeight = '20px';
            displayElement.style.whiteSpace = 'pre-wrap';
            displayElement.style.color = '#000';
            displayElement.style.backgroundColor = '#fff';
            displayElement.style.font = getComputedStyle(el).font;
            // displayElement.style.padding = '4px 6px';
            displayElement.style.marginBottom = '6px';
            displayElement.style.fontWeight = 'bold';
            // If empty value, show an underline
            if (el.tagName !== 'INPUT' || (el.type !== 'radio' && el.type !== 'checkbox')) {
                if (!value.trim()) {
                    displayElement.style.borderBottom = '2px solid #ccc';
                    //displayElement.style.width = '100px';
                    displayElement.style.minHeight = '24px';
                    //displayElement.style.backgroundColor = '#fff'; // Light gray background to indicate it's filled
                    //displayElement.style.color = '#000'; // Black text color for visibility
                    displayElement.innerText = 'N/A'; // Default text to indicate it's filled
                    displayElement.style.fontWeight = 'bold';
                    displayElement.style.marginBottom = '4px';
                }
            }
            // Replace the original element with our display element
            el.parentNode.replaceChild(displayElement, el);
        });
        test.forEach((wrapper) => {
            // console.log("test3");
        });
        const images = combinedContainer.querySelectorAll('img');
        images.forEach((img) => {
            const original = sourceElementParent.querySelector(`img[src="${img.src}"]`);
            if (original instanceof HTMLImageElement) {
                const computedStyle = getComputedStyle(original);
                img.style.width = computedStyle.width;
                img.style.height = computedStyle.height;
            }
        });
        combinedContainer.style.width = '750px'; // Or whatever your target width is (slightly less than page width)
        combinedContainer.style.maxWidth = '750px';
        combinedContainer.style.padding = '20px';
        combinedContainer.style.boxSizing = 'border-box';
        combinedContainer.style.wordBreak = 'break-word';
        combinedContainer.style.overflowWrap = 'break-word';
        //combinedContainer.style.fontSize = '8px'; 
        const inlineAllStyles = (root) => {
            const allElements = root.querySelectorAll('*');
            allElements.forEach(el => {
                const computedStyle = window.getComputedStyle(el);
                // Only keep the most important styles for accurate text layout
                [
                    'font-family', 'font-size', 'font-weight', 'font-style',
                    'line-height', 'letter-spacing', 'color', 'background-color',
                    'text-align', 'vertical-align', 'text-transform',
                    'padding', 'margin', 'box-sizing', 'display', 'width', 'height',
                    'border', 'border-radius', 'white-space', 'overflow-wrap'
                ].forEach(prop => {
                    const value = computedStyle.getPropertyValue(prop);
                    el.style.fontFamily = 'Quicksand';
                    if (value) {
                        el.style.setProperty(prop, value);
                    }
                });
            });
        };
        inlineAllStyles(combinedContainer);
        test.forEach((wrapper) => {
            // console.log("test4");
        });
        // Fix label rendering issue
        const initialsLabels = combinedContainer.querySelectorAll('.col-md-2 .sharinginformationfo');
        initialsLabels.forEach((el) => {
            el.innerHTML = el.textContent?.trim() || '';
            el.style.fontFamily = 'Quicksand';
            el.style.fontWeight = 'normal';
            el.style.fontSize = '12px';
            el.style.whiteSpace = 'nowrap';
            el.style.letterSpacing = '0.3px';
            el.style.color = '#000';
            //el.style.background = 'transparent';
            el.style.display = 'inline-block';
        });
        const labelColumns = combinedContainer.querySelectorAll('.col-md-2');
        labelColumns.forEach((col) => {
            col.style.width = 'fit-content';
            col.style.minWidth = '150px';
            col.style.display = 'flex';
            col.style.alignItems = 'center';
        });
        const inputHeadingLabel = combinedContainer.querySelectorAll('.col-form-label,.cf-label-border-top');
        inputHeadingLabel.forEach((el) => {
            if (!el.innerText || !(el.innerText.trim() === '')) {
                el.style.color = '#808080';
                el.style.fontWeight = 'bold';
                el.style.letterSpacing = '1';
                //el.style.margin = '16px 0';
                el.style.fontFamily = 'Quicksand';
            }
            else {
                el.style.height = '0px';
                el.style.border = 'none';
                el.style.background = 'none';
                el.style.backgroundColor = 'transparent';
            }
        });
        const inputText = combinedContainer.querySelectorAll('.cf-label-bold');
        inputText.forEach((el) => {
            el.style.color = '#333';
            el.style.letterSpacing = '1';
            //el.style.margin = '16px 0';
            el.style.fontFamily = 'Quicksand';
        });
        boldFormatingOnSomeForms(combinedContainer);
        // If actual signature is not available, replace with a placeholder and need to modify this code
        // Find all elements with the class "visible_doc_sign" and make their text color white
        const visibleDocSignElements = combinedContainer.querySelectorAll('[class*="visible_doc_sign"]');
        visibleDocSignElements.forEach((node) => {
            // Change text color to white
            node.style.color = "white";
            // Optional: If you want to ensure it's not visible even when selected
            node.style.userSelect = "none";
        });
        //  // Apply manual styling for headings
        //  const mainHeadings = combinedContainer.querySelectorAll('.main-heading');
        //  mainHeadings.forEach((el: HTMLElement) => {
        //      //el.style.fontSize = '22px';
        //      el.style.fontWeight = 'bold';
        //      //el.style.margin = '16px 0';
        //      el.style.color = '#000'; // Optional: set a strong contrast color
        //      el.style.fontFamily = 'Quicksand-Bold'; // Ensure it's supported in PDF
        //  });
        const mainHeadings = combinedContainer.querySelectorAll('.main-heading');
        mainHeadings.forEach((el) => {
            el.style.fontFamily = 'Quicksand'; // ✅ Use the base family only
            el.style.fontWeight = 'bold'; // ✅ Use numeric bold weight (not 'bold' string)
            el.style.fontSize = '24px'; // Optional: adjust for clarity
            el.style.lineHeight = '1.2'; // ✅ Helps spacing
            el.style.letterSpacing = '0.4px'; // ✅ Prevents overlapping
            el.style.color = '#000';
        });
        // Apply styling for subheadings or other known classes
        const subHeadings = combinedContainer.querySelectorAll('[class*="sub-heading"]');
        subHeadings.forEach((el) => {
            el.style.fontFamily = 'Quicksand'; // ✅ Use the base family only
            el.style.fontWeight = 'bold'; // ✅ Use numeric bold weight (not 'bold' string)
            el.style.fontSize = '18px'; // Optional: adjust for clarity
            el.style.lineHeight = '1.2'; // ✅ Helps spacing
            el.style.letterSpacing = '0.4px'; // ✅ Prevents overlapping
            el.style.color = '#000';
            el.style.marginTop = '27px'; // Add space above sub-headings
            el.style.paddingTop = '5px'; // Additional padding for better spacing
        });
        // header issue
        // const wrapper = document.querySelector('div.block_field_1057637_wrapper') as HTMLElement;
        // if (wrapper) {
        //   wrapper.style.width = '600px';
        //   const leftCol = wrapper.querySelector('.col-md-6.field-0-0') as HTMLElement;
        //   const rightCol = wrapper.querySelector('.col-md-6.field-0-1') as HTMLElement;
        //   if (leftCol) leftCol.style.width = '300px';
        //   if (rightCol) rightCol.style.width = '300px';
        // }
        const wrappers = document.querySelectorAll('div.block_field_1057637_wrapper');
        wrappers.forEach(wrapper => {
            const wrapperEl = wrapper;
            wrapperEl.style.width = '600px';
            wrapperEl.style.marginBottom = "5px";
            const leftCol = wrapperEl.querySelector('.col-md-6.field-0-0');
            const rightCol = wrapperEl.querySelector('.col-md-6.field-0-1');
            if (leftCol)
                leftCol.style.width = '300px';
            if (rightCol)
                rightCol.style.width = '300px';
        });
        const wrappers1 = document.querySelectorAll('div.block_field_1127065_wrapper');
        wrappers1.forEach(wrapper => {
            const wrapperEl = wrapper;
            wrapperEl.style.width = '600px';
            wrapperEl.style.marginBottom = "5px";
            const leftCol = wrapperEl.querySelector('.col-md-6.field-0-0');
            const rightCol = wrapperEl.querySelector('.col-md-6.field-0-1');
            if (leftCol)
                leftCol.style.width = '300px';
            if (rightCol)
                rightCol.style.width = '300px';
        });
        const wrappers2 = document.querySelectorAll('div.block_field_1602836_wrapper');
        wrappers2.forEach(wrapper => {
            const wrapperEl = wrapper;
            wrapperEl.style.width = '600px';
            wrapperEl.style.marginBottom = "5px";
            const leftCol = wrapperEl.querySelector('.col-md-6.field-0-0');
            const rightCol = wrapperEl.querySelector('.col-md-6.field-0-1');
            if (leftCol)
                leftCol.style.width = '300px';
            if (rightCol)
                rightCol.style.width = '300px';
        });
        // const renderers = document.querySelectorAll('.app-view-renderer-7_45423-5');
        // renderers.forEach((el: Element) => {
        //     (el as HTMLElement).style.marginTop = '5px';
        // });
        const renderers1 = document.querySelectorAll('.app-view-renderer-5_45453-3');
        renderers1.forEach((el) => {
            el.style.marginTop = '5px';
        });
        // const renderers2 = document.querySelectorAll('.app-view-renderer-7_45423-6');
        // renderers2.forEach((el: Element) => {
        //     (el as HTMLElement).style.marginTop = '5px';
        // });
        this.fixStepLabelOverlapping(combinedContainer); // Fix overlapping step labels
        this.fixOverlappingBulletPoints(combinedContainer); // Fix overlapping bullet points
        this.fixNestedLabelStructures(combinedContainer); // test
        test.forEach((wrapper) => {
            // console.log("test5");
        });
        // Add spacing before each section element
        const sectionElements = combinedContainer.querySelectorAll('section');
        sectionElements.forEach((section) => {
            // section.style.marginTop = '10px'; // Add spacing before each section
            // section.style.paddingTop = '5px'; // Add additional padding
            section.style.marginBottom = '5px'; // Add spacing after each section
        });
        //tableHeadersElements(combinedContainer);
        // Function to detect if an element would overflow the current page
        const detectIfElementOverflowsPage = (element, currentY) => {
            const elementHeight = element.offsetHeight;
            const pageHeightPx = 1122; // A4 at 96 DPI
            return (currentY + elementHeight > pageHeightPx);
        };
        // Add PDF-row class to all table rows for page break detection
        // const allTableRows = combinedContainer.querySelectorAll('table tr, mat-mdc-table mat-row');
        // allTableRows.forEach((row: HTMLElement) => {
        //     row.classList.add('pdf-row');
        // });
        // Process page breaks for all rows in the document
        // let currentY = 0;
        // const pageHeightPx = 1122; // A4 at 96 DPI
        // let lastRowOfPage: HTMLElement | null = null;
        // Get all PDF rows in the document in sequence
        // const allPdfRows = combinedContainer.querySelectorAll('.pdf-row');
        // allPdfRows.forEach((row: HTMLElement, index) => {
        //     const rowHeight = row.offsetHeight;
        //     // If adding this row would overflow the page
        //     if (currentY + rowHeight > pageHeightPx + 5) {
        //         // Mark the previous row as the last row of the page
        //         if (lastRowOfPage) {
        //             // Apply page break properties to the last row of the page
        //             lastRowOfPage.style.setProperty('page-break-inside', 'avoid');
        //             lastRowOfPage.style.setProperty('break-inside', 'avoid');
        //             lastRowOfPage.style.setProperty('page-break-after', 'auto');
        //         }
        //         // Create spacer to push content to next page
        //         const spacer = document.createElement('div');
        //         spacer.style.height = (pageHeightPx - currentY) + 'px';
        //         spacer.style.display = 'block';
        //         row.parentNode?.insertBefore(spacer, row);
        //         // Reset for new page
        //         currentY = 0;
        //         lastRowOfPage = null;
        //     }
        //     // Update position and last row reference
        //     currentY += rowHeight;
        //     lastRowOfPage = row;
        //     // For the very last row in the document
        //     if (index === allPdfRows.length - 1 && lastRowOfPage) {
        //         lastRowOfPage.style.setProperty('page-break-inside', 'avoid');
        //         lastRowOfPage.style.setProperty('break-inside', 'avoid');
        //         lastRowOfPage.style.setProperty('page-break-after', 'auto');
        //     }
        // });
        this.fixNestedLabelStructures(combinedContainer); // test
        this.removeAddButton(combinedContainer);
        // Target elements within the combinedContainer, not the entire document
        // Target elements within the combinedContainer, not the entire document
        document.querySelectorAll('.section-0-0-1-3-0.step-45237,' +
            '.section-0-0-1-4-0.step-45521,' +
            '.app-view-renderer-18_46450-1.block_field_151851050333332_wrapper,' +
            '.app-view-renderer-14_45320-2,' +
            '.app-view-renderer-10_45320-2,' +
            '.cee-section.row.section-0-0-1-1-0.step-45043,' +
            '.block_field_1135670_wrapper,' +
            '.block_field_2553578_wrapper,' +
            '.block_field_2647691_wrapper,' +
            '.block_field_1993215_wrapper,' +
            '.block_field_2356219_wrapper,' +
            '.block_field_5622882_wrapper,' +
            '.block_field_6215202_wrapper,' +
            '.block_field_3214831_wrapper,' +
            '.block_field_2025129_wrapper,' +
            '.block_field_4756600_wrapper,' +
            '.block_field_2871196_wrapper,' +
            '.block_field_1981319_wrapper,' +
            '.block_field_2963716_wrapper,' +
            '.block_field_1297584_wrapper,' +
            '.block_field_5227011_wrapper,' +
            '.block_field_3802960_wrapper,' +
            '.block_field_5577468_wrapper,' +
            '.block_field_3245258_wrapper,' +
            '.block_field_2523354_wrapper,' +
            '.block_field_3245258_wrapper,' +
            '.block_field_2301701_wrapper,' +
            '.block_field_3078751_wrapper,' +
            '.block_field_3991634_wrapper,' +
            '.block_field_2426487_wrapper,' +
            '.block_field_3078751_wrapper,' +
            '.block_field_2231986_wrapper,' +
            '.block_field_3059426_wrapper,' +
            '.block_field_2782362_wrapper,' +
            '.block_field_3504770_wrapper,' +
            '.block_field_2235683_wrapper,' +
            '.block_field_4031710_wrapper,' +
            '.app-view-renderer-10_45320-2 block_field_2121787_wrapper,' +
            '.app-view-renderer-14_45320-2 block_field_4031710_wrapper,' +
            '.block_field_151851090851454_wrapper,' +
            '.block_field_151851090677458_wrapper,' +
            '.block_field_151851090842462_wrapper,' +
            '.block_field_5188238_wrapper,' +
            '.block_field_2514572_wrapper').forEach(el => {
            el.classList.remove('col-auto');
            el.classList.add('col-md-12');
        });
        document.querySelectorAll('.app-view-renderer-6_45068-1').forEach(el => {
            el.classList.remove('col-auto');
            el.classList.add('col-md-6');
        });
        document.querySelectorAll('.app-view-renderer-6_45068-1,' +
            '.app-view-renderer-5_45068-2').forEach(el => {
            el.classList.add('col-md-6');
        });
        document.querySelectorAll('.app-view-renderer-14_45320-3').forEach(el => {
            // console.log("app-view-renderer-14_45320-3", el);
            el.classList.remove('col-md-4');
            el.classList.add('col-md-3');
        });
        document.querySelectorAll('.app-view-renderer-9_46406-9').forEach(el => {
            // console.log("app-view-renderer-14_45320-3", el);
            el.classList.remove('col-md-4');
            el.classList.add('col-md-12');
        });
        document.querySelectorAll('.app-view-renderer-9_46406-9').forEach(el => {
            // console.log("app-view-renderer-14_45320-3", el);
            el.classList.remove('col-md-4');
            el.classList.add('col-md-3');
        });
        document.querySelectorAll('.cee-section row section-0-0-1-0-1').forEach(el => {
            el.classList.add('col-md-6');
        });
        document.querySelectorAll('.app-view-renderer-6_45068-1').forEach(el => {
            el.classList.add('col-md-6');
        });
        document.querySelectorAll('.app-view-renderer-5_45280-6.col-md-4').forEach(el => {
            el.classList.remove('col-md-4');
            el.classList.add('col-md-12');
        });
        document.querySelectorAll('.block_field_9728023_wrapper').forEach(el => {
            el.classList.remove('col-auto');
            el.classList.add('col-md-12');
        });
        test.forEach((wrapper) => {
            // console.log("test7");
        });
        this.boldAndColorInLabel(combinedContainer);
        this.removeCheckboxUnderline();
        this.adjustDollerPrepend();
        this.rebuildMaterialTables(combinedContainer);
        this.rebuildMaterialTablesInRepeatable(combinedContainer);
        this.applyResolutionSpecificFixes(combinedContainer);
        this.adjustPercentageSuffix();
        this.applyPageBreakStylesAfterTable(combinedContainer);
        this.transformSignaturesToTable(combinedContainer);
        this.mainBorrowerListPadding(combinedContainer);
        const labels = document.getElementsByClassName('acknowledgementandsi');
        document.querySelectorAll('.block_field_4031710_wrapper').forEach((wrapper) => {
            const validLabels = [];
            // Extract valid label text
            wrapper.querySelectorAll('label.acknowledgementandsi').forEach((label) => {
                const text = label.textContent?.trim();
                if (text && !text.includes('NaN') && /[a-zA-Z]/.test(text)) {
                    validLabels.push(text);
                }
            });
            // Create a container with the new label divs
            const container = document.createElement('div');
            container.className = 'custom-label-wrapper';
            validLabels.forEach((labelText) => {
                const labelDiv = document.createElement('div');
                labelDiv.textContent = labelText;
                labelDiv.style.color = '#808080';
                //labelDiv.style.marginBottom = '8px';
                labelDiv.style.fontWeight = 'bold';
                container.appendChild(labelDiv);
            });
            // Replace wrapper in-place
            if (validLabels.length > 0) {
                wrapper.replaceWith(container);
            }
            else {
                // If no valid labels, just remove the app-view-renderer
                wrapper.remove();
            }
        });
        this.processLabelWrappers([
            'block_field_151851090851454_wrapper',
            'block_field_151851090677458_wrapper',
            'block_field_151851090842462_wrapper'
        ]);
        const bf = combinedContainer.querySelectorAll('.data-list');
        bf.forEach((section) => {
            section.style.paddingBottom = '1px';
        });
        const bf2 = combinedContainer.querySelectorAll('.field-wrapper, .ng-star-inserted');
        bf2.forEach((section) => {
            section.style.paddingBottom = '2px';
        });
        const bf3 = combinedContainer.querySelectorAll('.app-view-renderer-15_46489-2');
        bf3.forEach((section) => {
            section.style.paddingBottom = '5px';
        });
        // Apply marginTop to different classes
        const fields1 = ['.app-view-renderer-9_45280-1', '.app-view-renderer-9_45280-3', '.app-view-renderer-9_45280-5'];
        this.setMarginForElements(combinedContainer, fields1, '30px');
        const fields2 = ['.app-view-renderer-8_46578-0', '.app-view-renderer-8_46578-1', '.app-view-renderer-8_46578-3', '.app-view-renderer-8_46578-5'];
        this.setMarginForElements(combinedContainer, fields2, '40px');
        const fields3 = ['.app-view-renderer-12_45280-0', '.app-view-renderer-12_45280-1'];
        this.setMarginForElements(combinedContainer, fields3, '50px');
        this.wrapPartialLabelText(combinedContainer);
        test.forEach((wrapper) => {
            // console.log("testend");
        });
        return combinedContainer;
    }
    processLabelWrappers(wrapperClassNames = []) {
        wrapperClassNames.forEach((className) => {
            document.querySelectorAll(`.${className}`).forEach((wrapper) => {
                const validLabels = [];
                // Extract valid labels
                wrapper.querySelectorAll('label').forEach((label) => {
                    const text = label.textContent?.trim();
                    if (text &&
                        !/Applicant_\d+/i.test(text) &&
                        !text.includes('NaN') &&
                        /[a-zA-Z]/.test(text)) {
                        validLabels.push(text);
                    }
                });
                if (validLabels.length > 0) {
                    // Create replacement structure
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'row';
                    const colDiv = document.createElement('div');
                    colDiv.className = 'col-md-12';
                    const table = document.createElement('div');
                    table.style.display = 'table';
                    table.style.width = '100%';
                    validLabels.forEach((labelText) => {
                        const row = document.createElement('div');
                        row.style.display = 'table-row';
                        const cell = document.createElement('div');
                        cell.style.display = 'table-cell';
                        cell.style.color = 'black';
                        cell.style.fontWeight = 'bold';
                        cell.style.padding = '4px 0';
                        cell.textContent = labelText;
                        row.appendChild(cell);
                        table.appendChild(row);
                    });
                    colDiv.appendChild(table);
                    rowDiv.appendChild(colDiv);
                    wrapper.replaceWith(rowDiv);
                }
                else {
                    wrapper.remove(); // No valid labels found
                }
            });
        });
    }
    wrapPartialLabelText(container) {
        const labels = container.querySelectorAll('label');
        labels.forEach(label => {
            let hasSpan = false;
            label.childNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN') {
                    hasSpan = true;
                }
            });
            if (hasSpan) {
                // Only wrap unwrapped text nodes
                label.childNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE && node.textContent?.trim()) {
                        // Wrap plain text in a span
                        const span = document.createElement('span');
                        span.textContent = node.textContent;
                        label.replaceChild(span, node);
                    }
                });
            }
        });
        //console.log("Wrapped partial label text in spans where applicable.",labels);
    }
    transformSignaturesToTable(tempRoot) {
        const targetSelectors = [
            '.block_field_9296486_wrapper,' +
                '.block_field_151851090851454_wrapper,' +
                '.block_field_5188238_wrapper'
            // Add more as 
        ];
        const signatureBlocks = tempRoot.querySelectorAll(targetSelectors.join(','));
        signatureBlocks.forEach(wrapper => {
            const appViewRenderer = wrapper.closest('app-view-renderer');
            if (!appViewRenderer)
                return;
            const rows = [];
            const signatureRows = wrapper.querySelectorAll('.row.show-in-row');
            signatureRows.forEach(rowEl => {
                const row = [];
                const colEls = Array.from(rowEl.children).filter(el => el.nodeType === 1 &&
                    el.classList &&
                    Array.from(el.classList).some(cls => cls.startsWith('col-md-')));
                colEls.forEach(colEl => {
                    const label = colEl.querySelector('label.signatures');
                    if (!label)
                        return; // Skip columns without the actual signed name/date
                    const text = label.textContent?.trim() || '';
                    const colClass = Array.from(colEl.classList).find(cls => cls.startsWith('col-md-')) || 'col-md-12';
                    const width = parseInt(colClass.replace('col-md-', ''), 10) / 12 * 100;
                    row.push({ text, width });
                });
                // Only push rows that contain meaningful data (e.g. Bunty Test, Date)
                if (row.length > 0)
                    rows.push(row);
            });
            if (rows.length > 0) {
                const table = buildTable(rows);
                appViewRenderer.replaceWith(table);
            }
        });
        function buildTable(rows) {
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const table = document.createElement('table');
            if (screenWidth === 1920 && screenHeight === 1080) {
                table.style.width = '92%';
            }
            else if (screenWidth === 1366 && screenHeight === 768) {
                table.style.width = '98%';
            }
            else {
                table.style.width = '90%';
            }
            table.style.borderCollapse = 'collapse';
            table.style.margin = '40px 0';
            table.style.fontSize = '14px';
            rows.forEach(row => {
                const tr = document.createElement('tr');
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell.text || '';
                    td.style.width = cell.width + '%';
                    td.style.fontWeight = 'bold'; // test
                    //td.style.color = 'grey'; // color for label
                    td.style.padding = '8px';
                    tr.appendChild(td);
                });
                table.appendChild(tr);
            });
            return table;
        }
    }
    mainBorrowerListPadding(combinedContainer) {
        const mainBorrower = combinedContainer.querySelectorAll('.bborrowerguarantorco.comp-574647'
        // '.app-view-renderer-7_45423-4.block_field_1135670_wrapper'
        );
        mainBorrower.forEach((node) => {
            // console.log("mainBorrower", node);
            // node.style.marginLeft = '0';
            node.style.paddingLeft = '0';
        });
        const test = combinedContainer.querySelectorAll('.cf-textfield label.col-form-label');
        test.forEach((node) => {
            // console.log("test", node);
            // node.style.marginLeft = '0';
            node.style.textTransform = 'capitalize';
        });
    }
    applyPageBreakStylesAfterTable(containerMain) {
        const section = document.querySelector('.cee-section.row.section-0-0-1-0-4.step-44897.template-');
        if (section) {
            section.style.setProperty('break-before', 'page'); // modern
            section.style.setProperty('page-break-before', 'always'); // legacy CSS
            section.style.setProperty('display', 'block');
        }
    }
    setMarginForElements(combinedContainer, classes, margin) {
        const elements = combinedContainer.querySelectorAll(classes.join(', '));
        elements.forEach((el) => {
            el.style.marginTop = margin;
        });
    }
    replaceOnlyRadioAppViewRenderers(containerMain) {
        const renderers = containerMain.querySelectorAll('app-view-renderer');
        renderers.forEach(renderer => {
            // Save non-radio/checkbox children before replacing
            const preservedNodes = [];
            renderer.childNodes.forEach(child => {
                if (child.nodeType === Node.ELEMENT_NODE &&
                    !child.matches('app-cee-radio, app-cee-checkbox')) {
                    preservedNodes.push(child);
                }
            });
            const radioComponent = renderer.querySelector('app-cee-radio');
            const checkboxComponent = renderer.querySelector('app-cee-checkbox');
            let containerSub = null;
            if (radioComponent) {
                // Look for a group-level label inside form-label
                const formLabelEl = radioComponent.querySelector('.form-label label');
                const questionText = formLabelEl?.innerText?.trim();
                const radios = radioComponent.querySelectorAll('input[type="radio"]');
                if (!radios.length)
                    return;
                const options = [];
                radios.forEach(radio => {
                    const radioId = radio.id;
                    const labelElement = radioComponent.querySelector(`label[for="${radioId}"]`);
                    const label = labelElement?.innerText?.trim() || radio.value;
                    options.push({ value: radio.value, label, checked: radio.checked });
                });
                containerSub = document.createElement('div');
                containerSub.classList.add('form-group');
                const optionsHtml = options.map(opt => {
                    const bullet = 'O';
                    if (opt.checked) {
                        return `<div style="margin-top: 0px; font-family: Quicksand;">
                        <strong><span style="color: #4287f5;">${bullet}</span>&nbsp;&nbsp;${opt.label}</strong>
                    </div>`;
                    }
                    else {
                        return `<div style="margin-top: 0px; font-family: Quicksand;">
                        <strong>${bullet}&nbsp;&nbsp;${opt.label}</strong>
                    </div>`;
                    }
                }).join('');
                const hasSpecificClass = renderer.classList.contains('app-view-renderer-15_45423-2');
                const marginTopStyle = hasSpecificClass ? 'margin-top: 35px;' : '';
                // Only add question text if it is NOT already preserved in a label node
                let questionHeaderHtml = '';
                const labelAlreadyPreserved = preservedNodes.some(node => {
                    // Check if any preserved node is a label or contains the question text
                    return (node.tagName?.toLowerCase() === 'label' ||
                        (node.textContent?.trim() === questionText));
                });
                if (questionText && !labelAlreadyPreserved) {
                    questionHeaderHtml = `<div style="margin-bottom: 2px;${marginTopStyle}"><strong>${questionText}</strong></div>`;
                }
                containerSub.innerHTML = `
                ${questionHeaderHtml}
                <div style="margin-left: 10px;">
                    ${optionsHtml}
                </div>
            `;
                containerSub.style.pageBreakInside = 'avoid';
                containerSub.style.breakInside = 'avoid';
                const classArray = [
                    'app-view-renderer-17_45521-51',
                    'app-view-renderer-17_45521-52',
                    'app-view-renderer-17_45521-53',
                    'app-view-renderer-12_45237-50',
                    'app-view-renderer-12_45237-51',
                    'app-view-renderer-12_45237-52',
                ];
                if (classArray.some(className => renderer.classList.contains(className))) {
                    const outerWrapper = document.createElement('div');
                    outerWrapper.className = 'col-md-4';
                    outerWrapper.appendChild(containerSub);
                    renderer.replaceWith(outerWrapper);
                }
            }
            else if (checkboxComponent) {
                const checkboxes = checkboxComponent.querySelectorAll('.custom-control-input');
                const options = [];
                checkboxes.forEach(checkbox => {
                    const checkboxId = checkbox.id;
                    const labelSpan = checkboxComponent.querySelector(`.custom-control-label[for="${checkboxId}"] span`);
                    const label = labelSpan?.textContent?.trim() || checkbox.value;
                    options.push({ value: checkbox.value, label, checked: checkbox.checked });
                });
                containerSub = document.createElement('div');
                containerSub.classList.add('form-group');
                const optionsHtml = options.map(opt => {
                    const bullet = opt.checked ? 'X' : 'O';
                    return `<div style="margin-top: 0px; font-family: Quicksand;"><strong>${bullet}&nbsp;&nbsp;${opt.label}</strong></div>`;
                }).join('');
                containerSub.innerHTML = `
                <div style="margin-left: 10px;">
                    ${optionsHtml}
                </div>
            `;
                containerSub.style.pageBreakInside = 'avoid';
                containerSub.style.breakInside = 'avoid';
            }
            if (containerSub) {
                // Remove all app-cee-radio elements from containerSub
                renderer.querySelectorAll('app-cee-radio').forEach(node => node.remove());
                // Remove all app-cee-checkbox elements from containerSub
                renderer.querySelectorAll('app-cee-checkbox').forEach(node => node.remove());
                // Re-add preserved nodes (like labels, images, etc.) before the radio/checkbox summary
                // But filter out any app-cee-radio or app-cee-checkbox elements
                preservedNodes.forEach(node => {
                    containerSub.insertBefore(node.cloneNode(true), containerSub.firstChild);
                });
                renderer.replaceWith(containerSub);
            }
        });
        document.querySelectorAll('.form-group').forEach(el => {
            el.style.pageBreakInside = 'avoid';
            el.style.breakInside = 'avoid';
        });
    }
    //     private replaceOnlyRadioAppViewRenderers(containerMain: HTMLElement) {
    //         const renderers = containerMain.querySelectorAll('app-view-renderer');
    //         renderers.forEach(renderer => {
    //             const radioComponent = renderer.querySelector('app-cee-radio');
    //             const checkboxComponent = renderer.querySelector('app-cee-checkbox');
    // if (radioComponent) {
    //     // Look for a group-level label inside form-label
    //     const formLabelEl = radioComponent.querySelector('.form-label label');
    //     const questionText = (formLabelEl as HTMLElement | null)?.innerText?.trim();
    //     const radios = radioComponent.querySelectorAll('input[type="radio"]') as NodeListOf<HTMLInputElement>;
    //     if (!radios.length) return;
    //     const options: { value: string; label: string; checked: boolean }[] = [];
    //     radios.forEach(radio => {
    //         const value = radio.value;
    //         const checked = radio.checked;
    //         const radioId = radio.id;
    //         const labelElement = radioComponent.querySelector(`label[for="${radioId}"]`);
    //         const label = (labelElement as HTMLElement | null)?.innerText?.trim() || value;
    //         options.push({ value, label, checked });
    //     });
    //     const containerSub = document.createElement('div');
    //     containerSub.classList.add('form-group');
    //     const optionsHtml = options.map(opt => {
    //         const bullet = 'O';
    //         if (opt.checked) {
    //             return `<div style="margin-top: 0px; font-family: Quicksand;">
    //                 <strong><span style="color: #4287f5;">${bullet}</span>&nbsp;&nbsp;${opt.label}</strong>
    //             </div>`;
    //         } else {
    //             return `<div style="margin-top: 0px; font-family: Quicksand;">
    //                 <strong>${bullet}&nbsp;&nbsp;${opt.label}</strong>
    //             </div>`;
    //         }
    //     }).join('');
    //     const hasSpecificClass = renderer.classList.contains('app-view-renderer-15_45423-2');
    //             const marginTopStyle = hasSpecificClass ? 'margin-top: 35px;' : '';
    //             //<div style="margin-bottom: 2px; ${marginTopStyle}">
    //     // Render question text only if it exists
    //     const questionHeaderHtml = questionText
    //         ? `<div style="margin-bottom: 2px;${marginTopStyle}"><strong>${questionText}</strong></div>`
    //         : '';
    //     containerSub.innerHTML = `
    //         ${questionHeaderHtml}
    //         <div style="margin-left: 10px;">
    //             ${optionsHtml}
    //         </div>
    //     `;
    //     containerSub.style.pageBreakInside = 'avoid';
    //     containerSub.style.breakInside = 'avoid';
    //     renderer.replaceWith(containerSub);
    // }else if (checkboxComponent) {
    //                 console.log('Processing checkbox component');
    //                 const checkboxes = checkboxComponent.querySelectorAll('.custom-control-input') as NodeListOf<HTMLInputElement>;
    //                 // Get all checkbox values and their associated labels
    //                 const options: { value: string; label: string; checked: boolean }[] = [];
    //                 checkboxes.forEach(checkbox => {
    //                     const value = checkbox.value;
    //                     const checked = checkbox.checked;
    //                     const checkboxId = checkbox.id;
    //                     const labelSpan = checkboxComponent.querySelector(`.custom-control-label[for="${checkboxId}"] span`);
    //                     const label = labelSpan?.textContent?.trim() || value;
    //                     options.push({ value, label, checked });
    //                 });
    //                 // Build the simplified HTML for checkbox
    //                 const containerSub = document.createElement('div');
    //                 containerSub.classList.add('form-group');
    //                 // const optionsHtml = options.map(opt => {
    //                 //     const mark = opt.checked ? '[X]' : '[ ]'; // Using filled and empty square symbols
    //                 //     return `<div style="display: inline-flex; align-items: center; white-space: pre-wrap; color: #000; background-color: #fff; font-family: Quicksand; margin-bottom: 6px; font-weight: bold;">${mark}&nbsp;&nbsp;${opt.label}</div>`;
    //                 // }).join('');
    //                 const optionsHtml = options.map(opt => {
    //                 const bullet = opt.checked ? 'X' : 'O';
    //                 return `<div style="margin-top: 0px;font-family: Quicksand;"><strong>${bullet}&nbsp;&nbsp;${opt.label}</strong></div>`;
    //             }).join('');
    //                 containerSub.innerHTML = `
    //                     <div style="margin-left: 10px;">
    //                     ${optionsHtml}
    //                     </div>
    //                 `;
    //                 containerSub.style.pageBreakInside = 'avoid';
    //                 containerSub.style.breakInside = 'avoid';
    //                 renderer.replaceWith(containerSub);
    //             }
    //         });
    //         document.querySelectorAll('.form-group').forEach(el => {
    //             (el as HTMLElement).style.pageBreakInside = 'avoid';
    //             (el as HTMLElement).style.breakInside = 'avoid';
    //         });
    //     }
    applyResolutionSpecificFixes(container) {
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;
        if (screenWidth === 1920 && screenHeight === 1080) {
            // 👉 Logic for 1920x1080 resolution implemented
            // console.log('1920x1080 resolution detected');
            // Write your resolution-specific fixes here
        }
        else if (screenWidth === 1366 && screenHeight === 768) {
            // 👉 Logic for 1366x768 resolution
            // console.log('1366x768 resolution detected');
            // Write your resolution-specific fixes here
        }
        else {
            // 👉 Default logic for any other resolution
            // console.log('Other resolution detected');
            // Write fallback logic here
        }
    }
    // rebuildMaterialTables(container: HTMLElement) {
    //   const materialTables = container.querySelectorAll('table.mat-mdc-table');
    //   materialTables.forEach((table: HTMLTableElement) => {
    //     const newTable = document.createElement('table');
    //     newTable.style.pageBreakInside = 'avoid';
    //     newTable.style.borderCollapse = 'collapse';
    //     newTable.style.tableLayout = 'fixed';
    //     newTable.style.margin = '12px 0';
    //     newTable.style.width = '100%';
    //     const thead = table.querySelector('thead');
    //     const tbody = table.querySelector('tbody');
    //     const newTbody = document.createElement('tbody');
    //     let columnCount = 0;
    //     // Rebuild the header
    //     if (thead) {
    //       const oldHeadRow = thead.querySelector('tr');
    //       if (oldHeadRow) {
    //         const newThead = document.createElement('thead');
    //         const newHeadRow = document.createElement('tr');
    //         const ths = oldHeadRow.querySelectorAll('th');
    //         columnCount = ths.length;
    //         ths.forEach((th: HTMLElement) => {
    //           const newTh = document.createElement('th');
    //           newTh.innerText = th.innerText.trim();
    //           newTh.style.backgroundColor = '#656772';
    //           newTh.style.color = '#fff';
    //           newTh.style.fontWeight = 'bold';
    //           newTh.style.textAlign = 'center';
    //           newTh.style.padding = '8px';
    //           newTh.style.fontSize = '12px';
    //           newTh.style.width = `${95 / columnCount}%`;
    //           newTh.style.border = 'none';
    //           newHeadRow.appendChild(newTh);
    //         });
    //         newThead.appendChild(newHeadRow);
    //         newTable.appendChild(newThead);
    //       }
    //     }
    //     // Rebuild rows
    //     if (tbody) {
    //       const rows = Array.from(tbody.querySelectorAll('tr')).filter(row =>
    //         Array.from(row.querySelectorAll('td')).some(td => td.textContent?.trim())
    //       );
    //       rows.forEach((row, rowIndex) => {
    //         const newRow = document.createElement('tr');
    //         const tds = row.querySelectorAll('td');
    //         tds.forEach((td: HTMLElement) => {
    //           const newTd = document.createElement('td');
    //           newTd.innerText = td.innerText.trim();
    //           newTd.style.padding = '6px';
    //           newTd.style.fontSize = '12px';
    //           newTd.style.textAlign = 'center';
    //           newTd.style.width = `${95 / columnCount}%`;
    //           newTd.style.border = 'none';
    //           newRow.appendChild(newTd);
    //         });
    //         newTbody.appendChild(newRow);
    //         // Row divider except last
    //         if (rowIndex < rows.length - 1) {
    //           const dividerRow = document.createElement('tr');
    //           const dividerTd = document.createElement('td');
    //           dividerTd.colSpan = columnCount;
    //           dividerTd.style.borderBottom = '1px solid #ccc';
    //           dividerTd.style.height = '1px';
    //           dividerTd.style.padding = '0';
    //           dividerRow.appendChild(dividerTd);
    //           newTbody.appendChild(dividerRow);
    //         }
    //       });
    //     }
    //     // Add label row from next app-view-renderers
    //     const labelRow = document.createElement('tr');
    //     const tableWrapper = table.closest('app-view-renderer');
    //     let nextSibling = tableWrapper?.nextElementSibling;
    //     let appRenderers: HTMLElement[] = [];
    //     while (nextSibling && appRenderers.length < columnCount) {
    //       if (nextSibling.tagName.toLowerCase() === 'app-view-renderer') {
    //         appRenderers.push(nextSibling as HTMLElement);
    //       }
    //       nextSibling = nextSibling.nextElementSibling;
    //     }
    //     if (appRenderers.length === columnCount) {
    //       appRenderers.forEach(renderer => {
    //         const label = renderer.querySelector('label');
    //         const td = document.createElement('td');
    //         td.innerText = label?.textContent?.trim() || '';
    //         td.style.padding = '6px';
    //         td.style.fontSize = '12px';
    //         td.style.textAlign = 'center';
    //         td.style.width = `${95 / columnCount}%`;
    //         td.style.border = 'none';
    //         labelRow.appendChild(td);
    //         renderer.remove();
    //       });
    //       newTbody.appendChild(labelRow);
    //     }
    //     newTable.appendChild(newTbody);
    //     table.parentNode?.replaceChild(newTable, table);
    //   });
    // }
    rebuildMaterialTablesInRepeatable(container) {
        const materialTables = container.querySelectorAll('block_field_42137301');
        // const materialTables = Array.from(container.querySelectorAll('table.mat-mdc-table'))
        //   // Skip tables that have class comp-223 or comp-567 (add more as needed)
        //   .filter(table =>
        //     !Array.from(table.classList).some(cls =>
        //       ['block_field_42137301'].includes(cls)
        //     )
        //   );
        materialTables.forEach((table) => {
            const newTable = document.createElement('table');
            newTable.style.pageBreakInside = 'avoid';
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            if (screenWidth === 1920 && screenHeight === 1080) {
                newTable.style.width = '92%';
            }
            else if (screenWidth === 1366 && screenHeight === 768) {
                newTable.style.width = '98%';
            }
            else {
                newTable.style.width = '90%';
            }
            newTable.style.borderCollapse = 'collapse';
            newTable.style.tableLayout = 'fixed';
            newTable.style.margin = '12px 0';
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            // Copy headers
            if (thead) {
                const newThead = document.createElement('thead');
                const oldHeadRow = thead.querySelector('tr');
                newThead.style.display = 'table-header-group';
                var columns = 0;
                if (oldHeadRow) {
                    const newHeadRow = document.createElement('tr');
                    columns = oldHeadRow.querySelectorAll('th').length;
                    oldHeadRow.querySelectorAll('th').forEach((th) => {
                        const newTh = document.createElement('th');
                        newTh.innerText = th.innerText.trim();
                        newTh.style.backgroundColor = '#656772';
                        newTh.style.color = '#ffffff';
                        newTh.style.fontWeight = 'bold';
                        newTh.style.textAlign = 'center';
                        newTh.style.padding = '8px';
                        newTh.style.fontSize = '12px';
                        newTh.style.width = `${95 / columns}%`;
                        newTh.style.border = 'none';
                        newHeadRow.appendChild(newTh);
                    });
                    newThead.appendChild(newHeadRow);
                    newTable.appendChild(newThead);
                }
            }
            // Copy body rows
            if (tbody) {
                const newTbody = document.createElement('tbody');
                const rows = Array.from(tbody.querySelectorAll('tr')).filter(row => {
                    // Skip empty rows: all <td> are empty or invisible
                    const tds = Array.from(row.querySelectorAll('td'));
                    return tds.length && tds.some(td => td.textContent?.trim());
                });
                rows.forEach((row, rowIndex) => {
                    const newRow = document.createElement('tr');
                    const columns = row.querySelectorAll('td').length;
                    row.querySelectorAll('td').forEach((td) => {
                        const value = td.innerText.trim();
                        const newTd = document.createElement('td');
                        newTd.innerText = value;
                        newTd.style.padding = '6px';
                        newTd.style.fontSize = '12px';
                        newTd.style.textAlign = 'center';
                        newTd.style.width = `${95 / columns}%`;
                        newTd.style.border = 'none';
                        newRow.appendChild(newTd);
                    });
                    newTbody.appendChild(newRow);
                    // Add gray line after each row except the last one
                    if (rowIndex < rows.length - 1) {
                        const dividerRow = document.createElement('tr');
                        const dividerTd = document.createElement('td');
                        dividerTd.colSpan = row.querySelectorAll('td').length || 1;
                        dividerTd.style.borderBottom = '1px solid #ccc';
                        dividerTd.style.height = '1px';
                        dividerTd.style.padding = '0';
                        dividerRow.style.pageBreakInside = 'avoid';
                        dividerTd.style.pageBreakInside = 'avoid';
                        dividerRow.appendChild(dividerTd);
                        newTbody.appendChild(dividerRow);
                    }
                });
                // Add label row from next app-view-renderers
                const labelRow = document.createElement('tr');
                const tableWrapper = table.closest('div');
                let nextSibling = tableWrapper?.nextElementSibling;
                let appRenderers = [];
                while (nextSibling && appRenderers.length < columns) {
                    if (nextSibling.tagName.toLowerCase() === 'div') {
                        appRenderers.push(nextSibling);
                    }
                    nextSibling = nextSibling.nextElementSibling;
                }
                if (appRenderers.length === columns) {
                    appRenderers.forEach(renderer => {
                        const label = renderer.querySelector('label');
                        const td = document.createElement('td');
                        td.innerText = label?.textContent?.trim() || '';
                        td.style.padding = '6px';
                        td.style.fontSize = '14px';
                        td.style.fontWeight = 'bold';
                        td.style.textAlign = 'center';
                        td.style.width = `${95 / columns}%`;
                        td.style.border = 'none';
                        labelRow.appendChild(td);
                        renderer.remove();
                    });
                    newTbody.appendChild(labelRow);
                }
                newTable.appendChild(newTbody);
            }
            table.parentNode?.replaceChild(newTable, table);
            // Replace original table
            // table.parentNode?.replaceChild(newTable, table);
        });
        const targetSection1 = document.querySelector('.cee-section.row.section-0-0-1-0-4.step-44974.template-');
        if (targetSection1) {
            targetSection1.style.marginTop = '24px'; // or any value you prefer
        }
        const targetSection2 = document.querySelector('.cee-section.row.section-0-0-1-4-0.step-45237.template-');
        if (targetSection2) {
            targetSection2.style.marginTop = '50px'; // or any value you prefer
        }
    }
    rebuildMaterialTables(container) {
        //const materialTables = container.querySelectorAll('table.mat-mdc-table');
        const materialTables = Array.from(container.querySelectorAll('table.mat-mdc-table'))
            // Skip tables that have class comp-223 or comp-567 (add more as needed)
            .filter(table => !Array.from(table.classList).some(cls => ['block_field_42137301'].includes(cls)));
        materialTables.forEach((table) => {
            const newTable = document.createElement('table');
            newTable.style.pageBreakInside = 'avoid';
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            if (screenWidth === 1920 && screenHeight === 1080) {
                newTable.style.width = '92%';
            }
            else if (screenWidth === 1366 && screenHeight === 768) {
                newTable.style.width = '98%';
            }
            else {
                newTable.style.width = '90%';
            }
            newTable.style.borderCollapse = 'collapse';
            newTable.style.tableLayout = 'fixed';
            newTable.style.margin = '12px 0';
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            // Copy headers
            if (thead) {
                const newThead = document.createElement('thead');
                const oldHeadRow = thead.querySelector('tr');
                newThead.style.display = 'table-header-group';
                var columns = 0;
                if (oldHeadRow) {
                    const newHeadRow = document.createElement('tr');
                    columns = oldHeadRow.querySelectorAll('th').length;
                    oldHeadRow.querySelectorAll('th').forEach((th) => {
                        const newTh = document.createElement('th');
                        newTh.innerText = th.innerText.trim();
                        newTh.style.backgroundColor = '#656772';
                        newTh.style.color = '#ffffff';
                        newTh.style.fontWeight = 'bold';
                        newTh.style.textAlign = 'center';
                        newTh.style.padding = '8px';
                        newTh.style.fontSize = '12px';
                        newTh.style.width = `${95 / columns}%`;
                        newTh.style.border = 'none';
                        newHeadRow.appendChild(newTh);
                    });
                    newThead.appendChild(newHeadRow);
                    newTable.appendChild(newThead);
                }
            }
            // Copy body rows
            if (tbody) {
                const newTbody = document.createElement('tbody');
                const rows = Array.from(tbody.querySelectorAll('tr')).filter(row => {
                    // Skip empty rows: all <td> are empty or invisible
                    const tds = Array.from(row.querySelectorAll('td'));
                    return tds.length && tds.some(td => td.textContent?.trim());
                });
                rows.forEach((row, rowIndex) => {
                    const newRow = document.createElement('tr');
                    const columns = row.querySelectorAll('td').length;
                    row.querySelectorAll('td').forEach((td) => {
                        const value = td.innerText.trim();
                        const newTd = document.createElement('td');
                        newTd.innerText = value;
                        newTd.style.padding = '6px';
                        newTd.style.fontSize = '12px';
                        newTd.style.textAlign = 'center';
                        newTd.style.width = `${95 / columns}%`;
                        newTd.style.border = 'none';
                        newRow.appendChild(newTd);
                    });
                    newTbody.appendChild(newRow);
                    // Add gray line after each row except the last one
                    if (rowIndex < rows.length - 1) {
                        const dividerRow = document.createElement('tr');
                        const dividerTd = document.createElement('td');
                        dividerTd.colSpan = row.querySelectorAll('td').length || 1;
                        dividerTd.style.borderBottom = '1px solid #ccc';
                        dividerTd.style.height = '1px';
                        dividerTd.style.padding = '0';
                        dividerRow.style.pageBreakInside = 'avoid';
                        dividerTd.style.pageBreakInside = 'avoid';
                        dividerRow.appendChild(dividerTd);
                        newTbody.appendChild(dividerRow);
                    }
                });
                // Add label row from next app-view-renderers
                const labelRow = document.createElement('tr');
                const tableWrapper = table.closest('app-view-renderer');
                let nextSibling = tableWrapper?.nextElementSibling;
                let appRenderers = [];
                while (nextSibling && appRenderers.length < columns) {
                    if (nextSibling.tagName.toLowerCase() === 'app-view-renderer') {
                        appRenderers.push(nextSibling);
                    }
                    nextSibling = nextSibling.nextElementSibling;
                }
                if (appRenderers.length === columns) {
                    appRenderers.forEach(renderer => {
                        const label = renderer.querySelector('label');
                        const td = document.createElement('td');
                        td.innerText = label?.textContent?.trim() || '';
                        td.style.padding = '6px';
                        td.style.fontSize = '14px';
                        td.style.fontWeight = 'bold';
                        td.style.textAlign = 'center';
                        td.style.width = `${95 / columns}%`;
                        td.style.border = 'none';
                        labelRow.appendChild(td);
                        renderer.remove();
                    });
                    newTbody.appendChild(labelRow);
                }
                newTable.appendChild(newTbody);
            }
            table.parentNode?.replaceChild(newTable, table);
            // Replace original table
            // table.parentNode?.replaceChild(newTable, table);
        });
        const targetSection1 = document.querySelector('.cee-section.row.section-0-0-1-0-4.step-44974.template-');
        if (targetSection1) {
            targetSection1.style.marginTop = '24px'; // or any value you prefer
        }
        const targetSection2 = document.querySelector('.cee-section.row.section-0-0-1-4-0.step-45237.template-');
        if (targetSection2) {
            targetSection2.style.marginTop = '50px'; // or any value you prefer
        }
    }
    removeCheckboxUnderline() {
        document.querySelectorAll('app-view-renderer.border-bottom').forEach(el => {
            if (el.querySelector('input[type="checkbox"]')) {
                el.classList.remove('border-bottom');
            }
        });
    }
    adjustDollerPrepend() {
        document.querySelectorAll('.form-field.input-group').forEach(container => {
            const prependSpan = container.querySelector('.input-group-prepend span.input-group-text');
            const input = container.querySelector('input');
            if (prependSpan && prependSpan.textContent.trim() === '$' && input) {
                // Remove the prepend span's parent div
                prependSpan.closest('.input-group-prepend')?.remove();
                // Format the input value with commas and 2 decimal places
                let rawValue = input.value.replace(/[^\d.-]/g, ''); // Remove non-numeric except . and -
                let numericValue = parseFloat(rawValue);
                if (!isNaN(numericValue)) {
                    const formatted = `$ ${numericValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                    input.value = formatted;
                }
                else {
                    // fallback if value is empty or invalid
                    input.value = `$ 0.00`;
                }
            }
        });
    }
    adjustPercentageSuffix() {
        document.querySelectorAll('.form-field.input-group').forEach(container => {
            const appendSpan = container.querySelector('.input-group-append span.input-group-text');
            const input = container.querySelector('input');
            if (appendSpan && appendSpan.textContent.trim() === '%' && input) {
                // Remove the % span's parent div (if exists)
                const appendWrapper = appendSpan.closest('.input-group-append');
                if (appendWrapper)
                    appendWrapper.remove();
                // Clean and validate value
                let rawValue = input.value?.toString().trim() ?? '';
                let sanitized = rawValue.replace(/[^\d.-]/g, '');
                let numericValue = parseFloat(sanitized);
                if (!isNaN(numericValue) && isFinite(numericValue)) {
                    const formatted = `${numericValue.toLocaleString('en-US', {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2
                    })}%`;
                    input.value = formatted;
                }
                else {
                    // If no valid value (empty/null/Infinity), show "N/A%" underlined
                    input.value = 'N/A%';
                    input.style.textDecoration = 'underline';
                }
            }
        });
    }
    boldAndColorInLabel(combinedContainer) {
        combinedContainer.querySelectorAll('app-view-renderer').forEach(renderer => {
            const isGray = renderer.classList.contains('cf-label-gray');
            const labels = renderer.querySelectorAll('label');
            // If this renderer contains repeatable-block-renderer and app-cee-textfield, change label color
            const hasRepeatableBlock = !!renderer.querySelector('repeatable-block-renderer');
            const hasTextfield = !!renderer.querySelector('app-cee-textfield');
            labels.forEach(label => {
                // Skip labels inside table rows
                const isInTableRow = !!label.closest('tr');
                if (isInTableRow)
                    return;
                // If label is inside repeatable-block-renderer and is an app-cee-label with both sub-heading and main-heading, ignore
                const isInRepeatableBlock = !!label.closest('repeatable-block-renderer');
                const isAppCeeLabel = label.closest('app-cee-label');
                const isAppCeeTextfield = label.closest('app-cee-textfield');
                const hasSubHeading = label.classList.contains('sub-heading');
                const hasMainHeading = label.classList.contains('main-heading');
                const signatures = label.classList.contains('cf-label-border-top');
                const isNonRepeatable = label.classList.contains('nonrepeatable');
                // const borroweracknowledgem = label.classList.contains('borroweracknowledgem');
                //for bc letter of direction sign
                const textgray = label.classList.contains('cf-text-gray');
                if (textgray) {
                    label.style.fontWeight = 'bold';
                    label.style.color = '#808080';
                }
                if (isInRepeatableBlock &&
                    isAppCeeLabel &&
                    hasSubHeading ||
                    hasMainHeading ||
                    signatures) {
                    return;
                }
                // If label has nonrepeatable class, set color to grey
                if (isNonRepeatable) {
                    label.style.fontWeight = 'bold';
                    label.style.color = '#808080';
                }
                // Special color if both repeatable-block-renderer and app-cee-textfield are present
                else if (hasRepeatableBlock && hasTextfield) {
                    label.style.fontWeight = 'bold';
                    label.style.color = '#808080';
                }
                else if (isGray) {
                    label.style.fontWeight = 'bold';
                    label.style.color = '#808080';
                }
                else {
                    label.style.fontWeight = 'bold';
                    label.style.color = '#000';
                    label.style.marginTop = '2px';
                }
                if (isAppCeeTextfield) {
                    label.style.fontWeight = 'bold';
                    label.style.color = '#808080';
                }
            });
        });
        const visibleDocSignElements = combinedContainer.querySelectorAll('.visible_doc_sign');
        visibleDocSignElements.forEach((node) => {
            if (node.tagName.toLowerCase() === 'label') {
                node.style.color = 'white';
                node.style.userSelect = 'none';
            }
            else {
                // Find all labels inside this element
                const labels = node.querySelectorAll('label');
                labels.forEach(label => {
                    label.style.color = 'white';
                    label.style.userSelect = 'none';
                });
            }
        });
        const partdfees = combinedContainer.querySelectorAll('.app-view-renderer-13_45453-5,' +
            '.comp-767690.disclosuretoborrower.sub-heading,' +
            '.app-view-renderer-16_45264-5,' +
            '.app-view-renderer-11_45248-1,' +
            '.app-view-renderer-13_45248-8,' +
            '.app-view-renderer-6_45068-5,' +
            '.comp-047998.mortgagetermsanddeta.sub-heading,' +
            '.borroweracknowledgem.comp-315380,' +
            '.comp-272030.propertydetails.sub-heading,' +
            '.borroweracknowledgem.comp-270575,' +
            '.comp-522024.propertydetails.sub-heading,' +
            '.comp-080556.mortgagedisclosure.sub-heading,' +
            '.comp-622582.mortgagedisclosure.sub-heading,' +
            '.borroweracknowledgem.comp-653290,' +
            '.comp-725363.partctheborrower.sub-heading,' +
            '.comp-764349.initials,' +
            '.comp-250920.initials,' +
            '.comp-645768.partbmortgageparticu,' +
            '.applicablefees.comp-045882.sub-heading,' +
            '.comp-310803.disclosures.sub-heading,' +
            '.borroweracknowledgem.comp-181498,' +
            '.borroweracknowledgem.comp-334366,' +
            '.comp-668063.propertydetails.sub-heading,' +
            '.comp-938657.mortgagedetails,' +
            '.comp-438653.propertydetails.sub-heading,' +
            '.comp-798931.mortgagepaymentinfor,' +
            '.comp-246925.mortgagepaymentinfor,' +
            '.comp-144347.rankofmortgage.sub-heading,' +
            '.comp-833723.icertification,' +
            '.comp-497578.loantovalueratioacco.sub-heading,' +
            '.comp-307024.hattacheddocuments,' +
            '.comp-999391.loantovalueratioacco,' +
            // '.borroweracknowledgem.comp-723061,' +
            '.comp-807498.partbmortgageparticu,' +
            '.comp-224544.partctheborrower,' +
            '.comp-343255.left-space.partbmortgageparticu,' +
            '.comp-529992.left-space.partdfees,' +
            '.comp-736184.importantthemortgage,' +
            '.comp-114778.partdfees,' +
            '.comp-070703.partdfees,' +
            '.comp-819861.partdfees.sub-heading,' +
            '.comp-417125.left-space.partbmortgageparticu,' +
            '.comp-061817.mortgagedetails.sub-heading,' +
            '.comp-144962.propertydetails.sub-heading,' +
            '.comp-853672.sectiondeclarationby,' +
            '.acknowledgement.comp-896244,' +
            '.comp-221634.left-space.partbmortgageparticu,' +
            '.comp-415093.left-space.partbmortgageparticu,' +
            '.comp-752238.interestinrecommende');
        // console.log("partdfees", partdfees);
        partdfees.forEach((node) => {
            node.style.marginTop = '55px';
        });
        const blackColorForNonrepeatable = combinedContainer.querySelectorAll('.comp-997412,.comp-226055,.number_list');
        // console.log("blackColorForNonrepeatable", blackColorForNonrepeatable);
        blackColorForNonrepeatable.forEach((node) => {
            node.style.fontWeight = 'bold';
            node.style.color = '#000';
        });
        const personalandconfident = combinedContainer.querySelectorAll('.comp-631870,.comp-054755');
        // console.log("personalandconfident", personalandconfident);
        personalandconfident.forEach((node) => {
            node.style.fontWeight = 'bold';
            node.style.color = '#808080';
        });
        const rankofmortgage = combinedContainer.querySelectorAll('.comp-709368.mortgagedetails,' +
            '.borroweracknowledgem.comp-715493,' +
            '.borroweracknowledgem.comp-795512,' +
            '.comp-061026.partdfees,' +
            '.comp-790134.partdfees,' +
            '.app-view-renderer-7_45280-21,' +
            // '.comp-659751.downpaymentsources.sub-heading,'+
            // '.field-wrapper.comp-00935933,'+
            // '.field-wrapper.comp-748372.disclosureandcredita,'+
            // '.app-view-renderer-5_45280-4,'+
            '.comp-103822.mortgagedetails,' +
            '.comp-144347.rankofmortgage.sub-heading,' +
            '.borroweracknowledgem.comp-911826');
        // console.log("rankofmortgage", rankofmortgage);
        rankofmortgage.forEach((node) => {
            node.style.marginTop = '5px';
        });
        const earlyendtothisagreem = combinedContainer.querySelectorAll('.number_list_inner span');
        // console.log("labels--", earlyendtothisagreem);
        earlyendtothisagreem.forEach((span) => {
            // Add margin-right to the span for spacing after the "d)", "b)", etc.
            // span.style.marginRight = '4px'; // adjust px as needed
            span.style.display = 'inline-block';
            span.style.width = '2em';
            span.style.textAlign = 'right';
            span.style.marginRight = '0.5em';
            span.style.flexShrink = '0';
        });
        const number_list_inner = combinedContainer.querySelectorAll('.earlyendtothisagreem,.number_list_inner');
        // console.log("number_list_inner--", number_list_inner);
        number_list_inner.forEach((span) => {
            span.style.display = 'flex';
            span.style.alignItems = 'flex-start'; /* Aligns the text nicely at the top */
            // span.style.marginBottom = '8px';
        });
        const borroweracknowledgem = combinedContainer.querySelectorAll('.borroweracknowledgem.comp-723061,' +
            '.borroweracknowledgem.comp-911826,' +
            '.borroweracknowledgem.comp-653290,' +
            '.borroweracknowledgem.comp-882636,' +
            '.borroweracknowledgem.comp-181498,' +
            '.borroweracknowledgem.comp-334366,' +
            '.borroweracknowledgem.comp-229059,' +
            '.borroweracknowledgem.comp-860567,' +
            '.comp-849985.mortgagedetails,' +
            '.comp-898828.partfcertification,' +
            '.borroweracknowledgem.comp-723061,' +
            '.borroweracknowledgem.comp-229059,' +
            'unique_field_052487,' +
            '.unique_field_683645');
        // console.log("borroweracknowledgem", borroweracknowledgem);
        borroweracknowledgem.forEach((node) => {
            node.style.marginTop = '65px'; // test
        });
        const sectionIdsToOffset = ['16_45423', '17_45423', '18_45423', '20_45423', '21_45423'];
        sectionIdsToOffset.forEach(id => {
            const section = document.getElementById(id);
            if (section) {
                section.style.marginTop = '20px';
            }
        });
        const sectionIdsToOffset1 = ['6_45219', '11_45032'];
        sectionIdsToOffset1.forEach(id => {
            const section = document.getElementById(id);
            if (section) {
                section.style.marginTop = '50px';
            }
        });
        const subjectPropertyHeading = combinedContainer.querySelectorAll('.comp-090171.sub-heading,' +
            '.comp-391105.mortgagesummary.sub-heading,' +
            '.comp-228213.mortgagesummary.sub-heading,' +
            '.app-view-renderer-7_46578-0');
        // console.log("borroweracknowledgem", borroweracknowledgem);
        subjectPropertyHeading.forEach((node) => {
            node.style.marginTop = '10px'; // test
        });
        const tableHeaderSection = document.getElementById('7_46578');
        if (tableHeaderSection) {
            //  console.log("tableHeaderSection found: ", tableHeaderSection);
            tableHeaderSection.style.marginTop = '50px';
        }
    }
    removeAddButton(container) {
        // Search within the container element, not the entire document
        const addButtons = container.querySelectorAll('button[aria-label="Click on Add"]');
        // Hide all matching buttons
        for (let i = 0; i < addButtons.length; i++) {
            const addButton = addButtons[i];
            if (addButton) {
                // Try multiple approaches to ensure it's hidden
                addButton.style.display = 'none';
                addButton.style.visibility = 'hidden';
                addButton.style.opacity = '0';
                addButton.style.position = 'absolute';
                addButton.style.pointerEvents = 'none';
                // Also try removing it completely
                addButton.parentNode?.removeChild(addButton);
            }
        }
        // Also try with other potential selectors
        const alternativeButtons = container.querySelectorAll('.add-button, button.add, [class*="add-btn"]');
        for (let i = 0; i < alternativeButtons.length; i++) {
            const btn = alternativeButtons[i];
            if (btn) {
                btn.style.display = 'none';
                btn.parentNode?.removeChild(btn);
            }
        }
    }
    fixStepLabelOverlapping(container) {
        const innerNumberlist = container.querySelectorAll('.cf-form-step label');
        innerNumberlist.forEach((el) => {
            // Apply font and basic styles
            el.style.fontFamily = "Quicksand";
            el.style.marginBottom = "4px"; // Space between lines if they're stacked vertically
        });
    }
    // Handler inner bullet points overlapping fixed
    fixOverlappingBulletPoints(container) {
        const innerNumberlist = container.querySelectorAll('.number_list_inner');
        innerNumberlist.forEach((el) => {
            // Apply font and basic styles
            el.style.fontFamily = "Quicksand";
            el.style.color = "#000";
            el.style.fontSize = "14px";
            el.style.lineHeight = "1.4"; // Increased for better line spacing
            el.style.letterSpacing = '0.3px';
            el.style.paddingRight = "0px"; // Reset padding
            el.style.marginTop = "4px"; // Space between lines if they're stacked vertically
            // Optional: Adjust vertical spacing with margin
            el.style.marginBottom = "10px"; // Space between lines if they're stacked vertically
        });
    }
    // Add this function to handle nested label structures
    fixNestedLabelStructures(container) {
        try {
            // Target labels with spans inside them, especially the termoftheagreement class
            const complexLabels = container.querySelectorAll('label.termoftheagreement, label.number_list');
            complexLabels.forEach((label) => {
                // Get the full text content
                const fullText = label.textContent?.trim() || '';
                // Create a new simpler element to replace the complex structure
                const simplifiedElement = document.createElement('div');
                simplifiedElement.textContent = fullText;
                // Copy styles from the original label
                const computedStyle = window.getComputedStyle(label);
                // Apply key styles to the new element
                simplifiedElement.style.fontFamily = 'Quicksand';
                simplifiedElement.style.fontSize = computedStyle.fontSize;
                simplifiedElement.style.fontWeight = label.classList.contains('termoftheagreement') ? 'bold' : 'normal';
                simplifiedElement.style.color = '#000';
                simplifiedElement.style.margin = '10px 0';
                simplifiedElement.style.padding = '0';
                simplifiedElement.style.display = 'block';
                simplifiedElement.style.lineHeight = '1.5';
                simplifiedElement.style.letterSpacing = '0.4px';
                // Add classes for identification but remove Angular attributes
                label.classList.forEach(className => {
                    simplifiedElement.classList.add(className);
                });
                // Replace the original complex element with our simplified version
                if (label.parentNode) {
                    label.parentNode.replaceChild(simplifiedElement, label);
                }
            });
            // Also look for any elements with number_list class
            const numberListItems = container.querySelectorAll('.number_list');
            numberListItems.forEach((item) => {
                if (item.tagName !== 'DIV') { // Skip if we already processed it above
                    // Extract number and content
                    const spanElement = item.querySelector('span');
                    const number = spanElement ? spanElement.textContent : '';
                    // Remove the span to get just the content
                    let content = item.textContent || '';
                    if (number) {
                        content = content.replace(number, '');
                    }
                    // Create a simplified version
                    const simplifiedItem = document.createElement('div');
                    simplifiedItem.textContent = (number || '') + content;
                    // Copy styles and classes
                    const computedStyle = window.getComputedStyle(item);
                    simplifiedItem.style.fontFamily = 'Quicksand';
                    simplifiedItem.style.fontSize = computedStyle.fontSize;
                    simplifiedItem.style.fontWeight = item.classList.contains('termoftheagreement') ? 'bold' : 'normal';
                    simplifiedItem.style.color = '#000';
                    simplifiedItem.style.margin = '8px 0';
                    simplifiedItem.style.padding = '0';
                    simplifiedItem.style.display = 'block';
                    // Copy classes
                    item.classList.forEach(className => {
                        simplifiedItem.classList.add(className);
                    });
                    // Replace the original
                    if (item.parentNode) {
                        item.parentNode.replaceChild(simplifiedItem, item);
                    }
                }
            });
        }
        catch (error) {
            console.error('Error fixing nested label structures:', error);
        }
    }
    findLabelText(inputElement) {
        // First try to find a label with a 'for' attribute matching this input's id
        if (inputElement.id) {
            const label = document.querySelector(`label[for="${inputElement.id}"]`);
            if (label)
                return label.textContent || '';
        }
        // Next check if the input is inside a label
        let parent = inputElement.parentElement;
        while (parent) {
            if (parent.tagName === 'LABEL') {
                // Get text content but exclude the input's value
                const clone = parent.cloneNode(true);
                const inputs = clone.querySelectorAll('input');
                inputs.forEach(input => input.parentNode?.removeChild(input));
                return clone.textContent?.trim() || '';
            }
            if (parent === document.body)
                break;
            parent = parent.parentElement;
        }
        // If no label found, try looking for sibling text or neighboring labels
        let sibling = inputElement.nextSibling;
        while (sibling) {
            if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent?.trim()) {
                return sibling.textContent.trim();
            }
            if (sibling.nodeType === Node.ELEMENT_NODE &&
                sibling.tagName === 'LABEL') {
                return sibling.textContent || '';
            }
            sibling = sibling.nextSibling;
        }
        // If all else fails, return empty string or the name attribute
        return inputElement.name || '';
    }
    getCurrentTimestamp(format) {
        const now = new Date();
        const pad = (n) => n.toString().padStart(2, '0');
        const replacements = {
            yyyy: now.getFullYear().toString(),
            mm: pad(now.getMonth() + 1),
            dd: pad(now.getDate()),
            hh: pad(now.getHours()),
            mi: pad(now.getMinutes()),
            ss: pad(now.getSeconds())
        };
        // Normalize all matches to lowercase and replace using the above keys
        return format.replace(/YYYY|MM|DD|HH|MI|SS/gi, (match) => {
            const normalized = match.toLowerCase();
            switch (normalized) {
                case 'yyyy': return replacements.yyyy;
                case 'mm': return replacements.mm;
                case 'dd': return replacements.dd;
                case 'hh': return replacements.hh;
                case 'mi': return replacements.mi;
                case 'ss': return replacements.ss;
                default: return match;
            }
        });
    }
    // Function to insert timestamp before file extension
    getTimestampedFilename(filename, format) {
        if (!format)
            return filename;
        const timestamp = this.getCurrentTimestamp(format);
        const lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex === -1) {
            return `${filename}_${timestamp}`;
        }
        const namePart = filename.substring(0, lastDotIndex);
        const extension = filename.substring(lastDotIndex);
        return `${namePart}_${timestamp}${extension}`;
    }
    printAndDownload(event) {
        const self = this;
        this.eventAdditionalParams = this.getAdditionalParameter();
        const printFormat = this.eventAdditionalParams['CEE_PRINT_FORMAT'] ? this.eventAdditionalParams['CEE_PRINT_FORMAT'].toLowerCase() : "pdf";
        const source = this.eventAdditionalParams['CEE_PRINT_SOURCE']; // "0_1221||1_1221"
        const parts = source.split(/##|\.\s*|\[\*\]/g).filter(Boolean);
        const containerIds = (event['event_handler'] && event['event_handler'].toLowerCase() === 'step')
            ? source.split('||').map(id => 'stepblock-' + id) // Split and map with prefix
            : source.split('||'); // Split directly if not 'step'
        const containerIdFooter = (event['event_handler'] && event['event_handler'].toLowerCase() == 'step') ? 'stepblock-' + this.eventAdditionalParams['CEE_PRINT_SOURCE_HEADER'] : this.eventAdditionalParams['CEE_PRINT_SOURCE_HEADER'];
        // Flatten the array to ensure proper structure
        const splitContainerIds = [...containerIds];
        var filename = this.eventAdditionalParams['CEE_PRINT_FILE_NAME'] ? this.eventAdditionalParams['CEE_PRINT_FILE_NAME'] : "report_pdf.pdf";
        const filenameTimeStamp = this.eventAdditionalParams['CEE_PRINT_TIMESTAMP'] ? this.eventAdditionalParams['CEE_PRINT_TIMESTAMP'] : "";
        filename = this.getTimestampedFilename(filename, filenameTimeStamp);
        //var filename = this.eventAdditionalParams['CEE_PRINT_FILE_NAME'] ? this.eventAdditionalParams['CEE_PRINT_FILE_NAME'] : "report_pdf.pdf"
        switch (printFormat) {
            case "downloadpdf":
                this.downloadFromS3(event);
                break;
            case "pdf":
                const regexForName = /\{(.*?)\}/g;
                const pdfFileName = this.eventAdditionalParams['CEE_PRINT_FILE_NAME'] ? this.getFileName(this.eventAdditionalParams['CEE_PRINT_FILE_NAME'], '', regexForName) : "report_pdf.pdf";
                // this.casePdfGenerate(event);
                this.sharedEventsServices.generatePdfUsingShadowDom.emit({
                    additionalParameters: this.eventAdditionalParams,
                    pdfFileName: pdfFileName,
                    event: event
                });
                const apiConfigToken = this.sharedEventsServices.printUploadUsingShadowDom.subscribe(async (res) => {
                    this.printUpload(res.blob, res.fileName, res.success, res.failure);
                    apiConfigToken.unsubscribe();
                });
                break;
            case "csv":
                let apiDatas = this.apiDataService.getApiDataByHandler(splitContainerIds[0].split('##')[0]);
                var apiKeyValue = this.getApiKeyValuePair(apiDatas);
                // console.log("apiKeyValue: ", apiKeyValue)
                const replacer = (key, value) => value === null ? '' : value; // specify how you want to handle null values here
                // find row with max keys so can cover all headers
                let indexWithMaxKeys = 0;
                if (apiKeyValue && apiKeyValue.length) {
                    indexWithMaxKeys = apiKeyValue.reduce((maxIndex, currentRow, currentIndex) => {
                        if (Object.keys(currentRow).length > Object.keys(apiKeyValue[maxIndex]).length) {
                            return currentIndex; // Return current index if current row has more keys
                        }
                        return maxIndex; // Keep the maxIndex if no update is needed
                    }, 0);
                }
                const header = Object.keys(apiKeyValue[indexWithMaxKeys]);
                let csv = apiKeyValue.map(row => header.map(fieldName => JSON.stringify(row[fieldName], replacer)).join(','));
                csv.unshift(header.join(','));
                let csvArray = csv.join('\r\n');
                var blob = new Blob([csvArray], { type: 'text/csv' });
                saveAs(blob, filename);
                break;
            case "excel":
            case "xls":
            case "xlsx":
                // const apiDatasExcel = this.apiDataService.getApiDataByHandler(splitContainerIds[0].split('##')[0]);
                // const apiKeyValueExcel = this.getApiKeyValuePair(apiDatasExcel);
                // if (apiKeyValueExcel && apiKeyValueExcel.length) {
                //     const worksheet = XLSX.utils.json_to_sheet(apiKeyValueExcel);
                //     const workbook = XLSX.utils.book_new();
                //     XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
                //     const excelBuffer = XLSX.write(workbook, {
                //         bookType: printFormat === "xls" ? "biff8" : "xlsx", // <== fixed
                //         type: "array"
                //     });
                //     const blob = new Blob([excelBuffer], {
                //         type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                //     });
                //     saveAs(blob, filename.endsWith('.xlsx') || filename.endsWith('.xls') ? filename : filename + (printFormat === 'xls' ? '.xls' : '.xlsx'));
                // }
                const apiDatasExcelM = this.apiDataService.getApiDataByHandler(splitContainerIds[0].split('##')[0]);
                let updatedData = Object.keys(apiDatasExcelM.value).reduce((acc, key) => {
                    let newKey = key.replace(apiDatasExcelM.value.handler_name + '##', "");
                    acc[newKey] = apiDatasExcelM.value[key];
                    return acc;
                }, {});
                const blobdata = new Blob();
                const dats = this.unflattenJSON(updatedData);
                const arrs = Object.entries(dats[parts[1]]);
                const apiDatasExcels = arrs.map(([key, value]) => {
                    return { propertyName: key, value: value };
                });
                const workbook = XLSX.utils.book_new();
                for (let i = 0; i < apiDatasExcels.length; i++) {
                    let data = [];
                    if (parts.length > 1 && parts.includes(apiDatasExcels[i].propertyName)) { // If the property name is in the list, we can skip it
                        //console.log(apiDatasExcels[i].propertyName);
                        for (let j = 0; j < Object.keys(apiDatasExcels[i].value).length; j++) {
                            // Access specific properties
                            //console.log(apiDatasExcels[i].value[Object.keys(apiDatasExcels[i].value)[j]]);
                            data.push(apiDatasExcels[i].value[Object.keys(apiDatasExcels[i].value)[j]]);
                        }
                    }
                    else if (parts.length === 2 && !parts.includes(apiDatasExcels[i].propertyName)) {
                        // If the property name is in the list, we can skip it
                        for (let j = 0; j < Object.keys(apiDatasExcels[i].value).length; j++) {
                            // Access specific properties
                            //console.log(apiDatasExcels[i].value[Object.keys(apiDatasExcels[i].value)[j]]);
                            data.push(apiDatasExcels[i].value[Object.keys(apiDatasExcels[i].value)[j]]);
                        }
                    }
                    if (data.length > 0) {
                        const worksheet = data.length > 0 ? XLSX.utils.json_to_sheet(data) : XLSX.utils.aoa_to_sheet([]);
                        //const workbook = XLSX.utils.book_new();
                        if ((parts.length > 1 && parts.includes(apiDatasExcels[i].propertyName)) || (parts.length === 2 && !parts.includes(apiDatasExcels[i].propertyName))) {
                            XLSX.utils.book_append_sheet(workbook, worksheet, apiDatasExcels[i].propertyName);
                        }
                        const excelBuffer = XLSX.write(workbook, {
                            bookType: printFormat === "xls" ? "biff8" : "xlsx",
                            type: "array"
                        });
                        //workbook.SheetNames.push(apiDatasExcels[i].propertyName);
                        const blob = data.length > 0 ? new Blob([excelBuffer], {
                            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        }) : new Blob([blobdata], {});
                        if (parts.length == 2 && i === apiDatasExcels.length - 1) {
                            saveAs(blob, filename.endsWith('.xlsx') || filename.endsWith('.xls') ? filename : filename + (printFormat === 'xls' ? '.xls' : '.xlsx'));
                        }
                        else if (parts.length > 2) {
                            saveAs(blob, filename.endsWith('.xlsx') || filename.endsWith('.xls') ? filename : filename + (printFormat === 'xls' ? '.xls' : '.xlsx'));
                        }
                    }
                }
                break;
            default:
                break;
        }
    }
    /**
    * method returns the name based on the configuration
    * @param originalName the original name from where
    * @param fileName the file name of the file
    * @param regex the regex from which the dynamic variables needs to be extracted
    * @returns the result name
    */
    getFileName(originalName, fileName, regex) {
        let result = originalName;
        const matched = originalName.match(new RegExp(regex));
        if (matched) {
            for (const name of matched) {
                let val = '';
                switch (name.toLowerCase()) {
                    case '{filename}':
                        val = fileName;
                        break;
                    case '{yyyymmddhhmmss}':
                    case '{timestamp}':
                        val = String(new Date().getTime());
                        break;
                    default:
                        if (name.includes('##')) {
                            const values = name.match(new RegExp(/[^{}]+/g));
                            const key = values ? values[0] : name;
                            const handlerData = this.apiDataService.getApiDataByHandler(key.split('##')[0]);
                            val = handlerData ? handlerData.value[key] : '';
                        }
                        else {
                            const apiData = this.apiDataService.getApiDataByApiKey(name);
                            val = apiData ? apiData.value : '';
                        }
                        break;
                }
                result = result.split(name).join(val);
            }
        }
        return result;
    }
    unflattenJSON(flatObj) {
        const result = {};
        for (const key in flatObj) {
            if (flatObj.hasOwnProperty(key)) {
                const keys = key.split('.');
                let current = result;
                for (let i = 0; i < keys.length; i++) {
                    const part = keys[i];
                    const arrayMatch = part.match(/(\w+)\[(\d+)\]/);
                    if (arrayMatch) {
                        // Handle array notation
                        const arrayKey = arrayMatch[1];
                        const arrayIndex = parseInt(arrayMatch[2]);
                        current[arrayKey] = current[arrayKey] || [];
                        if (i === keys.length - 1) {
                            current[arrayKey][arrayIndex] = flatObj[key];
                        }
                        else {
                            current[arrayKey][arrayIndex] = current[arrayKey][arrayIndex] || {};
                            current = current[arrayKey][arrayIndex];
                        }
                    }
                    else {
                        // Handle object notation
                        if (i === keys.length - 1) {
                            current[part] = flatObj[key];
                        }
                        else {
                            current[part] = current[part] || {};
                            current = current[part];
                        }
                    }
                }
            }
        }
        return result;
    }
    printUpload(blobObject, fileName, success, failure) {
        this.showLoader("Uploading PDF... Please wait.");
        let extraConfigData = {};
        const apiConfigData = localStorage.getItem('API_CONFIG');
        const parsedData = apiConfigData ? JSON.parse(apiConfigData) : null;
        if (parsedData && parsedData["file/upload"]) {
            extraConfigData = this.externalRequestResponseUtil.formTheRequestObj(parsedData["file/upload"]);
        }
        if (window.sessionStorage.getItem('CEE_OIDC') == '1' &&
            extraConfigData.hasAuthorisation == true) {
            const apiConfigToken = this.sharedEventsServices.apiConfigTokenEmitter.subscribe(async (res) => {
                this.uploads3pdf(res, blobObject, fileName, success, failure);
                apiConfigToken.unsubscribe();
            });
        }
        if (window.sessionStorage.getItem('CEE_OIDC') == '1' &&
            extraConfigData.hasAuthorisation == true) {
            extraConfigData.emitToken = true;
            this.sharedEventsServices.oidcDataEmitter.emit(extraConfigData);
        }
        else {
            this.uploads3pdf(extraConfigData, blobObject, fileName, success, failure);
        }
        // this.hideLoader()
    }
    async uploads3pdf(extraConfigData, blobObject, fileName, success, failure) {
        const timestamp = Date.now(); // date cuttent
        let payload = {
            type: "application/pdf",
            fileData: {
                apiKey: "",
                name: "testFileName",
                type: "application/pdf",
                attachmentName: fileName.toString(),
                key: "uploaded.pdf",
                attachmentPath: "",
                file: blobObject,
                fileSize: blobObject["size"],
                size: blobObject["size"],
                uId: timestamp.toString(),
            }
        };
        const response = await this.fileUploadService.genericFileService("OnUpload", payload, extraConfigData, "file/upload");
        if (Number(response.statusCode) === 200) {
            // call on response or on success
            if (response.emit) {
                const apiKeyData = this.apiDataService.getApiDataByHandler("file/upload");
                this.sharedEventsServices.emitApiSuccessResponse.emit(apiKeyData.value);
            }
            const successCallback = this.processCallbackBlocks({ body: response.data, status: response.statusCode }, success);
            if (successCallback && success) {
                this.getOnSuccess(successCallback);
            }
        }
        else {
            // call on exception or on failure
            if (response.emit) {
                this.sharedEventsServices.emitApiErrorResponse.emit(response.data);
            }
            const failureCallback = this.processCallbackBlocks({ body: response.data, status: response.statusCode }, failure);
            if (failureCallback && failure) {
                this.getOnFailure(failureCallback);
            }
        }
        setTimeout(() => {
            this.hideLoader();
        }, 500);
    }
    stripHtml(html) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = html;
        return tempDiv.textContent || tempDiv.innerText || "";
    }
    eventConfig(config, handler, primaryData = {}) {
        // console.log('config.display_step', config.display_step);
        // console.log('handler', handler);
        // event config will execute the step
        this.skipLoaderCheck();
        const flagBtn = localStorage.getItem('isButtonInvokeApi');
        const btnText = localStorage.getItem('buttonText');
        const plainBtnText = this.stripHtml(btnText);
        if (config.display_step) {
            switch (config.display_step) {
                case 'InvokeAPI':
                case 'InvokeCaptcha':
                    if (flagBtn === '1') {
                        const dialogRef = this.dialog.open(AlertModalComponent, {
                            data: {
                                message: `Do you want to ${plainBtnText}?`,
                                title: " ",
                                class: "custom-confirmation-box"
                            }
                        });
                        dialogRef.afterClosed().subscribe(result => {
                            localStorage.setItem('isButtonInvokeApi', '0');
                            if (result) {
                                this.eventHandler(handler, primaryData);
                            }
                            else {
                                const responseObj = {
                                    handler: handler,
                                    response: {},
                                    chk: false,
                                };
                                this.sharedEventsServices.eventConditionalFailureSubscriber.emit(responseObj);
                            }
                        });
                    }
                    else {
                        this.eventHandler(handler, primaryData);
                    }
                    break;
                case 'LanguageToggle':
                    if (this.payLoad &&
                        this.payLoad.uniqueId &&
                        this.payLoad.value) {
                        this.setLanguage(this.payLoad);
                    }
                    break;
                case 'PrintAndDownload':
                    this.printAndDownload(handler);
                    break;
                case 'SessionClearance':
                    this.switchClearenceType(this.sessionEventHandler(handler, 'EraseSessionData'), handler);
                    break;
                case 'CheckMandatory':
                    this.switchMandatoryCheckType(this.sessionEventHandler(handler, 'CheckMandatoryData'), handler);
                    break;
                case 'CheckValidation':
                    this.switchValidationCheckType(this.sessionEventHandler(handler, 'CheckValidData'), handler);
                    break;
                case 'ClearSessionValues':
                    this.switchClearAkitaStore(this.sessionEventHandler(handler, 'EraseSessionData'), handler, primaryData);
                    break;
                case 'ChangeVisibility':
                case 'ChangeEditable':
                case 'ChangeMandatory':
                    let readDataFromModal = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ReadDataFromModal'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ReadDataFromModal'; })[0].value == 'true' ? true : false : false;
                    this.fieldStateChangeEvent(this.sessionEventHandler(handler, 'FieldStateIds'), config.display_step, readDataFromModal);
                    break;
                case 'CopyToClipboard':
                    this.copyToClipboardEventHandler(handler);
                    break;
                case 'DismissModal':
                    this.dialog.closeAll();
                    this.commonUtil.moveMatDialogToBody();
                    this.sharedEventsServices.modelEmitter.emit({ data: { stepId: "", config: { disableClose: true } }, id: ``, panelClass: `` });
                    break;
                case 'Display Modal':
                    this.displayModal(handler);
                    this.sharedEventsServices.modelEmitter.emit({ data: { stepId: "", config: { disableClose: true } }, id: ``, panelClass: `` });
                    break;
                case 'HighlightMapMarker':
                    this.highlightMapMarker(handler);
                    break;
                case 'SearchFilter':
                    this.searchFilter(handler);
                    break;
                case 'MapCenter':
                    this.mapCenter(handler);
                    break;
                case 'MapLayer':
                    this.MapLayer(handler);
                    break;
                case 'ToggleAccordion':
                    this.toggleAccordion(handler);
                    break;
                case 'CancelTableInlineEdit':
                    setTimeout(() => {
                        this.sharedEventsServices.emitOnTableInlineEditCancelClicked.emit(handler);
                    }, 50);
                    break;
                case 'OpenTableInlineEdit':
                    setTimeout(() => {
                        this.sharedEventsServices.emitOnTableInlineEditClicked.emit(handler);
                    }, 50);
                    break;
                case 'Undo':
                    const fieldIds = this.getAdditionalParameter()['UndoFieldIds'].split('|').map(str => str.trim());
                    if (fieldIds.length > 0) {
                        this.undoRedoUtil.undoCurrentId();
                        setTimeout(() => {
                            this.sharedEventsServices.stateHistoryEmitter.emit(fieldIds);
                        }, 50);
                    }
                    break;
                case 'CustomFunctions':
                    handler.event_handler === "ExecuteOnLoadEvents" ? this.executeStepOnLoadEvents() : this.customFunctions(handler, 'Variables', 'Targets', primaryData);
                    break;
                case 'HistoryBack':
                    this.historyBack();
                    break;
                case 'StateModified':
                    this.stateModified(handler);
                    break;
                case 'SetValues':
                    this.setValuesOnEvent(handler, primaryData);
                    break;
                case 'ScrollToTop':
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    break;
                case 'ListCell':
                    if (primaryData && Object.keys(primaryData).length && primaryData.type) {
                        this.setCellData(primaryData, handler);
                    }
                    break;
                case 'GeoLocation':
                    const globalParameters = this.wfeStepLoaderService.additionalParameters;
                    this.getLocation(globalParameters, handler);
                    break;
                case 'StartTicker':
                    let fieldId = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'TickerID'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'TickerID'; })[0].value : '';
                    this.sharedEventsServices.startTickerEmitter.emit(fieldId);
                    break;
                case 'StopTicker':
                    let tickerId = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'TickerID'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'TickerID'; })[0].value : '';
                    this.sharedEventsServices.stopTickerEmitter.emit(tickerId);
                    break;
                case 'PauseTicker':
                    let timerId = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'TickerID'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'TickerID'; })[0].value : '';
                    this.sharedEventsServices.pauseTickerEmitter.emit(timerId);
                    break;
                case 'OpenSnackBar':
                    let timeOut = Number(handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageDuration'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageDuration'; })[0].value : 3000);
                    let messageHeaderText = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageHeader'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageHeader'; })[0].value : '';
                    let messageTextHandler = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageText'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageText'; })[0].value : '';
                    let actionButtonText = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ActionButtonText'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ActionButtonText'; })[0].value : '';
                    let panelClass = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PanelClass'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PanelClass'; })[0].value.split(' ') : ['ngx-toastr'];
                    let isProgressBarNeeded = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ProgressBar'; }).length > 0 ? (handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ProgressBar'; })[0].value.toLowerCase() == 'true' ? true : false) : false;
                    let messageVerticalPosition = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageVerticalPosition'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageVerticalPosition'; })[0].value : 'top';
                    let messageHorizontalPosition = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageHorizontalPosition'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'MessageHorizontalPosition'; })[0].value : 'center';
                    let messageDynamicHandlers = messageTextHandler.split('||').length > 1 ? messageTextHandler.split('||')[1].split('|') : [];
                    let messageText = messageTextHandler ? messageTextHandler.split('||')[0] : "";
                    let dynamicText = [];
                    messageDynamicHandlers.forEach(messageHandler => {
                        let apiStoreData = this.apiDataService.getApiDataByHandler(messageHandler.split('##')[0]);
                        dynamicText.push(apiStoreData.value[messageHandler]);
                    });
                    let messageArr = messageText.split('{{dynamic}}');
                    let message = messageHeaderText ? "<h2>" + messageHeaderText + "</h2>" : '';
                    messageArr.forEach((msg, index) => {
                        message = message + msg + (dynamicText.length > index ? dynamicText[index] : "");
                    });
                    if (message && message != "") {
                        // this.snackBar.openFromComponent(SnackbarRendererComponent, {
                        //     data: {
                        //         html: message,
                        //         actionButton: actionButtonText,
                        //         progressBar: isProgressBarNeeded
                        //     },
                        //     verticalPosition: messageVerticalPosition,
                        //     horizontalPosition: messageHorizontalPosition,
                        //     panelClass: panelClass,
                        //     duration: Number(timeOut)
                        // });
                        this.wfeStepLoaderService.openToster({
                            html: message,
                            verticalPosition: messageVerticalPosition,
                            horizontalPosition: messageHorizontalPosition,
                            panelClass: panelClass,
                            progressBar: isProgressBarNeeded,
                            closeButton: actionButtonText && actionButtonText != '' ? true : false,
                            duration: Number(timeOut)
                        });
                    }
                    break;
                case 'SaveLocalData':
                    this.saveLocalDataProcess(handler, primaryData);
                    // this.emitUpdatedDataToStore(handler, apiKeyValue);
                    break;
                case 'cancelLocalData':
                    this.cancelLocalDataProcess(handler, primaryData);
                    // this.emitUpdatedDataToStore(handler, apiKeyValue);
                    break;
                case 'updateLocalData':
                    this.updateLocalDataProcess(handler, primaryData);
                    // this.emitUpdatedDataToStore(handler, apiKeyValueUpdate);
                    break;
                case 'DeleteLocalData':
                    var deleteWorningMessage = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'DeleteMessage'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'DeleteMessage'; })[0].value : 'false';
                    if (deleteWorningMessage.toLowerCase() != "false") {
                        this.onDeleteData(deleteWorningMessage, handler, primaryData);
                    }
                    else {
                        this.deleteLocalDataProcess(handler, primaryData);
                    }
                    break;
                case 'OIDCConnect':
                    // if (window.sessionStorage.getItem('CEE_OIDC') === '1') {
                    //     this.sharedEventsServices.oidcEventEmitter.emit(handler);
                    // }
                    // else {
                    //     console.error('OIDC not configured')
                    // }
                    this.sharedEventsServices.oidcEventEmitter.emit(handler);
                    break;
                case 'contextMenu':
                    this.contextMenu(handler, primaryData);
                    break;
                case 'ApplyFilter':
                    // console.log("################### ApplyFilter ###################")
                    let tableId = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'CEE_TABLE_ID'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'CEE_TABLE_ID'; })[0].value : '';
                    // console.log("hello ApplyFilter!: ",tableId);
                    this.sharedEventsServices.emitOnApplyRearrangeBtnClicked.emit(handler);
                    break;
                case 'stepRedirection':
                    if (flagBtn === '1') {
                        const dialogRef = this.dialog.open(AlertModalComponent, {
                            data: {
                                message: `Do you want to ${plainBtnText}?`,
                                title: " ",
                                class: "custom-confirmation-box"
                            }
                        });
                        dialogRef.afterClosed().subscribe(result => {
                            localStorage.setItem('isButtonInvokeApi', '0');
                            if (result) {
                                this.stepRedirection(handler);
                            }
                            else {
                                const responseObj = {
                                    handler: handler,
                                    response: {},
                                    chk: false,
                                };
                                this.sharedEventsServices.eventConditionalFailureSubscriber.emit(responseObj);
                            }
                        });
                    }
                    else {
                        this.stepRedirection(handler);
                    }
                    break;
                case 'CreateZip':
                    this.createZip(handler);
                    break;
                case 'extractEmailIds':
                    this.extractEmailIds(handler);
                    break;
                case 'scrollIntoView':
                    const target = handler.invoke_event_config.additional_parameters.find((el) => { return el.parameter_type == 'Target'; });
                    if (target) {
                        document.getElementById(target.value).scrollIntoView({
                            behavior: "smooth",
                            block: "start", // Align to the start (top) of the viewport
                        });
                    }
                    break;
                case 'SideMenuSelectionReset':
                    this.sharedEventsServices.sideMenuSelectionResetEmitter.emit();
                    break;
                default:
                    let display_step = config.display_step;
                    this.dialog.closeAll();
                    if (config.display_step.indexOf('#') !== -1 && config.display_step.split('#').length === 2) {
                        const splitDS = config.display_step.split('#');
                        display_step = splitDS[0];
                        if (document.getElementById(splitDS[1])) {
                            document.getElementById(splitDS[1]).scrollIntoView({ behavior: 'auto' });
                        }
                        else {
                            localStorage.setItem('scrollTarget', splitDS[1]);
                        }
                    }
                    if (display_step) {
                        var stepRedirectionTarget = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'Target'; })[0]?.value;
                        if (stepRedirectionTarget && !(['self', 'blank', 'top'].includes(stepRedirectionTarget.toLowerCase()))) {
                            this.sharedEventsServices.targetStepRedirection.emit({
                                stepId: this.wfeStepLoaderService.stepNameAndIdDataMap[display_step],
                                target: stepRedirectionTarget
                            });
                        }
                        else {
                            this.wfeStepLoaderService.loadStepByName(display_step).subscribe((data) => {
                                this.processStepRedirection(display_step, data, handler);
                            });
                        }
                    }
                    break;
            }
        }
    }
    getAkitaDataFromHandler(handler) {
        if (this.apiDataService.getApiDataByHandler(handler)) {
            return this.returnNestedData(this.apiDataService.getApiDataByHandler(handler).value);
        }
    }
    returnNestedData(data) {
        if (Object(data) !== data || Array.isArray(data)) {
            return data;
        }
        const regex = /\.?([^.\[\]]+)|\[(\d+)\]/g;
        const resultholder = {};
        // tslint:disable-next-line: forin
        for (const p in data) {
            let cur = resultholder;
            let prop = '';
            let m;
            while ((m = regex.exec(p))) {
                cur = cur[prop] || (cur[prop] = m[2] ? [] : {});
                prop = m[2] || m[1];
            }
            cur[prop] = data[p];
        }
        return resultholder[''] || resultholder;
    }
    stepRedirection(handler) {
        this.additionalParameters = handler.invoke_event_config.additional_parameters;
        const targetStep = handler.invoke_event_config.additional_parameters.find(i => i.parameter_type === 'CEE_dynaimcRoute');
        const target = handler.invoke_event_config.additional_parameters.find(i => i.parameter_type === 'Target');
        if (targetStep) {
            const appStoreData = this.appDataService.getAllAppStoreData();
            const updatedUrl = targetStep.value.replace(/%([^%]+)%/g, (_, key) => {
                for (const data of appStoreData) {
                    if (key == data.id) {
                        return data.value;
                    }
                }
            });
            this.redirectToHref(updatedUrl, null, target);
        }
    }
    openDrawer(data) {
        let isDisableClose = false;
        // data.dismiss_modal = 1 (i.e isDisableClose = true) is to restrict closing the modal when clicking outside the modal or pressing the escape key on the keyboard.
        if (data !== undefined && data.dismiss_modal === 1) {
            isDisableClose = true;
        }
        this.sharedEventsServices.modelEmitter.emit({ data: { stepId: data.tid, config: { disableClose: isDisableClose, dismissModal: data.dismiss_modal } }, id: `stepModal-${data.tid}`, panelClass: `stepModal-${data.tid}` });
    }
    getFileFetchURL() {
        const handler = 'file/fetch';
        const apiConfig = JSON.parse(localStorage.getItem('API_CONFIG'));
        const apiConfigObject = apiConfig[handler];
        if (!apiConfigObject) {
            // console.log(`Error in Mapping ${handler}`);
            return false;
        }
        const { requestBody, headers, queryParams, urlParams, url, methodType, requestType, isESB, hasAuthorisation, storageType, useUID, esbRequestBody } = this.externalRequestResponseUtil.formTheRequestObj(apiConfigObject);
        return url;
    }
    async createZip(handler) {
        const fileFetchURL = this.getFileFetchURL();
        const AssociatedAPIKey = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'AssociatedAPIKey'; }).length > 0 ?
            handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'AssociatedAPIKey'; })[0].value.split('||') : [];
        if (fileFetchURL && AssociatedAPIKey.length) {
            const AttachmentFiles = [];
            for (const apiKey of AssociatedAPIKey) {
                const handlerData = this.apiDataService.getApiDataByHandler(apiKey.split('##')[0]);
                if (handlerData) {
                    const resData = this.setAPIKeyUtil.setApiCallBackData(apiKey, handlerData.value);
                    if (resData && Array.isArray(resData) && resData.length) {
                        for (let i = 0; i < resData.length; i++) {
                            if (resData[i]['attachmentId']) {
                                const fetchUrl = fileFetchURL + resData[i]['attachmentId'];
                                const fetchRes = await this.http.get(fetchUrl).toPromise();
                                if (fetchRes && fetchRes['result']) {
                                    AttachmentFiles.push(fetchRes['result']);
                                }
                            }
                        }
                    }
                }
            }
            this.commonUtil.processZipFile(AttachmentFiles);
        }
    }
    processStepRedirection(display_step, data, handler) {
        if (data !== undefined) {
            this.wfeStepLoaderService.setStepDataInCache(display_step, data);
            // implemented by-default overRideWorkflow for ComplianceForms step redicrection to reduce the memory leak issue
            if (display_step == "ComplianceForms") {
                handler.event_handler = "overRideWorkflow";
            }
            if (data.display_as_modal === 1) {
                // Display the Step As Modal
                //this.openDialog(data);
                this.openDrawer(data);
                if (window['navOpenStaus'] == true) {
                    this.sharedEventsServices.hamburgermenuEmitter.emit(true);
                }
            }
            else if (handler.event_handler !== "") {
                this.redirectWithParams(handler, data.tid);
            }
            else {
                const ModalOnPageLeave = handler['ModalOnPageLeave'] ? handler['ModalOnPageLeave'] : null;
                this.sharedEventsServices.hamburgermenuEmitter.emit(true);
                this.redirectTo(data.tid, ModalOnPageLeave);
            }
        }
    }
    redirectWithParams(handler, stepId) {
        if (handler.event_handler == "overRideWorkflow") {
            this.sharedEventsServices.targetStepRedirection.emit({
                event_handler: handler.event_handler
            });
            this.redirectionUtil.redirectTo(stepId, '_self', '');
        }
        else if (handler.event_handler == "overRideWorkflowWithLocation") {
            this.sharedEventsServices.targetStepRedirection.emit({
                event_handler: handler.event_handler
            });
            this.redirectionUtil.redirectTo(stepId, 'location', '');
        }
        const apiConfig = JSON.parse(localStorage.getItem('API_CONFIG'));
        if (!apiConfig || !apiConfig[handler.event_handler]) {
            return;
        }
        const apiConfigObject = apiConfig[handler.event_handler];
        let { url, queryParams, urlParams } = this.externalRequestResponseUtil.formTheRequestObj(apiConfigObject);
        // set url param
        for (const key of Object.keys(urlParams)) {
            if (url.includes(`{${key}}`)) {
                url = url.split(`{${key}}`).join(encodeURIComponent(urlParams[key]));
            }
        }
        // set query param
        for (const key of Object.keys(queryParams)) {
            if (url.includes(`{${key}}`)) {
                url = url.split(`{${key}}`).join(encodeURIComponent(queryParams[key]));
            }
        }
        let _target = "_blank";
        if (handler && handler.invoke_event_config && handler.invoke_event_config.additional_parameters) {
            for (const ap of handler.invoke_event_config.additional_parameters) {
                if (ap.parameter_type === 'Target') {
                    switch (ap.value.toLowerCase()) {
                        case 'self':
                            _target = '_self';
                            break;
                        case 'blank':
                            _target = '_blank';
                            break;
                        case 'top':
                            _target = '_top';
                            break;
                        default:
                            break;
                    }
                }
            }
        }
        this.redirectionUtil.redirectTo(stepId, _target, url);
    }
    onDeleteData(deleteWorningMessage, handler, primaryData) {
        if (deleteWorningMessage) {
            this.dialog.closeAll();
            const dialogRef = this.dialog.open(AlertModalComponent, {
                data: {
                    message: deleteWorningMessage,
                    title: " "
                }
            });
            dialogRef.afterClosed().subscribe(result => {
                if (result) {
                    this.deleteLocalDataProcess(handler, primaryData);
                }
            });
        }
        else {
            this.deleteLocalDataProcess(handler, primaryData);
        }
    }
    deleteLocalDataProcess(handler, primaryData, responseData = {}) {
        let blockFields = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; })[0].value ? true : false : false;
        let filterKey = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PrimaryKeyName'; })[0].value;
        let table_key = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'table_key'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'table_key'; })[0].value : '';
        let blockFieldName = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; })[0].value : '';
        let apiKeyValueArr = this.getAkitaDataFromHandler(handler.event_handler.split('##')[0])[handler.event_handler];
        let apiData = this.apiDataService.getApiDataByHandler(handler.event_handler.split('##')[0]);
        let apiKeyValue = [];
        let parentPositions;
        let deletePosition;
        let lastNumber = blockFieldName.split("$");
        if (apiData.value.handler_name && blockFields == true && responseData) {
            if (table_key === "borrowers.employment" || table_key === "properties.mortgage") {
                parentPositions = primaryData?.value?.parentPosition;
                deletePosition = primaryData?.value?.position;
            }
            else {
                parentPositions = lastNumber[lastNumber.length - 1];
                deletePosition = primaryData?.value?.data?.application_id;
            }
        }
        if (blockFields == true) {
            let tableKeyFormat = table_key.split(".");
            if (tableKeyFormat.length == 1) {
                apiKeyValue = apiKeyValueArr?.[tableKeyFormat[0]];
            }
            else {
                apiKeyValue = apiKeyValueArr?.[tableKeyFormat[0]]?.[parentPositions]?.[tableKeyFormat[1]];
            }
            if (!deletePosition && table_key !== "borrowers.employment" && table_key !== "properties.mortgage") {
                deletePosition = apiKeyValue[parentPositions]?.application_id;
            }
            let newArray;
            if (table_key === "borrowers.employment" || table_key === "properties.mortgage") {
                newArray = apiKeyValue.filter((_, index) => index !== deletePosition);
            }
            else {
                newArray = apiKeyValue.filter(function (el) {
                    return el[filterKey] != deletePosition;
                });
            }
            if (tableKeyFormat.length == 1) {
                apiKeyValueArr[tableKeyFormat[0]] = newArray;
            }
            else {
                apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]] = newArray;
            }
            if (table_key == "asset" && apiKeyValueArr['asset'].length > 0) {
                apiKeyValueArr['assetTotal']['count'] = apiKeyValueArr['asset'].length;
                apiKeyValueArr['assetTotal']['sum'] = apiKeyValueArr['asset'].map(item => item.cash_or_market_value).reduce((prev, next) => Number(prev) + Number(next));
                apiKeyValueArr['assetStr'] = "Assets Total assets " + apiKeyValueArr['assetTotal']['count'] + " | Total assets amount $" + apiKeyValueArr['assetTotal']['sum'];
            }
            if (apiKeyValueArr['asset'].length == 0) {
                apiKeyValueArr['assetTotal']['count'] = 0;
                apiKeyValueArr['assetTotal']['sum'] = 0;
                apiKeyValueArr['assetStr'] = "Assets Total assets 0 | Total assets amount $0";
            }
            if (table_key == "liabilities" && apiKeyValueArr['liabilities'].length > 0) {
                apiKeyValueArr['liabilityTotal']['count'] = apiKeyValueArr['liabilities'].length;
                apiKeyValueArr['liabilityTotal']['sum'] = apiKeyValueArr['liabilities'].map(item => item.monthly_payment).reduce((prev, next) => Number(prev) + Number(next));
                apiKeyValueArr['liabilitieStr'] = "Liabilities Total liabilities " + apiKeyValueArr['liabilityTotal']['count'] + " | Total liabilities amount $" + apiKeyValueArr['liabilityTotal']['sum'];
            }
            if (apiKeyValueArr['liabilities'].length == 0) {
                apiKeyValueArr['liabilityTotal']['count'] = 0;
                apiKeyValueArr['liabilityTotal']['sum'] = 0;
                apiKeyValueArr['liabilitieStr'] = "Liabilities Total liabilities 0 | Total liabilities amount $0";
            }
            if (table_key == "borrowers.borrowerAddress") {
                let tableKeyFormat = table_key.split(".");
                let addressData = apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]];
                let previousAddresses = [];
                let currentAddress = null;
                addressData.forEach((address, index) => {
                    if (address.move_out_date && address.move_out_date != "Invalid date") {
                        // Addresses with move_out_date are treated as Previous
                        previousAddresses.push(address);
                        apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]][index]['is_current'] = '';
                    }
                    else if (!currentAddress) {
                        // First address without move_out_date is treated as Current
                        currentAddress = address;
                        apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]][index]['is_current'] = 'current';
                    }
                    else {
                        // Any additional addresses without move_out_date are Previous
                        previousAddresses.push(address);
                        apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]][index]['is_current'] = '';
                    }
                });
                apiKeyValueArr[tableKeyFormat[0]][parentPositions]['addressStr'] = `${apiKeyValueArr[tableKeyFormat[0]][parentPositions]['personal_info']['first_name']}'s living address details       ${currentAddress?.address ?? '-'}`;
                if (!apiKeyValueArr[tableKeyFormat[0]][parentPositions].hasOwnProperty('processaddress')) {
                    apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress'] = {};
                }
                if (apiKeyValueArr[tableKeyFormat[0]][parentPositions] && apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress']) {
                    apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress']['currentAddress'] = { ...currentAddress };
                    apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress']['previousAddresses'] = previousAddresses;
                }
            }
            if (table_key == "borrowers.income") {
                let tableKeyFormat = table_key.split(".");
                apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]].forEach((element) => {
                    element['yearlyEarning'] = this.calculateYearlyIncome(element);
                });
                let incomeData = apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]];
                let totalIncome = this.calculateTotalAndCount(incomeData, 'yearlyEarning').totalIncome;
                apiKeyValueArr[tableKeyFormat[0]][parentPositions]['incomeStr'] = `${apiKeyValueArr[tableKeyFormat[0]][parentPositions]['personal_info']['first_name']}'s Additional income details   <span>     Total Income: ${incomeData?.length ?? 0} | Total Amount: $ ${totalIncome ?? 0}/annually </span>`;
            }
            if (table_key == "properties") {
                let tableKeyFormat = table_key.split(".");
                apiKeyValueArr['property_length'] = apiKeyValueArr[tableKeyFormat[0]].length > -1 ? apiKeyValueArr[tableKeyFormat[0]].length : apiKeyValueArr['property_length'];
            }
            this.emitUpdatedDataToStore(handler, apiKeyValueArr);
        }
        else {
            for (const key of Object.keys(apiData.value)) {
                let indexArr = key.match(/^.*?\[[^\d]*(\d+)[^\d]*\].*$/);
                let index = indexArr ? Number(indexArr[1]) : -1;
                let indexKey = key.split('.')[1];
                let obj = {};
                if (index > -1) {
                    if (apiKeyValue[index]) {
                        apiKeyValue[index][indexKey] = apiData.value[key];
                    }
                    else {
                        obj[indexKey] = apiData.value[key];
                        apiKeyValue[index] = obj;
                    }
                }
            }
            apiKeyValue.filter(function (el) {
                return el[filterKey] != primaryData.value.data[filterKey];
            });
            if (table_key == "asset" && apiKeyValueArr['asset'].length > 0) {
                apiKeyValueArr['assetTotal']['count'] = apiKeyValueArr['asset'].length;
                apiKeyValueArr['assetTotal']['sum'] = apiKeyValueArr['asset'].map(item => item.cash_or_market_value).reduce((prev, next) => Number(prev) + Number(next));
                apiKeyValueArr['assetStr'] = "Assets Total assets " + apiKeyValueArr['assetTotal']['count'] + " | Total assets amount $" + apiKeyValueArr['assetTotal']['sum'];
            }
            if (apiKeyValueArr['asset'].length == 0) {
                apiKeyValueArr['assetTotal']['count'] = 0;
                apiKeyValueArr['assetTotal']['sum'] = 0;
                apiKeyValueArr['assetStr'] = "Assets Total assets 0 | Total assets amount $0";
            }
            if (table_key == "liabilities" && apiKeyValueArr['liabilities'].length > 0) {
                apiKeyValueArr['liabilityTotal']['count'] = apiKeyValueArr['liabilities'].length;
                apiKeyValueArr['liabilityTotal']['sum'] = apiKeyValueArr['liabilities'].map(item => item.monthly_payment).reduce((prev, next) => Number(prev) + Number(next));
                apiKeyValueArr['liabilitieStr'] = "Liabilities Total liabilities " + apiKeyValueArr['liabilityTotal']['count'] + " | Total liabilities amount $" + apiKeyValueArr['liabilityTotal']['sum'];
            }
            if (apiKeyValueArr['liabilities'].length == 0) {
                apiKeyValueArr['liabilityTotal']['count'] = 0;
                apiKeyValueArr['liabilityTotal']['sum'] = 0;
                apiKeyValueArr['liabilitieStr'] = "Liabilities Total liabilities 0 | Total liabilities amount $0";
            }
            if (table_key == "borrowers.borrowerAddress") {
                let tableKeyFormat = table_key.split(".");
                let addressData = apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]];
                let previousAddresses = [];
                let currentAddress = null;
                addressData.forEach((address, index) => {
                    if (address.move_out_date && address.move_out_date != "Invalid date") {
                        // Addresses with move_out_date are treated as Previous
                        previousAddresses.push(address);
                        apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]][index]['is_current'] = '';
                    }
                    else if (!currentAddress) {
                        // First address without move_out_date is treated as Current
                        currentAddress = address;
                        apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]][index]['is_current'] = 'current';
                    }
                    else {
                        // Any additional addresses without move_out_date are Previous
                        previousAddresses.push(address);
                        apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]][index]['is_current'] = '';
                    }
                });
                apiKeyValueArr[tableKeyFormat[0]][parentPositions]['addressStr'] = `${apiKeyValueArr[tableKeyFormat[0]][parentPositions]['personal_info']['first_name']}'s living address details       ${currentAddress?.address ?? '-'}`;
                if (!apiKeyValueArr[tableKeyFormat[0]][parentPositions].hasOwnProperty('processaddress')) {
                    apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress'] = {};
                }
                if (apiKeyValueArr[tableKeyFormat[0]][parentPositions] && apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress']) {
                    apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress']['currentAddress'] = { ...currentAddress };
                    apiKeyValueArr[tableKeyFormat[0]][parentPositions]['processaddress']['previousAddresses'] = previousAddresses;
                }
            }
            if (table_key == "borrowers.income") {
                let tableKeyFormat = table_key.split(".");
                apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]].forEach((element) => {
                    element['yearlyEarning'] = this.calculateYearlyIncome(element);
                });
                let incomeData = apiKeyValueArr[tableKeyFormat[0]][parentPositions][tableKeyFormat[1]];
                let totalIncome = this.calculateTotalAndCount(incomeData, 'yearlyEarning').totalIncome;
                apiKeyValueArr[tableKeyFormat[0]][parentPositions]['incomeStr'] = `${apiKeyValueArr[tableKeyFormat[0]][parentPositions]['personal_info']['first_name']}'s Additional income details   <span>     Total Income: ${incomeData?.length ?? 0} | Total Amount: $ ${totalIncome ?? 0}/annually </span>`;
            }
            if (table_key == "properties") {
                let tableKeyFormat = table_key.split(".");
                apiKeyValue['property_length'] = apiKeyValue[tableKeyFormat[0]].length > -1 ? apiKeyValue[tableKeyFormat[0]].length : apiKeyValue['property_length'];
            }
            this.emitUpdatedDataToStore(handler, apiKeyValue);
        }
    }
    cancelLocalDataProcess(handler, primaryData) {
        let apiKeyValueArr = this.getAkitaDataFromHandler(handler.event_handler.split('##')[0])[handler.event_handler];
        if (primaryData.value) {
            apiKeyValueArr.primaryData = {
                position: primaryData.value.position,
                linkedBlockId: primaryData.value.linkedBlockId,
                repeatedBlockFieldId: primaryData.value.repeatedBlockFieldId,
                unique_id: primaryData.value.unique_id,
                isCancelEvent: "true",
            };
        }
        this.emitUpdatedDataToStore(handler, apiKeyValueArr);
    }
    saveLocalDataProcess(handler, primaryData, responseData = {}) {
        let primaryKeyName = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PrimaryKeyName'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PrimaryKeyName'; })[0].value : '';
        let ReadDataFromModal = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ReadDataFromModal'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ReadDataFromModal'; })[0].value == 'true' ? true : false : false;
        let blockFields = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; })[0].value ? true : false : false;
        let blockFieldName = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; })[0].value : '';
        let table_key = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'table_key'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'table_key'; })[0].value : '';
        let splitKeys = primaryKeyName.split('||');
        let tempKeyCreate;
        if (splitKeys.length > 0) {
            primaryKeyName = splitKeys[0];
            tempKeyCreate = '_' + splitKeys[1];
        }
        this.uniqueFields = [];
        let uniqueFieldsAdditionalParam = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'UniqueFields'; });
        if (uniqueFieldsAdditionalParam.length > 0) {
            uniqueFieldsAdditionalParam[0].value.split('||').forEach(element => {
                let elementArr = element.split('|');
                let tempObj = {
                    req_key: elementArr.length > 0 ? elementArr[0] : '',
                    message: elementArr.length > 1 ? elementArr[1] : 'Please provide unique value!'
                };
                this.uniqueFields.push(tempObj);
            });
        }
        let sectionFields = {};
        let sectionFieldsFiltered = {};
        if (blockFields != true) {
            if (ReadDataFromModal) {
                sectionFields = this.wfeStepLoaderService && this.wfeStepLoaderService.rootData && this.wfeStepLoaderService.rootData['sectionFields'] ? this.wfeStepLoaderService.rootData['sectionFields'] : {};
            }
            else {
                sectionFields = this.wfeStepLoaderService && this.wfeStepLoaderService.lastStepRootData && this.wfeStepLoaderService.lastStepRootData['sectionFields'] ? this.wfeStepLoaderService.lastStepRootData['sectionFields'] : {};
            }
            // Filtering only current step data
            let stepId = ReadDataFromModal ? window['currentModalId'] : window['currentStepId'];
            const sectionFieldsArray = Object.entries(sectionFields);
            const filteredSectionFields = sectionFieldsArray.filter(([key, value]) => key.includes(stepId));
            // let sectionFieldsFiltered = {};
            filteredSectionFields.forEach(e => {
                sectionFieldsFiltered[e[0]] = e[1];
            });
        }
        else {
            sectionFields = this.wfeStepLoaderService && this.wfeStepLoaderService.lastStepRootData && this.wfeStepLoaderService.lastStepRootData['blockFields'] ? this.wfeStepLoaderService.lastStepRootData['blockFields'] : {};
            sectionFieldsFiltered[blockFieldName] = sectionFields[blockFieldName];
        }
        const newObj = {};
        if (sectionFieldsFiltered) {
            for (const key of Object.keys(sectionFieldsFiltered)) {
                sectionFieldsFiltered[key]?.forEach(fieldId => {
                    this.appDataService.getIndividualAppData(fieldId).pipe(take(1)).subscribe(fieldData => {
                        if (fieldData.length > 0 && fieldData[0]['requestApiKey']) {
                            let reqKey = fieldData[0]['requestApiKey'][0];
                            let fieldValue = fieldData[0]['value'];
                            if (reqKey != "" && reqKey != undefined) {
                                newObj[reqKey] = fieldValue;
                            }
                            if (fieldData[0]['isRepeatedField']) {
                                const blockId = fieldData[0]["linkedBlockId"];
                                let blockData;
                                if (tempKeyCreate) {
                                    blockData = this.getRepetableBlockDataFromBlockIdwithResponseKey(blockId, reqKey);
                                }
                                else {
                                    blockData = this.getRepetableBlockDataFromBlockId(blockId);
                                }
                                if (reqKey != "" && reqKey != undefined) {
                                    newObj[reqKey] = blockData;
                                }
                            }
                            else if (fieldData[0]['apiKey'] == 'Generic Block') {
                                // console.log("field:----> ",fieldData)
                                const blockId = fieldData[0]["linkedBlockId"];
                                // if (blockId) {
                                let blockObject = {};
                                this.wfeStepLoaderService.loadBlockByName(blockId).toPromise().then((data) => {
                                    if (blockFields != true) {
                                        data['block_fields'].forEach(element => {
                                            if (element['field_type'] != "Button" && element['field_type'] != "label") {
                                                let blockFieldRequestKey = element['requestApiKey'] ? element['requestApiKey'] : element['unique_id'];
                                                // let blockFieldRequestKey = element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] ? element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] : element['unique_id'];
                                                let blockFieldValue = this.appDataService.getFieldDataByFieldId(element.unique_id);
                                                blockObject[blockFieldRequestKey] = blockFieldValue;
                                                // console.log("unique_id: ", element.unique_id, " field data: ", this.appDataService.getFieldDataByFieldId(element.unique_id));
                                            }
                                        });
                                    }
                                    else {
                                        data['block_fields'].forEach(element => {
                                            if (element['field_type'] != "Button" && element['field_type'] != "label" && element['field_type'] != "Table") {
                                                let blockFieldRequestKey = element['requestApiKey'] ? element['requestApiKey'] : element['unique_id'];
                                                // let blockFieldRequestKey = element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] ? element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] : element['unique_id'];
                                                let blockFieldValue = this.appDataService.getFieldDataByFieldId(element.unique_id);
                                                blockObject[blockFieldRequestKey] = blockFieldValue;
                                                // console.log("unique_id: ", element.unique_id, " field data: ", this.appDataService.getFieldDataByFieldId(element.unique_id));
                                            }
                                        });
                                    }
                                    // console.log("blockData:-----> ",blockObject);
                                    if (reqKey != "" && reqKey != undefined) {
                                        newObj[reqKey] = blockObject;
                                    }
                                });
                                // }
                            }
                        }
                    });
                });
            }
        }
        let isDuplicateItemFound = -1;
        let isNonUniqueItemFound = -1;
        let nonUniqueItemWarningMsg = "Value provided is not unique!";
        let apiDatas = this.apiDataService.getApiDataByHandler(handler.event_handler.split('##')[0]);
        let parentPosition;
        let position;
        if (apiDatas.value.handler_name && blockFields == true && responseData) {
            parentPosition = primaryData?.value?.parentPosition;
            position = primaryData?.value?.position;
            newObj[primaryKeyName] = responseData['data']?.application_id || responseData['data']?.mainAddressResponse?.application_id;
            if (responseData && responseData['data'] && responseData['data']['addressSituationsResponse'] && responseData['data']['addressSituationsResponse']['application_id']) {
                newObj['address_situations_application_id'] = responseData['data']['addressSituationsResponse']['application_id'];
                newObj['address'] = (newObj?.unit ? (newObj?.unit + '-') : '') + `${newObj?.street_long} ${newObj?.street_type} ${newObj?.street_direction} ${newObj?.country}` + (newObj?.province ? (', ' + newObj?.province) : '') + (newObj?.postal_code ? (', ' + newObj?.postal_code) : '');
            }
        }
        else {
            if (!newObj[primaryKeyName]) {
                newObj[primaryKeyName] = new Date().getTime();
            }
        }
        let apiKeyValueArr = blockFields == true ? this.getAkitaDataFromHandler(handler.event_handler.split('##')[0])[handler.event_handler] : this.getApiKeyValuePair(apiDatas);
        ;
        // console.log("apiKeyValueArr: ", apiKeyValueArr)
        if (table_key == "asset" || table_key == "liabilities") {
            let borrowerList = apiKeyValueArr['borrowerList'];
            let borrowerNamesList = [];
            borrowerNamesList = borrowerList.filter(obj => newObj["borrower_ids"].indexOf(obj.id) > -1);
            let borrowerNames = borrowerNamesList.map(obj => obj.name).join(', ');
            // console.log("borrowerNames: ", borrowerNames)
            newObj['assoicated_borrower_id'] = newObj['borrower_ids'];
            newObj['borrower_ids'] = borrowerNames;
        }
        if (Array.isArray(newObj[primaryKeyName]) && tempKeyCreate) {
            const dummyArray = newObj[primaryKeyName];
            let apiKeyValueSet = [];
            let includedIds = [];
            this.modelValue = -1;
            for (let i = 0; i <= dummyArray.length - 1; i++) {
                if (dummyArray[i]?.[primaryKeyName] && dummyArray[i][primaryKeyName] != '') {
                    let copiedObject = JSON.parse(JSON.stringify(newObj));
                    copiedObject[primaryKeyName] = (new Date().getTime() + i).toString();
                    copiedObject[primaryKeyName + tempKeyCreate] = dummyArray[i][primaryKeyName];
                    apiKeyValueSet.push(copiedObject);
                }
            }
            apiKeyValueSet.forEach((value) => {
                this.uniqueFields.forEach((val) => {
                    if (!includedIds.includes(value[val.req_key])) {
                        includedIds.push(value[val.req_key]);
                    }
                    else {
                        this.modelValue = 1;
                    }
                });
            });
            if (this.modelValue != 1) {
                apiKeyValueArr.forEach((value) => {
                    this.uniqueFields.forEach((val) => {
                        if (includedIds.includes(value[val.req_key])) {
                            this.modelValue = 1;
                        }
                    });
                });
            }
            if (this.modelValue === 1) {
                return apiKeyValueArr;
            }
            else {
                apiKeyValueArr.push(...apiKeyValueSet);
            }
        }
        else {
            let dummyArray = apiKeyValueArr;
            this.modelValue = -1;
            if (blockFields !== true) {
                apiKeyValueArr?.forEach((value, index) => {
                    if (value[primaryKeyName] == newObj[primaryKeyName]) {
                        isDuplicateItemFound = index;
                    }
                    this.uniqueFields.forEach((val) => {
                        if (value[val.req_key] == newObj[val.req_key]) {
                            if (tempKeyCreate && value[primaryKeyName] != newObj[primaryKeyName]) {
                                this.modelValue = 1;
                            }
                            else {
                                isNonUniqueItemFound = index;
                                nonUniqueItemWarningMsg = val.message;
                            }
                        }
                    });
                });
            }
            if (isDuplicateItemFound > -1 && this.modelValue != 1) {
                apiKeyValueArr[isDuplicateItemFound] = newObj;
            }
            else if (isNonUniqueItemFound > -1) {
                this.snackBar.open(nonUniqueItemWarningMsg, 'OK', {
                    verticalPosition: 'top',
                    panelClass: ['mat-toolbar', 'mat-primary']
                });
            }
            else if (this.modelValue == 1) {
                apiKeyValueArr = dummyArray;
            }
            else {
                if (blockFields !== true) {
                    apiKeyValueArr.push(newObj);
                }
                else {
                    let tableKeyFormat = table_key.split(".");
                    let parentArray = [];
                    if (tableKeyFormat.length == 1) {
                        parentArray = apiKeyValueArr[tableKeyFormat[0]];
                    }
                    else {
                        if (table_key === "borrowers.employment") {
                            parentArray = apiKeyValueArr[tableKeyFormat[0]][parentPosition][tableKeyFormat[1]];
                        }
                        else {
                            parentArray = apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]];
                        }
                    }
                    if (parentArray && Array.isArray(parentArray)) {
                        if (!Object.isExtensible(parentArray)) {
                            parentArray = [...parentArray, newObj];
                        }
                        else {
                            parentArray.push(newObj);
                        }
                    }
                    if (tableKeyFormat.length == 1) {
                        apiKeyValueArr[tableKeyFormat[0]] = parentArray;
                    }
                    else {
                        if (table_key === "borrowers.borrowerAddress" || table_key === "borrowers.income") {
                            apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]] = parentArray;
                        }
                        else {
                            apiKeyValueArr[tableKeyFormat[0]][parentPosition][tableKeyFormat[1]] = parentArray;
                        }
                    }
                }
            }
        }
        if (table_key == "asset") {
            apiKeyValueArr['assetTotal']['count'] = apiKeyValueArr['asset'].length;
            apiKeyValueArr['assetTotal']['sum'] = apiKeyValueArr['asset'].map(item => item.cash_or_market_value).reduce((prev, next) => Number(prev) + Number(next));
            apiKeyValueArr['assetStr'] = "Assets Total assets " + apiKeyValueArr['assetTotal']['count'] + " | Total assets amount $" + apiKeyValueArr['assetTotal']['sum'];
        }
        if (table_key == "liabilities") {
            apiKeyValueArr['liabilityTotal']['count'] = apiKeyValueArr['liabilities'].length;
            apiKeyValueArr['liabilityTotal']['sum'] = apiKeyValueArr['liabilities'].map(item => item.monthly_payment).reduce((prev, next) => Number(prev) + Number(next));
            apiKeyValueArr['liabilitieStr'] = "Liabilities Total liabilities " + apiKeyValueArr['liabilityTotal']['count'] + " | Total liabilities amount $" + apiKeyValueArr['liabilityTotal']['sum'];
        }
        if (table_key == "borrowers.borrowerAddress") {
            let tableKeyFormat = table_key.split(".");
            let addressData = apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]];
            let previousAddresses = [];
            let currentAddress = null;
            addressData.forEach((address, index) => {
                if (address.move_out_date && address.move_out_date != "Invalid date") {
                    // Addresses with move_out_date are treated as Previous
                    previousAddresses.push(address);
                    apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]][index]['is_current'] = '';
                }
                else if (!currentAddress) {
                    // First address without move_out_date is treated as Current
                    currentAddress = address;
                    apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]][index]['is_current'] = 'current';
                }
                else {
                    // Any additional addresses without move_out_date are Previous
                    previousAddresses.push(address);
                    apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]][index]['is_current'] = '';
                }
            });
            apiKeyValueArr[tableKeyFormat[0]][position]['addressStr'] = `${apiKeyValueArr[tableKeyFormat[0]][position]['personal_info']['first_name']}'s living address details       ${currentAddress?.address ?? '-'}`;
            if (!apiKeyValueArr[tableKeyFormat[0]][position].hasOwnProperty('processaddress')) {
                apiKeyValueArr[tableKeyFormat[0]][position]['processaddress'] = {};
            }
            if (apiKeyValueArr[tableKeyFormat[0]][position] && apiKeyValueArr[tableKeyFormat[0]][position]['processaddress']) {
                apiKeyValueArr[tableKeyFormat[0]][position]['processaddress']['currentAddress'] = { ...currentAddress };
                apiKeyValueArr[tableKeyFormat[0]][position]['processaddress']['previousAddresses'] = previousAddresses;
            }
        }
        if (table_key == "borrowers.income") {
            let tableKeyFormat = table_key.split(".");
            apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]].forEach((element) => {
                element['yearlyEarning'] = this.calculateYearlyIncome(element);
            });
            let incomeData = apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]];
            let totalIncome = this.calculateTotalAndCount(incomeData, 'yearlyEarning').totalIncome;
            apiKeyValueArr[tableKeyFormat[0]][position]['incomeStr'] = `${apiKeyValueArr[tableKeyFormat[0]][position]['personal_info']['first_name']}'s Additional income details   <span>     Total Income: ${incomeData?.length ?? 0} | Total Amount: $ ${totalIncome ?? 0}/annually </span>`;
        }
        if (table_key == "mortgage") {
            let tableKeyFormat = table_key.split(".");
            apiKeyValueArr[tableKeyFormat[0]]['loan_amount'] = newObj['purchase_price'];
            apiKeyValueArr[tableKeyFormat[0]]['total_loan_amount'] = newObj['purchase_price'];
            apiKeyValueArr[tableKeyFormat[0]]['purchase_price'] = newObj['purchase_price'];
            apiKeyValueArr[tableKeyFormat[0]]['property_value'] = newObj['purchase_price'];
            apiKeyValueArr[tableKeyFormat[0]]['lender'] = newObj['lender'];
            apiKeyValueArr[tableKeyFormat[0]]['qualifyingMonthlyPayment'] = responseData['data']['qualifyingMonthlyPayment'];
            apiKeyValueArr[tableKeyFormat[0]]['freequencyPayment'] = responseData['data']['freequencyPayment'];
        }
        if (table_key == "properties") {
            let tableKeyFormat = table_key.split(".");
            apiKeyValueArr['property_length'] = apiKeyValueArr[tableKeyFormat[0]].length > -1 ? apiKeyValueArr[tableKeyFormat[0]].length : apiKeyValueArr['property_length'];
        }
        if (table_key == "subjectProperty") {
            let tableKeyFormatsub = table_key.split(".");
            if (apiKeyValueArr[tableKeyFormatsub[0]].length == 0) {
                apiKeyValueArr[tableKeyFormatsub[0]][0] = {};
            }
            apiKeyValueArr[tableKeyFormatsub[0]][0]['total_expenses'] = Number(Number(newObj['monthly_heating_fees']) + Number(newObj['monthly_hydro_costs']) + Number(newObj['monthly_insurance_costs']) + Number(newObj['monthly_management_costs']) + Number(newObj['monthly_repairs_costs']) + Number(newObj['monthly_interest_costs']) + Number(newObj['monthly_other_costs']) + Number(newObj['monthly_rental_income']) + Number(newObj['monthly_condo_fees'])) || 0;
            apiKeyValueArr[tableKeyFormatsub[0]][0]['address'] = newObj['contact/update/getAddressFromLookup##input'];
            table_key = "mortgage";
            let tableKeyFormat = table_key.split(".");
            apiKeyValueArr[tableKeyFormat[0]]['loan_amount'] = newObj['purchase_price'];
            apiKeyValueArr[tableKeyFormat[0]]['total_loan_amount'] = newObj['purchase_price'];
            apiKeyValueArr[tableKeyFormat[0]]['purchase_price'] = newObj['purchase_price'];
            apiKeyValueArr[tableKeyFormat[0]]['property_value'] = newObj['purchase_price'];
            apiKeyValueArr.loan_amount = newObj['purchase_price'];
            table_key = "subjectProperty";
        }
        if (table_key == "mortgage") {
            table_key = "subjectProperty";
            let tableKeyFormat = table_key.split(".");
            if (apiKeyValueArr[tableKeyFormat[0]].length == 0) {
                apiKeyValueArr[tableKeyFormat[0]][0] = {};
            }
            apiKeyValueArr[tableKeyFormat[0]][0]['purchase_price'] = newObj['loan_amount'];
            apiKeyValueArr.loan_amount = newObj['loan_amount'];
            table_key = "mortgage";
        }
        this.emitUpdatedDataToStore(handler, apiKeyValueArr);
    }
    calculateYearlyIncome(data) {
        const frequencyMultiplier = {
            Annual: 1,
            Monthly: 12,
            'Bi-weekly': 26,
            'Semi-monthly': 24,
            'Semi- monthly': 24,
            Weekly: 52,
        };
        const { income, payment_frequency } = data;
        const multiplier = frequencyMultiplier[payment_frequency];
        // if (!multiplier) {
        //   throw new Error(`Invalid payment frequency: ${payment_frequency}`);
        // }
        return income * multiplier;
    }
    calculateTotalAndCount(data, key) {
        const totalIncome = data.reduce((total, item) => Number(total) + (Number(item[key]) || 0), 0);
        const recordCount = data.length;
        return { totalIncome, recordCount };
    }
    updateLocalDataProcess(handler, primaryData, responseData = {}) {
        let primaryKeyName = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PrimaryKeyName'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PrimaryKeyName'; })[0].value : '';
        let ReadDataFromModal = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ReadDataFromModal'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'ReadDataFromModal'; })[0].value == 'true' ? true : false : false;
        let blockFields = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; })[0].value ? true : false : false;
        let blockFieldName = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'blockFields'; })[0].value : '';
        let filterKey = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'PrimaryKeyName'; })[0]?.value;
        let table_key = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'table_key'; }).length > 0 ? handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'table_key'; })[0].value : '';
        let splitKeys = primaryKeyName.split('||');
        let tempKeyCreate;
        if (splitKeys.length > 0) {
            primaryKeyName = splitKeys[0];
            tempKeyCreate = '_' + splitKeys[1];
        }
        this.uniqueFields = [];
        let uniqueFieldsAdditionalParam = handler.invoke_event_config.additional_parameters.filter(function (el) { return el.parameter_type == 'UniqueFields'; });
        if (uniqueFieldsAdditionalParam.length > 0) {
            uniqueFieldsAdditionalParam[0].value.split('||').forEach(element => {
                let elementArr = element.split('|');
                let tempObj = {
                    req_key: elementArr.length > 0 ? elementArr[0] : '',
                    message: elementArr.length > 1 ? elementArr[1] : 'Please provide unique value!'
                };
                this.uniqueFields.push(tempObj);
            });
        }
        let sectionFields = {};
        let sectionFieldsFiltered = {};
        if (blockFields != true) {
            if (ReadDataFromModal) {
                sectionFields = this.wfeStepLoaderService && this.wfeStepLoaderService.rootData && this.wfeStepLoaderService.rootData['sectionFields'] ? this.wfeStepLoaderService.rootData['sectionFields'] : {};
            }
            else {
                sectionFields = this.wfeStepLoaderService && this.wfeStepLoaderService.lastStepRootData && this.wfeStepLoaderService.lastStepRootData['sectionFields'] ? this.wfeStepLoaderService.lastStepRootData['sectionFields'] : {};
            }
            // Filtering only current step data
            let stepId = ReadDataFromModal ? window['currentModalId'] : window['currentStepId'];
            const sectionFieldsArray = Object.entries(sectionFields);
            const filteredSectionFields = sectionFieldsArray.filter(([key, value]) => key.includes(stepId));
            let sectionFieldsFiltered = {};
            filteredSectionFields.forEach(e => {
                sectionFieldsFiltered[e[0]] = e[1];
            });
        }
        else {
            sectionFields = this.wfeStepLoaderService && this.wfeStepLoaderService.lastStepRootData && this.wfeStepLoaderService.lastStepRootData['blockFields'] ? this.wfeStepLoaderService.lastStepRootData['blockFields'] : {};
            sectionFieldsFiltered[blockFieldName] = sectionFields[blockFieldName];
        }
        const newObj = {};
        if (sectionFieldsFiltered) {
            for (const key of Object.keys(sectionFieldsFiltered)) {
                sectionFieldsFiltered[key].forEach(fieldId => {
                    this.appDataService.getIndividualAppData(fieldId).pipe(take(1)).subscribe(fieldData => {
                        if (fieldData.length > 0 && fieldData[0]['requestApiKey']) {
                            let reqKey = fieldData[0]['requestApiKey'][0];
                            let fieldValue = fieldData[0]['value'];
                            if (reqKey != "" && reqKey != undefined) {
                                newObj[reqKey] = fieldValue;
                            }
                            if (fieldData[0]['isRepeatedField']) {
                                const blockId = fieldData[0]["linkedBlockId"];
                                let blockData;
                                if (tempKeyCreate) {
                                    blockData = this.getRepetableBlockDataFromBlockIdwithResponseKey(blockId, reqKey);
                                }
                                else {
                                    blockData = this.getRepetableBlockDataFromBlockId(blockId);
                                }
                                if (reqKey != "" && reqKey != undefined) {
                                    newObj[reqKey] = blockData;
                                }
                            }
                            else if (fieldData[0]['apiKey'] == 'Generic Block') {
                                // console.log("field:----> ",fieldData)
                                const blockId = fieldData[0]["linkedBlockId"];
                                // if (blockId) {
                                let blockObject = {};
                                this.wfeStepLoaderService.loadBlockByName(blockId).toPromise().then((data) => {
                                    if (blockFields != true) {
                                        data['block_fields'].forEach(element => {
                                            if (element['field_type'] != "Button" && element['field_type'] != "label") {
                                                let blockFieldRequestKey = element['requestApiKey'] ? element['requestApiKey'] : element['unique_id'];
                                                // let blockFieldRequestKey = element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] ? element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] : element['unique_id'];
                                                let blockFieldValue = this.appDataService.getFieldDataByFieldId(element.unique_id);
                                                blockObject[blockFieldRequestKey] = blockFieldValue;
                                                // console.log("unique_id: ", element.unique_id, " field data: ", this.appDataService.getFieldDataByFieldId(element.unique_id));
                                            }
                                        });
                                    }
                                    else {
                                        data['block_fields'].forEach(element => {
                                            if (element['field_type'] != "Button" && element['field_type'] != "label" && element['field_type'] != "Table") {
                                                let blockFieldRequestKey = element['requestApiKey'] ? element['requestApiKey'] : element['unique_id'];
                                                // let blockFieldRequestKey = element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] ? element['requestApiKey'].split('##')[element['requestApiKey'].split('##').length - 1] : element['unique_id'];
                                                let blockFieldValue = this.appDataService.getFieldDataByFieldId(element.unique_id);
                                                blockObject[blockFieldRequestKey] = blockFieldValue;
                                                // console.log("unique_id: ", element.unique_id, " field data: ", this.appDataService.getFieldDataByFieldId(element.unique_id));
                                            }
                                        });
                                    }
                                    // console.log("blockData:-----> ",blockObject);
                                    if (reqKey != "" && reqKey != undefined) {
                                        newObj[reqKey] = blockObject;
                                    }
                                });
                                // }
                            }
                        }
                    });
                });
            }
        }
        let apiData = this.apiDataService.getApiDataByHandler(handler.event_handler.split('##')[0]);
        let apiKeyValueArr = this.getAkitaDataFromHandler(handler.event_handler.split('##')[0])[handler.event_handler];
        if (table_key == "asset" || table_key == "liabilities") {
            let borrowerList = apiKeyValueArr['borrowerList'];
            let borrowerNamesList = [];
            borrowerNamesList = borrowerList.filter(obj => newObj["borrower_ids"].indexOf(obj.id) > -1);
            let borrowerNames = borrowerNamesList.map(obj => obj.name).join(', ');
            // console.log("borrowerNames: ", borrowerNames)
            newObj['assoicated_borrower_id'] = newObj['borrower_ids'];
            newObj['borrower_ids'] = borrowerNames;
        }
        if (table_key == "deal_info") {
            newObj['application_id'] = newObj['deal_application_id'];
            table_key = "";
        }
        let apiKeyValue = [];
        let editPosition;
        let applicationId;
        let parentPosition;
        let position;
        if (apiData.value.handler_name && blockFields == true && responseData) {
            parentPosition = primaryData?.value?.parentPosition;
            position = primaryData?.value?.position;
            editPosition = newObj[primaryKeyName];
            if (blockFields == true) {
                let tableKeyFormat = table_key.split(".");
                if (table_key == "") {
                    apiKeyValue = apiKeyValueArr;
                }
                else if (tableKeyFormat.length == 1) {
                    apiKeyValue = apiKeyValueArr?.[tableKeyFormat[0]];
                }
                else {
                    if (table_key === "borrowers.employment") {
                        filterKey = "application_id";
                        apiKeyValue = apiKeyValueArr?.[tableKeyFormat[0]]?.[parentPosition]?.[tableKeyFormat[1]];
                    }
                    else {
                        apiKeyValue = apiKeyValueArr?.[tableKeyFormat[0]]?.[position]?.[tableKeyFormat[1]];
                    }
                }
                if (table_key == "mortgage") {
                    applicationId = apiKeyValue['application_id'];
                }
                if (newObj && newObj['address_situations_application_id']) {
                    newObj['address'] = (newObj?.unit ? (newObj?.unit + '-') : '') + `${newObj?.street_long} ${newObj?.street_type} ${newObj?.street_direction} ${newObj?.country}` + (newObj?.province ? (', ' + newObj?.province) : '') + (newObj?.postal_code ? (', ' + newObj?.postal_code) : '');
                }
                let updatedArray = apiKeyValue;
                if (table_key == "" && newObj['transaction_type']) {
                    newObj['previous_transaction_type'] = updatedArray['transaction_type'];
                }
                if (Array.isArray(apiKeyValue)) {
                    updatedArray = apiKeyValue.map(obj => obj[filterKey] === editPosition ? { ...obj, ...newObj } : obj);
                }
                else {
                    updatedArray = { ...updatedArray, ...newObj };
                }
                if (table_key == "") {
                    apiKeyValueArr = updatedArray;
                }
                else if (tableKeyFormat.length == 1) {
                    apiKeyValueArr[tableKeyFormat[0]] = updatedArray;
                }
                else {
                    if (table_key === "borrowers.employment") {
                        apiKeyValueArr[tableKeyFormat[0]][parentPosition][tableKeyFormat[1]] = updatedArray;
                    }
                    else {
                        apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]] = updatedArray;
                    }
                }
                if (table_key == "asset") {
                    apiKeyValueArr['assetTotal']['count'] = apiKeyValueArr['asset'].length;
                    apiKeyValueArr['assetTotal']['sum'] = apiKeyValueArr['asset'].map(item => item.cash_or_market_value).reduce((prev, next) => Number(prev) + Number(next));
                    apiKeyValueArr['assetStr'] = "Assets Total assets " + apiKeyValueArr['assetTotal']['count'] + " | Total assets amount $" + apiKeyValueArr['assetTotal']['sum'];
                }
                if (table_key == "liabilities") {
                    apiKeyValueArr['liabilityTotal']['count'] = apiKeyValueArr['liabilities'].length;
                    apiKeyValueArr['liabilityTotal']['sum'] = apiKeyValueArr['liabilities'].map(item => item.monthly_payment).reduce((prev, next) => Number(prev) + Number(next));
                    apiKeyValueArr['liabilitieStr'] = "Liabilities Total liabilities " + apiKeyValueArr['liabilityTotal']['count'] + " | Total liabilities amount $" + apiKeyValueArr['liabilityTotal']['sum'];
                }
                if (table_key == "borrowers.borrowerAddress") {
                    let tableKeyFormat = table_key.split(".");
                    let addressData = apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]];
                    let previousAddresses = [];
                    let currentAddress = null;
                    addressData.forEach((address, index) => {
                        if (address.move_out_date && address.move_out_date != "Invalid date") {
                            // Addresses with move_out_date are treated as Previous
                            previousAddresses.push(address);
                            apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]][index]['is_current'] = '';
                        }
                        else if (!currentAddress) {
                            // First address without move_out_date is treated as Current
                            currentAddress = address;
                            apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]][index]['is_current'] = 'current';
                        }
                        else {
                            // Any additional addresses without move_out_date are Previous
                            previousAddresses.push(address);
                            apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]][index]['is_current'] = '';
                        }
                    });
                    apiKeyValueArr[tableKeyFormat[0]][position]['addressStr'] = `${apiKeyValueArr[tableKeyFormat[0]][position]['personal_info']['first_name']}'s living address details       ${currentAddress?.address ?? '-'}`;
                    if (!apiKeyValueArr[tableKeyFormat[0]][position].hasOwnProperty('processaddress')) {
                        apiKeyValueArr[tableKeyFormat[0]][position]['processaddress'] = {};
                    }
                    if (apiKeyValueArr[tableKeyFormat[0]][position] && apiKeyValueArr[tableKeyFormat[0]][position]['processaddress']) {
                        apiKeyValueArr[tableKeyFormat[0]][position]['processaddress']['currentAddress'] = { ...currentAddress };
                        apiKeyValueArr[tableKeyFormat[0]][position]['processaddress']['previousAddresses'] = previousAddresses;
                    }
                }
                if (table_key == "borrowers.income") {
                    let tableKeyFormat = table_key.split(".");
                    apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]].forEach((element) => {
                        element['yearlyEarning'] = this.calculateYearlyIncome(element);
                    });
                    let incomeData = apiKeyValueArr[tableKeyFormat[0]][position][tableKeyFormat[1]];
                    let totalIncome = this.calculateTotalAndCount(incomeData, 'yearlyEarning').totalIncome;
                    apiKeyValueArr[tableKeyFormat[0]][position]['incomeStr'] = `${apiKeyValueArr[tableKeyFormat[0]][position]['personal_info']['first_name']}'s Additional income details   <span>     Total Income: ${incomeData?.length ?? 0} | Total Amount: $ ${totalIncome ?? 0}/annually </span>`;
                }
                if (table_key == "properties") {
                    let tableKeyFormat = table_key.split(".");
                    apiKeyValueArr['property_length'] = apiKeyValueArr[tableKeyFormat[0]].length > -1 ? apiKeyValueArr[tableKeyFormat[0]].length : apiKeyValueArr['property_length'];
                }
                if (table_key == "mortgage") {
                    let tableKeyFormat = table_key.split(".");
                    apiKeyValueArr[tableKeyFormat[0]]['application_id'] = applicationId;
                    apiKeyValueArr[tableKeyFormat[0]]['loan_amount'] = newObj['loan_amount'];
                    apiKeyValueArr[tableKeyFormat[0]]['total_loan_amount'] = newObj['loan_amount'];
                    apiKeyValueArr[tableKeyFormat[0]]['purchase_price'] = newObj['property_value'];
                    apiKeyValueArr[tableKeyFormat[0]]['property_value'] = newObj['property_value'];
                    apiKeyValueArr[tableKeyFormat[0]]['lender'] = newObj['lender'];
                    apiKeyValueArr[tableKeyFormat[0]]['qualifyingMonthlyPayment'] = responseData['data']['qualifyingMonthlyPayment'];
                    apiKeyValueArr[tableKeyFormat[0]]['freequencyPayment'] = responseData['data']['freequencyPayment'];
                }
                if (table_key == "subjectProperty") {
                    let tableKeyFormatsub = table_key.split(".");
                    if (apiKeyValueArr[tableKeyFormatsub[0]].length == 0) {
                        apiKeyValueArr[tableKeyFormatsub[0]][0] = {};
                    }
                    apiKeyValueArr[tableKeyFormatsub[0]][0]['total_expenses'] = Number(Number(newObj['monthly_heating_fees']) + Number(newObj['monthly_hydro_costs']) + Number(newObj['monthly_insurance_costs']) + Number(newObj['monthly_management_costs']) + Number(newObj['monthly_repairs_costs']) + Number(newObj['monthly_interest_costs']) + Number(newObj['monthly_other_costs']) + Number(newObj['monthly_rental_income']) + Number(newObj['monthly_condo_fees'])) || 0;
                    apiKeyValueArr[tableKeyFormatsub[0]][0]['address'] = newObj['contact/update/getAddressFromLookup##input'];
                    table_key = "mortgage";
                    let tableKeyFormat = table_key.split(".");
                    apiKeyValueArr[tableKeyFormat[0]]['application_id'] = applicationId;
                    apiKeyValueArr[tableKeyFormat[0]]['loan_amount'] = newObj['purchase_price'] - apiKeyValueArr[tableKeyFormat[0]]['down_payment'];
                    apiKeyValueArr[tableKeyFormat[0]]['total_loan_amount'] = newObj['purchase_price'] - apiKeyValueArr[tableKeyFormat[0]]['down_payment'];
                    apiKeyValueArr[tableKeyFormat[0]]['purchase_price'] = newObj['purchase_price'];
                    apiKeyValueArr[tableKeyFormat[0]]['property_value'] = newObj['purchase_price'];
                    apiKeyValueArr.loan_amount = newObj['purchase_price'];
                    table_key = "subjectProperty";
                }
                if (table_key == "mortgage") {
                    table_key = "subjectProperty";
                    let tableKeyFormat = table_key.split(".");
                    if (apiKeyValueArr[tableKeyFormat[0]].length == 0) {
                        apiKeyValueArr[tableKeyFormat[0]][0] = {};
                    }
                    apiKeyValueArr[tableKeyFormat[0]][0]['purchase_price'] = newObj['property_value'];
                    apiKeyValueArr.loan_amount = newObj['loan_amount'];
                    table_key = "mortgage";
                }
                this.emitUpdatedDataToStore(handler, apiKeyValueArr);
            }
        }
    }
    getApiKeyValuePair(apiDatas) {
        let apiKeyValue = [];
        if (apiDatas) {
            for (const key of Object.keys(apiDatas.value)) {
                if (key == "handler_name") {
                    continue;
                }
                let indexArr = key.match(/^.*?\[[^\d]*(\d+)[^\d]*\].*$/);
                let index = indexArr ? Number(indexArr[1]) : -1;
                let indexKey = key.split('.')[1];
                let obj = {};
                if (index > -1) {
                    if (apiKeyValue[index]) {
                        apiKeyValue[index][indexKey] = apiDatas.value[key];
                    }
                    else {
                        obj[indexKey] = apiDatas.value[key];
                        apiKeyValue[index] = obj;
                    }
                }
            }
        }
        return apiKeyValue;
    }
    getRepetableBlockDataFromBlockId(blockId) {
        const repeatableLocalStorageData = this.repeatableBlockUtil.getRepeatableLocalStorageDataByBlockId(blockId);
        var repeatableBlockData = [];
        if (repeatableLocalStorageData) {
            for (const objKey of Object.keys(repeatableLocalStorageData)) {
                const fieldDetails = objKey.split("$");
                const fieldData = this.appDataService.getFieldDataByFieldId(objKey);
                if (fieldDetails.length > 2) {
                    if (repeatableBlockData[fieldDetails[2]]) {
                        repeatableBlockData[fieldDetails[2]][fieldDetails[1]] = fieldData;
                    }
                    else {
                        repeatableBlockData[fieldDetails[2]] = { [fieldDetails[1]]: fieldData };
                    }
                }
            }
        }
        return repeatableBlockData;
    }
    getRepetableBlockDataFromBlockIdwithResponseKey(blockId, resKey) {
        const repeatableLocalStorageData = this.repeatableBlockUtil.getRepeatableLocalStorageDataByBlockId(blockId);
        var repeatableBlockData = [];
        if (repeatableLocalStorageData) {
            for (const objKey of Object.keys(repeatableLocalStorageData)) {
                const fieldDetails = objKey.split("$");
                const fieldData = this.appDataService.getFieldDataByFieldId(objKey);
                if (fieldDetails.length > 2) {
                    repeatableBlockData[fieldDetails[2]] = { [resKey]: fieldData };
                }
            }
        }
        return repeatableBlockData;
    }
    emitLoginStateDataToStore(handler, res) {
        if (res.loginStatus) {
            if (handler.invoke_event_config.callback_config?.OnSuccess) {
                if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.OnSuccess)) {
                    this.getOnSuccess(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.OnSuccess));
                }
            }
        }
        else {
            if (handler.invoke_event_config.callback_config?.onFailure) {
                if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure)) {
                    this.getOnFailure(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure));
                }
            }
        }
    }
    emitUpdatedDataToStore(handler, res) {
        var finalRes = {};
        finalRes[(handler.event_handler.includes('##') ? handler.event_handler.split('##')[1] : 'details').replace('[*]', '')] = res;
        const response = {
            handler: handler.event_handler.includes('##') ? handler.event_handler.split('##')[0] : handler.event_handler,
            response: finalRes,
            event_success: true,
            storageType: localStorage.getItem('storageType'),
            statusCode: 0
        };
        const { formattedResponse } = this.externalRequestResponseUtil.storeResponse(response);
        const result = formattedResponse;
        const apiTempData = {
            id: handler.event_handler.includes('##') ? handler.event_handler.split('##')[0] : handler.event_handler,
            apiUrl: handler.event_handler.includes('##') ? handler.event_handler.split('##')[0] : handler.event_handler,
            apiKey: handler.event_handler.includes('##') ? handler.event_handler.split('##')[0] : handler.event_handler,
            value: result.response
        };
        this.apiDataService.setApiDataByApiUrl(Object.assign({}, apiTempData));
        this.sharedEventsServices.emitApiSuccessResponse.emit(result.response);
        if (this.modelValue === 1) {
            if (handler.invoke_event_config.callback_config?.onFailure) {
                if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure)) {
                    this.getOnFailure(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure));
                }
            }
        }
        else {
            if (handler.invoke_event_config.callback_config?.OnSuccess) {
                if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.OnSuccess)) {
                    this.getOnSuccess(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.OnSuccess));
                }
            }
        }
    }
    skipLoaderCheck() {
        const SkipL = this.additionalParameters ? this.additionalParameters.find(i => i.parameter_type == 'SkipLoader') : [];
        this.wfeStepLoaderService.loaderService.skipLoading = SkipL && SkipL['value'] === "true";
    }
    setLanguage(obj) {
        this.wfeStepLoaderService.stepDataStore = {};
        this.wfeStepLoaderService.blockDataStore = {};
        // localStorage.removeItem('stepDataCache');
        // localStorage.removeItem('lastBlockLoaded');
        // localStorage.removeItem('blockDataCache');
        window.localStorage.setItem('langField', obj.uniqueId);
        window.localStorage.setItem('lang', `/${obj.value}`);
        // this.internalCEEEmitter.languageChangeEmitter.emit(`/${obj.value}`);
        window.location.reload();
    }
    stateModified(handler) {
        if (this.hasUnsavedData && this.modalOnPageLeave) {
            /* this.dialog.closeAll();
            history.pushState(null, document.title, document.location.toString());
            this.wfeStepLoaderService.loadStepById(this.modalOnPageLeave).subscribe((data: any) => {
                if (data !== undefined && data.display_as_modal === 1) {
                    this.openDialog(data);
                }
            }); */
            const callBackData = handler.invoke_event_config.callback_config;
            if (callBackData && callBackData.OnSuccess) {
                this.triggerSuccessOrFailure(callBackData.OnSuccess);
            }
        }
        else {
            const callBackData = handler.invoke_event_config.callback_config;
            if (callBackData && callBackData.onFailure) {
                this.triggerSuccessOrFailure(callBackData.onFailure, false);
            }
        }
    }
    historyBack() {
        localStorage.removeItem('modal_on_page_leave');
        let isDrawerOpen = localStorage.getItem('isDrawerOpen');
        if (this.dialog.openDialogs.length || String(isDrawerOpen) == '1') {
            this.dialog.closeAll();
            history.go(-2);
        }
        else {
            //Commented below line and added timeout to close popup and go back by -2
            history.go(-1);
        }
        // this.redirectionUtil.redirectTo(sessionStorage.getItem('previousStepId'));
        localStorage.setItem('forceOnBack', 'true');
    }
    openDialog(data) {
        let isDisableClose = false;
        // data.dismiss_modal = 1 (i.e isDisableClose = true) is to restrict closing the modal when clicking outside the modal or pressing the escape key on the keyboard.
        if (data !== undefined && data.dismiss_modal === 1) {
            isDisableClose = true;
        }
        const dialogRef = this.dialog.open(ModalRendererComponent, { data: { stepId: data.tid, config: { disableClose: isDisableClose } }, id: `stepModal-${data.tid}`, panelClass: `stepModal-${data.tid}` });
        dialogRef.afterClosed().subscribe(result => {
            // console.log('The dialog ' + data.tid + ' was closed.');
        });
    }
    openAlert(data) {
        this.dialog.open(AlertModalComponent, { data: { message: data } });
    }
    getBase64(file) {
        const reader = new FileReader();
        reader.onload = () => {
            // console.log(reader.result);
            this.encriptedFileArray.push(String(reader.result).split('base64,')[1]);
        };
        if (file) {
            reader.readAsDataURL(file);
        }
    }
    async eventHandler(handler, primaryData) {
        // handle all the events
        if (handler.event_handler !== '') {
            this.fileDataArray = [];
            const apiType = localStorage.getItem('API_TYPE');
            let SaveHandler = [];
            if (localStorage.getItem('save_handler')) {
                SaveHandler = localStorage.getItem('save_handler').split('|').map(s => s.trim());
            }
            // File Encription Code
            let eventAdditionalParameters = handler.invoke_event_config ? handler.invoke_event_config.additional_parameters : [];
            let fileEncriptionArr = eventAdditionalParameters?.filter(function (item) {
                return item['parameter_type'] == "FileEncription" && item['value'].toLowerCase() == "base64";
            });
            let table_operations = eventAdditionalParameters?.filter(function (item) {
                return item['parameter_type'] == "table_operations";
            });
            let table_operations_block = eventAdditionalParameters?.filter(function (item) {
                return item['parameter_type'] == "table_operations_block";
            });
            let tableOperations = table_operations?.length > 0 ? table_operations[0]?.value?.toLowerCase() : '';
            let tableOperationsBlock = table_operations_block?.length > 0 ? table_operations_block[0]?.value?.toLowerCase() : '';
            let isFileEncripted = fileEncriptionArr?.length > 0 && fileEncriptionArr[0]?.value?.toLowerCase() == "base64" ? true : false;
            let fileData = this.payLoad && this.payLoad['fileData'] && this.payLoad['fileData']['file'] ? this.payLoad['fileData']['file'] : null;
            this.fileDataArray.push(fileData);
            this.encriptedFileArray = [];
            this.fileDataArray.forEach(file => {
                this.getBase64(file);
            });
            // switch gets called only when there is payload and payLoad type if an file
            if (this.payLoad && this.payLoad.type === 'file' && !isFileEncripted) {
                let success;
                let failure;
                if (handler.invoke_event_config) {
                    success = handler.invoke_event_config.callback_config.OnSuccess ||
                        handler.invoke_event_config.callback_config.onResponse;
                    failure = handler.invoke_event_config.callback_config.onFailure ||
                        handler.invoke_event_config.callback_config.onException;
                }
                // check / get the extra payload from the config
                // extra config Data needs to be passed so that the
                // more parameters can be configured through config
                let extraConfigData = {};
                const apiConfigData = localStorage.getItem('API_CONFIG');
                const parsedData = apiConfigData ? JSON.parse(apiConfigData) : null;
                // get additional parameters
                let additionalParameters = this.getAdditionalParameter(), eventHandlerName = handler.event_handler, // default event handler name
                hasCustomEventHandler = false; // default hasCustomEventHandler flag
                // check if additional parameter CEE_CustomEventHandler is present
                if (additionalParameters.hasOwnProperty('CEE_CustomEventHandler') && additionalParameters['CEE_CustomEventHandler'] !== '') {
                    eventHandlerName = additionalParameters['CEE_CustomEventHandler'];
                    hasCustomEventHandler = true;
                }
                if (parsedData && parsedData[eventHandlerName]) {
                    extraConfigData = this.externalRequestResponseUtil.formTheRequestObj(parsedData[eventHandlerName]);
                    extraConfigData['customEventHandler'] = eventHandlerName;
                    extraConfigData['hasCustomEventHandler'] = hasCustomEventHandler;
                }
                // check if the file action needs token
                if (window.sessionStorage.getItem('CEE_OIDC') == '1' &&
                    extraConfigData.hasAuthorisation == true) {
                    const apiConfigToken = this.sharedEventsServices.apiConfigTokenEmitter.subscribe(async (res) => {
                        apiConfigToken.unsubscribe();
                        // call the act on file action method
                        await this.actOnFileAction(res, handler, success, failure);
                    });
                }
                if (window.sessionStorage.getItem('CEE_OIDC') == '1' &&
                    extraConfigData.hasAuthorisation == true) {
                    // * setting emit token to true so that msal service
                    // * send the api config data back through  apiConfigToken emitter
                    extraConfigData.emitToken = true;
                    this.sharedEventsServices.oidcDataEmitter.emit(extraConfigData);
                }
                else {
                    // call the act on file action method
                    await this.actOnFileAction(extraConfigData, handler, success, failure);
                }
            }
            else {
                switch (apiType) {
                    case 'ESB':
                        let requestBody = this.esbRequestBodyUtil.getESBRequestBody();
                        let queryParams;
                        // would work if the api key is not hashed
                        if (this.getAdditionalParameter()['QueryParameter']) {
                            queryParams = this.getAdditionalParameter()['QueryParameter'].split('|');
                        }
                        if (queryParams) {
                            const body = {};
                            for (const param of queryParams) {
                                body[param] = requestBody[param];
                            }
                            requestBody = body;
                        }
                        this.ceeApiService.ESBRequestHandler(handler.event_handler, requestBody).subscribe(res => {
                            if (res['status'] === 'ok') {
                                const successData = JSON.parse(res['api_response']);
                                const appBaseResult = window.sessionStorage.getItem('ApplicationBaseResultPath');
                                if (successData[appBaseResult] !== undefined) {
                                    this.sharedEventsServices.emitApiSuccessResponse.emit(JSON.parse(res['api_response'])[appBaseResult]);
                                    if (typeof (successData[appBaseResult]) === 'string' ||
                                        typeof (successData[appBaseResult]) === 'number') {
                                        // set the data to the akita store
                                        this.saveData(appBaseResult, handler.event_handler, successData[appBaseResult]);
                                    }
                                    else {
                                        for (const data of Object.keys(successData[appBaseResult])) {
                                            if (typeof (successData[appBaseResult][data]) === 'string' ||
                                                typeof (successData[appBaseResult][data]) === 'number') {
                                                // set the data to the akita store
                                                this.saveData(data, handler.event_handler, successData[appBaseResult][data]);
                                            }
                                            else {
                                                // set the data to the akita store
                                                this.saveData(data, handler.event_handler, JSON.stringify(successData[appBaseResult][data]));
                                            }
                                        }
                                    }
                                }
                                if (handler.invoke_event_config.callback_config.OnSuccess) {
                                    if (this.processCallbackBlocks(JSON.parse(res['api_response']), handler.invoke_event_config.callback_config.OnSuccess)) {
                                        this.getOnSuccess(this.processCallbackBlocks(JSON.parse(res['api_response']), handler.invoke_event_config.callback_config.OnSuccess));
                                    }
                                }
                                else {
                                    if (this.processCallbackBlocks(JSON.parse(res['api_response']), handler.invoke_event_config.callback_config.onResponse)) {
                                        this.getOnResponse(this.processCallbackBlocks(JSON.parse(res['api_response']), handler.invoke_event_config.callback_config.onResponse));
                                    }
                                }
                            }
                            else {
                                if (handler.invoke_event_config.callback_config.onFailure) {
                                    if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure)) {
                                        this.getOnFailure(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure));
                                    }
                                }
                                else {
                                    if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onResponse)) {
                                        this.getOnResponse(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onResponse));
                                    }
                                }
                            }
                        }, err => {
                            if (handler.invoke_event_config.callback_config.onFailure) {
                                if (this.processCallbackBlocks(err, handler.invoke_event_config.callback_config.onFailure)) {
                                    this.getOnFailure(this.processCallbackBlocks(err, handler.invoke_event_config.callback_config.onFailure));
                                }
                            }
                            else {
                                if (this.processCallbackBlocks(err, handler.invoke_event_config.callback_config.onException)) {
                                    this.getOnException(this.processCallbackBlocks(err, handler.invoke_event_config.callback_config.onException));
                                }
                            }
                        });
                        break;
                    case 'INTERNAL':
                    case 'EXTERNAL':
                        let success;
                        let failure;
                        let exception;
                        if (handler.invoke_event_config) {
                            success = handler.invoke_event_config.callback_config.OnSuccess ?
                                handler.invoke_event_config.callback_config.OnSuccess :
                                handler.invoke_event_config.callback_config.onResponse;
                            failure = handler.invoke_event_config.callback_config.onFailure ?
                                handler.invoke_event_config.callback_config.onFailure :
                                handler.invoke_event_config.callback_config.onResponse;
                            exception = handler.invoke_event_config.callback_config.onFailure ?
                                handler.invoke_event_config.callback_config.onFailure :
                                handler.invoke_event_config.callback_config.onException;
                        }
                        const responseSubscription = this.sharedEventsServices.eventResponseSubscriber.subscribe((res) => {
                            if (res.handler !== handler.event_handler) {
                                return;
                            }
                            const result = JSON.parse(JSON.stringify(res));
                            const { formattedResponse, flattenResponse } = this.externalRequestResponseUtil.storeResponse(res);
                            const modifiedResult = formattedResponse;
                            if (flattenResponse.logout) {
                                this.OIDCLogout();
                                responseSubscription.unsubscribe();
                                return;
                            }
                            const internalAPIResponseEmitter = primaryData['internalAPIResponseEmitter'];
                            if (internalAPIResponseEmitter) {
                                internalAPIResponseEmitter.emit(modifiedResult.response);
                                responseSubscription.unsubscribe();
                                return;
                            }
                            if (tableOperations) {
                                let derived_event_handler = '';
                                if (handler?.invoke_event_config?.callback_config?.onResponse[0]?.additional_parameters) {
                                    derived_event_handler = handler.invoke_event_config.callback_config.onResponse[0].additional_parameters.filter(function (el) { return el.parameter_type == 'CEE_table_local_opetation'; }).length > 0 ? handler.invoke_event_config.callback_config.onResponse[0].additional_parameters.filter(function (el) { return el.parameter_type == 'CEE_table_local_opetation'; })[0].value : '';
                                }
                                let handleSaveData = {
                                    result: result.response,
                                    primaryData: primaryData,
                                    tableOperations: tableOperations,
                                    tableOperationsBlock: tableOperationsBlock,
                                    ModalOnPageLeave: null,
                                    event_config: { display_step: derived_event_handler },
                                    event_handler: handler.invoke_event_config.callback_config.onResponse[0].handler,
                                    invoke_event_config: {
                                        additional_parameters: handler.invoke_event_config.callback_config.onResponse[0].additional_parameters
                                    }
                                };
                                if (tableOperationsBlock !== 'subject_property' && tableOperationsBlock !== 'subject_property_mortgage' && tableOperationsBlock !== 'mortgage' && tableOperationsBlock !== 'update_subject_property') {
                                    if (handleSaveData.tableOperations === "save" && tableOperationsBlock !== 'properties') {
                                        this.saveLocalDataProcess(handleSaveData, handleSaveData.primaryData, handleSaveData.result);
                                    }
                                    if (handleSaveData.tableOperations === "update" && tableOperationsBlock !== 'properties') {
                                        this.updateLocalDataProcess(handleSaveData, handleSaveData.primaryData, handleSaveData.result);
                                    }
                                    if (handleSaveData.tableOperations === "delete" && tableOperationsBlock !== 'properties' && tableOperationsBlock !== 'mortgagedelete') {
                                        this.deleteLocalDataProcess(handleSaveData, handleSaveData.primaryData, handleSaveData.result);
                                    }
                                }
                                else {
                                    if (tableOperationsBlock === 'subject_property' || tableOperationsBlock === 'mortgage') {
                                        this.handlerSaveData[tableOperationsBlock] = handleSaveData;
                                    }
                                }
                            }
                            if (result.event_success) {
                                this.sharedEventsServices.emitApiSuccessResponse.emit(modifiedResult.response);
                                if (success) {
                                    const successCallback = this.processCallbackBlocks(flattenResponse, success);
                                    if (successCallback) {
                                        if (SaveHandler.includes(res.handler)) {
                                            localStorage.removeItem('has_unsaved_data');
                                        }
                                        const _this = this;
                                        setTimeout(() => {
                                            _this.getOnSuccess(successCallback);
                                        }, 0);
                                    }
                                }
                                responseSubscription.unsubscribe();
                            }
                            else {
                                if (failure) {
                                    const failureCallback = this.processCallbackBlocks(flattenResponse, failure);
                                    if (failureCallback) {
                                        this.getOnFailure(failureCallback);
                                    }
                                }
                                responseSubscription.unsubscribe();
                            }
                        }, err => {
                            console.error(`Error Occurred while fetching response. ${err}`);
                            if (exception) {
                                const exceptionCallback = this.processCallbackBlocks(err, exception);
                                if (exceptionCallback) {
                                    this.getOnFailure(exceptionCallback);
                                }
                            }
                            responseSubscription.unsubscribe();
                        });
                        const SaveResponseDataStepId = handler.invoke_event_config && handler.invoke_event_config.additional_parameters ? handler.invoke_event_config.additional_parameters.find(function (p) { return p.parameter_type === 'SaveResponseData'; }) : null;
                        if (SaveResponseDataStepId && SaveResponseDataStepId.value) {
                            this.internalResponseUtil.saveResponseData(SaveResponseDataStepId.value);
                        }
                        if (isFileEncripted) {
                            setTimeout(() => {
                                this.externalRequestResponseUtil.prepareObjectToBeSent(handler.event_handler, apiType === 'INTERNAL' ? 'internal' : '', true, this.downloadType, this.encriptedFileArray, primaryData, tableOperations, tableOperationsBlock);
                            }, 1000);
                        }
                        else {
                            this.externalRequestResponseUtil.prepareObjectToBeSent(handler.event_handler, apiType === 'INTERNAL' ? 'internal' : '', true, this.downloadType, [], primaryData, tableOperations, tableOperationsBlock);
                        }
                        break;
                    default:
                        let appData = [];
                        let apiData = [];
                        // store the appData
                        this.appDataService.getAllAppData().subscribe(res => {
                            // console.log('appData', res);
                            if (localStorage.getItem('singleApiKey') === 'true') {
                                appData = res;
                            }
                            else {
                                let finalArr = [];
                                for (const data of res) {
                                    let obj = {};
                                    const arr = [];
                                    for (const requestKey of data['requestApiKey']) {
                                        obj = data;
                                        obj = { ...obj, apiKey: requestKey };
                                        arr.push(obj);
                                    }
                                    finalArr = [...finalArr, ...arr];
                                }
                                appData = finalArr;
                            }
                            // console.log('app Data', appData);
                        });
                        // store the apiData
                        this.apiDataService.getAllApiData().subscribe(res => {
                            // console.log('apiData', res);
                            apiData = res;
                        });
                        // update the app data with the mandatory data from the repeatable block
                        for (const data in appData) {
                            if (appData[data].linkedBlockId) {
                                const obj = {};
                                obj['mandatory'] =
                                    this.repeatableBlockUtil.getRepeatableLocalStorageData(appData[data].linkedBlockId, String(appData[data].id))['isMandatory'];
                                appData[data] = { ...appData[data], ...obj };
                            }
                        }
                        // console.log(appData);
                        const eventHandlerEmitterObject = {
                            handler: handler.event_handler,
                            appData,
                            apiData
                        };
                        this.sharedEventsServices.eventHandlerEmitter.emit(eventHandlerEmitterObject);
                        // subscribe to the outer event
                        const subscription = this.sharedEventsServices.eventResponseSubscriber.subscribe(res => {
                            if (res['event_sucess']) {
                                if (res['listResult']) {
                                    this.sharedEventsServices.emitApiSuccessResponse.emit(res['listResult']);
                                }
                                else {
                                    this.sharedEventsServices.emitApiSuccessResponse.emit(res);
                                }
                                if (typeof (res) === 'string' ||
                                    typeof (res) === 'number') {
                                    // set the data to the akita store
                                    this.saveData(String(res), handler.event_handler, res);
                                }
                                else {
                                    for (const data of Object.keys(res)) {
                                        if (typeof (res[data]) === 'string' ||
                                            typeof (res[data]) === 'number') {
                                            // set the data to the akita store
                                            this.saveData(data, handler.event_handler, res[data]);
                                        }
                                        else {
                                            // set the data to the akita store
                                            this.saveData(data, handler.event_handler, JSON.stringify(res[data]));
                                        }
                                    }
                                }
                                if (handler.invoke_event_config.callback_config.OnSuccess) {
                                    if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.OnSuccess)) {
                                        this.getOnSuccess(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.OnSuccess));
                                    }
                                }
                                else {
                                    if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onResponse)) {
                                        this.getOnResponse(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onResponse));
                                    }
                                }
                                subscription.unsubscribe();
                            }
                            else {
                                if (handler.invoke_event_config.callback_config.onFailure) {
                                    if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure)) {
                                        this.getOnFailure(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onFailure));
                                    }
                                }
                                else {
                                    if (this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onResponse)) {
                                        this.getOnResponse(this.processCallbackBlocks(res, handler.invoke_event_config.callback_config.onResponse));
                                    }
                                }
                                subscription.unsubscribe();
                            }
                        });
                        break;
                }
            }
        }
    }
    updateMortageSubjectPropertyData() {
        let handleSaveData = this.handlerSaveData['subject_property'] ? this.handlerSaveData['subject_property'] : this.handlerSaveData['mortgage'];
        if (handleSaveData?.tableOperations === "save") {
            this.saveLocalDataProcess(handleSaveData, handleSaveData.primaryData, handleSaveData.result);
        }
        if (handleSaveData?.tableOperations === "update") {
            this.updateLocalDataProcess(handleSaveData, handleSaveData.primaryData, handleSaveData.result);
        }
        if (handleSaveData?.tableOperations === "delete") {
            this.deleteLocalDataProcess(handleSaveData, handleSaveData.primaryData, handleSaveData.result);
        }
    }
    /**
     * method acts on each and every file action
     * @param extraConfigData: api config data
     * @param handler: the event handler
     * @param success: the success event
     * @param failure: the failure event
     * @returns void
     */
    async actOnFileAction(extraConfigData, handler, success, failure) {
        let eventHandlerName = handler.event_handler;
        if (extraConfigData.hasOwnProperty('hasCustomEventHandler') && extraConfigData['hasCustomEventHandler']) {
            eventHandlerName = extraConfigData['customEventHandler'];
        }
        if (extraConfigData.isExternal) {
            extraConfigData.handler = handler.event_handler;
            if (this.payLoad && this.payLoad.fileData) {
                extraConfigData.attachmentId = this.payLoad.fileData.attachmentId;
            }
            this.sharedEventsServices.eventHandlerEmitter.emit(extraConfigData);
            return;
        }
        const response = await this.fileUploadService.genericFileService(this.event.event_name, this.payLoad, extraConfigData, handler.event_handler);
        //
        if (Number(response.statusCode) === 200) {
            // call on response or on success
            if (response.emit) {
                const apiKeyData = this.apiDataService.getApiDataByHandler(eventHandlerName);
                this.sharedEventsServices.emitApiSuccessResponse.emit(apiKeyData.value);
            }
            const successCallback = this.processCallbackBlocks({ body: response.data, status: response.statusCode }, success);
            if (successCallback && success) {
                this.getOnSuccess(successCallback);
            }
        }
        else {
            // call on exception or on failure
            if (response.emit) {
                this.sharedEventsServices.emitApiErrorResponse.emit(response.data);
            }
            const failureCallback = this.processCallbackBlocks({ body: response.data, status: response.statusCode }, failure);
            if (failureCallback && failure) {
                this.getOnFailure(failureCallback);
            }
        }
    }
    /**
     * Redirect to logout when the response is to logout the user
     */
    OIDCLogout() {
        let logout = '';
        if (window.sessionStorage.getItem('CEE_Login_Step')) {
            logout = window.sessionStorage.getItem('CEE_Login_Step');
        }
        else {
            console.error(`CEE_Login_Step Not Found in global application constants.
             So redirecting to default step of the default sequence `);
            logout = Object.values(this.wfeStepLoaderService.sequenceDataMap)[0];
        }
        window.sessionStorage.clear();
        this.appDataService.removeAllAppData();
        this.apiDataService.removeAllApiData();
        this.wfeStepLoaderService.stepDataStore = {};
        this.wfeStepLoaderService.blockDataStore = {};
        // localStorage.removeItem('stepDataCache');
        // localStorage.removeItem('lastBlockLoaded');
        // localStorage.removeItem('blockDataCache');
        this.redirectionUtil.redirectTo(logout);
    }
    saveData(key, url, apiValue) {
        const apiData = {
            id: key,
            apiUrl: url,
            apiKey: key,
            value: apiValue
        };
        // console.log(apiData)
        this.apiDataService.setApiData(Object.assign({}, apiData));
    }
    processCallbackBlock(res, failureBlocks) {
        let callbackBlock;
        if (failureBlocks) {
            for (const failure of failureBlocks) {
                // console.log('failure block', failure);
                const data = this.checkResponseValues(res, failure);
                if (data) {
                    callbackBlock = data;
                }
            }
        }
        // console.log(callbackBlock);
        return callbackBlock;
    }
    processCallbackBlocks2(res, failureBlocks) {
        let callbackBlock = [];
        if (failureBlocks) {
            for (const failure of failureBlocks) {
                // console.log('failure block', failure);
                const data = this.checkResponseValues(res, failure);
                if (data) {
                    callbackBlock.push(data);
                }
            }
        }
        // console.log(callbackBlock);
        return callbackBlock;
    }
    processCallbackBlocks(res, failureBlocks) {
        const callbackBlock = [];
        if (failureBlocks && failureBlocks.length > 0) {
            const actualStatus = res?.statusCode?.toString() || res?.status?.toString() || res?.header_status?.toString() || res?.return?.toString() || '200'; // Default to 200 if not defined
            for (const failure of failureBlocks) {
                const expectedStatus = failure?.api_response?.header_status?.toString();
                // ✅ Check header_status per block if defined
                if (expectedStatus && expectedStatus !== actualStatus) {
                    continue; // ❌ skip this block, status mismatch
                }
                // ✅ Now check response_values and conditions
                const data = this.checkResponseValues(res, failure);
                if (data) {
                    callbackBlock.push(data);
                }
            }
        }
        return callbackBlock;
    }
    checkResponseValues(res, callbackConfigBlock) {
        const { header_status, response_values } = callbackConfigBlock.api_response;
        let contains = true;
        let statusPass = true;
        const response = JSON.parse(JSON.stringify(res)); // to check the status code as res.body is getting assigned to res
        res = res && res.body ? res.body : res;
        // check if res has status then check status else check the response
        if (response.body && response.status && header_status && header_status != response.status) {
            statusPass = false;
            contains = null;
        }
        if (statusPass && response_values && Object.keys(response_values).length > 0) {
            contains = null;
            const referenceValues = Object.assign({}, response_values);
            Object.keys(referenceValues).forEach(key => {
                if (contains === false) {
                    return;
                }
                if (res[key] == referenceValues[key]) {
                    contains = true;
                }
                else if (res[key] !== null && (typeof (res[key]) === 'boolean' || typeof (res[key]) === 'object' || Array.isArray(res[key]))
                    && JSON.stringify(res[key]) === JSON.stringify(JSON.parse(referenceValues[key]))) {
                    contains = true;
                }
                else if (referenceValues[key].includes('|') && referenceValues[key].split('|').map(str => str.trim()).includes(res[key])) {
                    contains = true;
                }
                else if (referenceValues[key] === "*" && res[key]) {
                    contains = true;
                }
                else {
                    contains = false;
                    return;
                }
            });
        }
        // console.log(contains);
        if (contains) {
            return callbackConfigBlock;
        }
        else {
            return undefined;
        }
    }
    getOnFailure(failureBlock) {
        // console.log("failureBlock: ",failureBlock)
        if (failureBlock !== undefined) {
            // act on failure
            if (!isArray(failureBlock)) {
                failureBlock = [failureBlock];
            }
            failureBlock.forEach(event => {
                this.executeEventCallback(event);
            });
        }
        else {
            if (this.failure !== undefined) {
                for (const event of this.failure) {
                    this.executeEventCallback(event);
                }
            }
        }
    }
    /**
     *  get Response is executed every time there is an API Call
     *  be it ESB or Generic Mapper or Response Recieved for the Project End API Call
     */
    getOnResponse(responseBlock) {
        // console.log("responseBlock: ",responseBlock)
        if (responseBlock !== undefined) {
            // act on response
            if (!isArray(responseBlock)) {
                responseBlock = [responseBlock];
            }
            responseBlock.forEach(event => {
                this.executeEventCallback(event);
            });
        }
        else {
            if (this.response !== undefined) {
                for (const event of this.response) {
                    this.executeEventCallback(event);
                }
            }
        }
    }
    /**
     * Exception Block is only triggered when there is an exception in case of API calling
     * @param exceptionBlock
     */
    getOnException(exceptionBlock) {
        // console.log("exceptionBlock: ",exceptionBlock)
        if (exceptionBlock !== undefined) {
            // act on Excption
            if (!isArray(exceptionBlock)) {
                exceptionBlock = [exceptionBlock];
            }
            exceptionBlock.forEach(event => {
                this.executeEventCallback(event);
            });
        }
        else {
            if (this.response !== undefined) {
                for (const event of this.exception) {
                    this.executeEventCallback(event);
                }
            }
        }
    }
    getOnSuccess(successBlock) {
        // console.log("successBlock: ",successBlock)
        if (successBlock !== undefined) {
            // act on success
            if (!isArray(successBlock)) {
                successBlock = [successBlock];
            }
            successBlock.forEach(event => {
                this.executeEventCallback(event);
            });
        }
        else {
            if (this.success !== undefined) {
                // console.log(this.success);
                for (const event of this.success) {
                    this.executeEventCallback(event);
                }
            }
        }
    }
    executeEventCallback(event) {
        if (!event) {
            return false;
        }
        if (event.NavigatetoNextPage) {
            this.redirectTo(event.NavigatetoNextPage);
        }
        // console.log(event, 'called');
        if (event.next_event_id !== '') {
            // check buffer time
            const bufferTime = event.additional_parameters ? event.additional_parameters.find((i) => i.parameter_type === 'BufferTime') : null;
            setTimeout(() => {
                this.executeEvent(event.next_event_id);
            }, bufferTime && !isNaN(Number(bufferTime.value)) ? Number(bufferTime.value) : 0);
        }
        else {
            this.updateMortageSubjectPropertyData();
        }
        // execute handler
        // execute message code
        const inlineErrorField = event.additional_parameters ? event.additional_parameters.find((i) => i.parameter_type === 'InlineErrorField') : null;
        const message = this.wfeStepLoaderService.getMessage(event.message_code);
        if (message) {
            if (inlineErrorField) {
                document.getElementById(inlineErrorField.value).innerHTML = '<div class="alert alert-danger">' + message + '</div>';
            }
            else {
                const timeOut = Number(localStorage.getItem('messageTimeOut'));
                this.snackBar.dismiss();
                if (timeOut !== 0) {
                    this.snackBar.open(message, 'OK', {
                        verticalPosition: 'top',
                        panelClass: ['mat-toolbar', 'mat-primary'],
                        duration: Number(timeOut)
                    });
                }
                else {
                    this.snackBar.open(message, 'OK', {
                        verticalPosition: 'top',
                        panelClass: ['mat-toolbar', 'mat-primary']
                    });
                }
            }
        }
        else {
            if (inlineErrorField) {
                document.getElementById(inlineErrorField.value).innerHTML = '';
            }
        }
        // ==== deprecated feature
        // for (const additionalParam of event.additional_parameters) {
        //     if (additionalParam.value) {
        //         const object = {
        //             display_step: (additionalParam.value).split('|')[0]
        //         };
        //         // console.log(object);
        //         this.eventConfig(object, '');
        //     }
        // }
    }
    // special event handler to handle the session clear event
    sessionEventHandler(handler, parameterType) {
        if (handler.event_handler !== '') {
            const obj = {};
            let arr = [];
            for (const additionalParameter of this.additionalParameters) {
                if (additionalParameter.parameter_type === parameterType) {
                    arr = [...arr, ...additionalParameter.value.includes('|') ?
                            additionalParameter.value.split('|').map(str => str.trim()) :
                            new Array(additionalParameter.value)];
                }
            }
            obj[handler.event_handler] = arr;
            return obj;
        }
    }
    // special event handler to handle the Display Modal event
    displayModal(handler) {
        let modals = JSON.parse(localStorage.getItem('modals'));
        modals.forEach((modal, i) => {
            if (modal.modalId == handler.event_handler) {
                const dialogRef = this.dialog.open(ModalRendererComponent, { data: { modal: modal }, id: `eventModal-${handler.event_handler}`, panelClass: `eventModal-${handler.event_handler}` });
                dialogRef.afterClosed().subscribe(result => {
                    // console.log('The dialog ' + modal.modalId + ' was closed.');
                });
            }
        });
    }
    // Add class to the element with '.cdk-overlay-pane' class selector of a modal.
    toggleModalCssClass() {
        const modalWrapper = window.document.querySelector('.cdk-overlay-pane');
        if (modalWrapper) {
            modalWrapper.classList.toggle('modal-step-wrapper');
            modalWrapper.classList.toggle(this.modalGenericCssClass);
        }
    }
    // special event handler to handle the mandatory check event
    copyToClipboardEventHandler(handler) {
        if (handler.event_handler !== '') {
            for (const additionalParam of this.additionalParameters) {
                const object = {};
                object[handler.event_handler] = additionalParam.value;
                this.switchCopyToClipboardType(object);
            }
        }
    }
    // special event handler to highlight Map Marker
    highlightMapMarker(handler) {
        const additionalParams = this.getAdditionalParameter();
        if (additionalParams['MapMarkerKey']) {
            this.sharedEventsServices.mapMarkerEmitter.emit(additionalParams);
        }
    }
    // special event handler to Search Filter
    searchFilter(handler) {
        const additionalParams = this.getAdditionalParameter();
        const obj = {
            uniqueIds: [],
            filterCol: [],
            values: []
        };
        obj['uniqueIds'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
        obj['values'] = this.appDataService.getFieldDataByFieldIds(additionalParams['ValueFields'], '|');
        obj['filterCol'] = this.appDataService.getFieldDataByFieldIds(additionalParams['FilterColumnKeys'], '|').filter(str => str).length ? this.appDataService.getFieldDataByFieldIds(additionalParams['FilterColumnKeys'], '|') :
            additionalParams['FilterColumnKeys'].split('|').map(str => str.trim());
        if (this.getAdditionalParameter()['TargetFields']) {
            this.sharedEventsServices.searchFilterEmitter.emit(obj);
        }
    }
    // special event handler to map Center
    mapCenter(handler) {
        const additionalParams = this.getAdditionalParameter();
        const obj = {
            uniqueIds: [],
            values: []
        };
        obj['uniqueIds'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
        obj['values'] = this.appDataService.getFieldDataByFieldIds(additionalParams['ValueFields'], '|');
        if (additionalParams['TargetFields']) {
            this.sharedEventsServices.mapCenterEmitter.emit(obj);
        }
    }
    // special event handler to map Layer
    MapLayer(handler) {
        const additionalParams = this.getAdditionalParameter();
        const obj = {
            uniqueIds: [],
            values: []
        };
        obj['uniqueIds'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
        obj['values'] = this.appDataService.getFieldDataByFieldIds(additionalParams['ValueFields'], '|');
        if (additionalParams['TargetFields']) {
            this.sharedEventsServices.mapLayerEmitter.emit(obj);
        }
    }
    // special event handler to Toggle Accordion
    toggleAccordion(handler) {
        this.sharedEventsServices.toggleAccordionEmitter.emit(this.getAdditionalParameter());
    }
    // execute OnLoad events of current step
    executeStepOnLoadEvents() {
        let oldUrl = this.router.url;
        this.router.navigateByUrl("/dummy-unknown-route", { skipLocationChange: true, state: { "executeOnLoadEvents": true } })
            .then(() => {
            this.router.navigate([oldUrl]);
        });
    }
    // customFunctions
    customFunctions(handler, parameter_type1, parameter_type2, primaryData) {
        const obj = {};
        let variables = [];
        let targets = [];
        for (const additionalParameter of this.additionalParameters) {
            if (additionalParameter.parameter_type === parameter_type1) {
                variables = [...variables, ...additionalParameter.value.includes('|') ?
                        additionalParameter.value.split('|').map(str => str.trim()) :
                        new Array(additionalParameter.value)];
            }
            if (additionalParameter.parameter_type === parameter_type2) {
                targets = [...targets, ...additionalParameter.value.includes('|') ?
                        additionalParameter.value.split('|').map(str => str.trim()) :
                        new Array(additionalParameter.value)];
            }
        }
        this.switchCustomHandlerFunction(handler, variables, targets, primaryData);
    }
    executeEvent(eventId) {
        // execute the event
        for (const singleEvent of this.event_list) {
            // console.log(this.event_list, singleEvent['event_id'], eventId);
            if (singleEvent['event_id'] === eventId) {
                this.switchEventDisplayType(singleEvent, this.event_list);
                break;
            }
        }
    }
    async switchClearenceType(clearObject, handlerData, primaryData = {}) {
        let rootData = this.wfeStepLoaderService.rootData;
        const keys = Object.keys(clearObject);
        let blocks;
        // let blockKeys = [];
        let uniqueIds = [];
        let apiKeys = [];
        let stepIds = [];
        let handlers = [];
        let stepValues;
        let fromStep = false;
        switch (keys[0]) {
            case 'workflow':
                for (const steps of clearObject[keys[0]]) {
                    stepIds = [...stepIds, ...this.wfeStepLoaderService.getListOfStepIdsByWorkflow(steps)];
                }
                stepValues = this.appDataService.getAllAppStoreData();
                for (const stepVal of stepValues) {
                    if (stepIds.includes(stepVal.stepId)) {
                        uniqueIds.push(stepVal.id);
                        apiKeys.push(stepVal.apiKey);
                        apiKeys = [...apiKeys, ...stepVal.requestApiKey];
                        apiKeys = [...apiKeys, ...stepVal.responseApiKey];
                        fromStep = true;
                        if (stepVal.linkedBlockId) {
                            this.repeatableBlockUtil.removeByBlockId(stepVal.linkedBlockId);
                        }
                    }
                }
                break;
            case 'handler':
                handlers = Object.assign(handlers, clearObject[keys[0]]);
                break;
            case 'block':
                for (const blockKey of clearObject[keys[0]]) {
                    if (rootData && rootData.blockFields && rootData.blockFields[blockKey]) {
                        uniqueIds = [...uniqueIds, ...rootData.blockFields[blockKey]];
                    }
                }
                break;
            case 'step':
                stepValues = this.appDataService.getAllAppStoreData();
                stepIds = clearObject[keys[0]];
                for (const stepVal of stepValues) {
                    if (stepIds.includes(stepVal.stepId)) {
                        uniqueIds.push(stepVal.id);
                        apiKeys.push(stepVal.apiKey);
                        apiKeys = [...apiKeys, ...stepVal.requestApiKey];
                        apiKeys = [...apiKeys, ...stepVal.responseApiKey];
                        fromStep = true;
                        if (stepVal.linkedBlockId) {
                            this.repeatableBlockUtil.removeByBlockId(stepVal.linkedBlockId);
                        }
                    }
                }
                break;
            case 'section':
                for (const blockKey of clearObject[keys[0]]) {
                    if (rootData && rootData.sectionFields && rootData.sectionFields[blockKey]) {
                        uniqueIds = [...uniqueIds, ...rootData.sectionFields[blockKey]];
                    }
                }
                break;
            case 'field':
                uniqueIds = [...uniqueIds, ...clearObject[keys[0]]];
                break;
            case 'repeatable_block':
                const allAPPData = this.appDataService.getAllAppStoreData();
                clearObject[keys[0]].forEach((repeatBlockId) => {
                    // const repeatBlock = allAPPData.find(i => i.id === repeatBlockId || i.linkedBlockId === repeatBlockId);
                    let foundByLinkedBlockId = false; // to check if the repeat block is found by linkedBlockId
                    const repeatBlock = allAPPData.find(i => {
                        if (i.id === repeatBlockId) {
                            foundByLinkedBlockId = false;
                            return true;
                        }
                        else if (i.linkedBlockId === repeatBlockId) {
                            foundByLinkedBlockId = true;
                            return true;
                        }
                        return false;
                    });
                    if (repeatBlock) {
                        if (repeatBlock.stepId == window['currentStepId'] && !foundByLinkedBlockId) {
                            // Handle the case where block is on current step and not found by linkedBlockId
                            this.sharedEventsServices.repeatableBlockSessionClearanceEmitter.emit(repeatBlockId);
                        }
                        else {
                            // Common code path for both cases where foundByLinkedBlockId is true
                            // or when repeatBlock.stepId != window['currentStepId'] and foundByLinkedBlockId is false
                            if (foundByLinkedBlockId) {
                                // Get all ids of the repeatable block when found by linkedBlockId
                                const filteredIds = allAPPData.reduce((acc, i) => {
                                    if (i.linkedBlockId === repeatBlockId) {
                                        acc.push(i.id);
                                    }
                                    return acc;
                                }, []);
                                uniqueIds = [...uniqueIds, ...filteredIds, repeatBlockId];
                                if (repeatBlockId) {
                                    localStorage.removeItem(repeatBlockId + '_count');
                                    localStorage.removeItem('RepeatableBlock_' + repeatBlockId);
                                }
                            }
                            else {
                                // Handle case when block is not on current step and not found by linkedBlockId
                                let linkBlockId = null;
                                uniqueIds = allAPPData
                                    .filter(i => {
                                    linkBlockId = i.linkedBlockId;
                                    return i.repeatedBlockFieldId === repeatBlockId;
                                })
                                    .map(i => i.id);
                                uniqueIds.push(repeatBlockId);
                                if (linkBlockId) {
                                    localStorage.removeItem(linkBlockId + '_count');
                                    localStorage.removeItem('RepeatableBlock_' + linkBlockId);
                                }
                            }
                        }
                    }
                });
                break;
            case 'associated_repeatable_block':
                this.sharedEventsServices.associatedRepeatableBlockSessionClearanceEmitter.emit(clearObject[keys[0]]);
                break;
            case 'api_key':
                apiKeys = [...apiKeys, ...clearObject[keys[0]]];
                break;
            case 'all':
                /*  window.sessionStorage.clear(); */
                this.dialog.closeAll();
                this.wfeStepLoaderService.stepDataStore = {};
                this.wfeStepLoaderService.blockDataStore = {};
                // localStorage.removeItem('stepDataCache');
                // localStorage.removeItem('lastBlockLoaded');
                // localStorage.removeItem('blockDataCache');
                this.appDataService.removeAllAppData();
                this.apiDataService.removeAllApiData();
                break;
        }
        const callBackData = handlerData.invoke_event_config.callback_config;
        if (handlers.length) {
            for (const handler of handlers) {
                this.apiDataService.deleteApiData(handler);
            }
        }
        const skipFieldsId = handlerData.invoke_event_config.additional_parameters.find(i => i.parameter_type === 'SkipEraseFields');
        let skipFieldsIds = [];
        if (skipFieldsId) {
            skipFieldsIds = skipFieldsId.value.split('|');
        }
        uniqueIds = uniqueIds.filter(e => !skipFieldsIds.includes(e));
        this.undoRedoUtil.deletById(uniqueIds);
        this.associatedMaputil.deleteByIds(uniqueIds);
        this.appDataService.deleteMultipleAppData(uniqueIds);
        // clear the language in the session storage
        if (uniqueIds.includes(window.localStorage.getItem('langField'))) {
            window.localStorage.removeItem('lang');
            this.wfeStepLoaderService.stepDataStore = {};
            this.wfeStepLoaderService.blockDataStore = {};
            // localStorage.removeItem('stepDataCache');
            // localStorage.removeItem('lastBlockLoaded');
            // localStorage.removeItem('blockDataCache');
        }
        const userInfoHandler = this.OIDCinfo && this.OIDCinfo['userInfoHandler'] ? this.OIDCinfo['userInfoHandler'] : "userInfo";
        apiKeys = apiKeys.filter(e => {
            if (userInfoHandler && this.commonUtil.getHandlerName(e) === userInfoHandler) {
                return false;
            }
            else {
                return true;
            }
        });
        this.apiDataService.deleteMultipleApiData(apiKeys, fromStep);
        this.triggerSuccessOrFailure(callBackData.OnSuccess);
    }
    // getter setter goes here
    get OIDCinfo() {
        return localStorage.getItem('oidc_config') ? localStorage.getItem('oidc_config') : false;
    }
    async switchClearAkitaStore(clearObject, handlerData, primaryData = {}) {
        let rootData = this.wfeStepLoaderService.rootData;
        const keys = Object.keys(clearObject);
        const emitterObj = {
            unique_ids: [],
            apiKeys: []
        };
        let isAssociated = false;
        let isRBKey = false;
        let stepList;
        let uniqueIdJSON;
        let blockKeys;
        let sectionKeys;
        const skipFieldsId = handlerData.invoke_event_config.additional_parameters.find(i => i.parameter_type === 'SkipEraseFields');
        let skipFieldsIds = [];
        if (skipFieldsId) {
            skipFieldsIds = skipFieldsId.value.split('|');
        }
        let key = keys[0];
        if (key.startsWith('rb_')) {
            isRBKey = true;
            key = key.replace('rb_', '');
        }
        switch (key) {
            case 'workflow':
                stepList = this.wfeStepLoaderService.getListOfStepIdsByWorkflow(clearObject[keys[0]]);
                uniqueIdJSON = await this.wfeStepLoaderService.loadWFEUniqueIdJSON().toPromise();
                emitterObj['unique_ids'] = this.getSessionKeyBySteps(stepList, uniqueIdJSON);
                break;
            case 'block':
                blockKeys = [];
                for (const blockKey of clearObject[keys[0]]) {
                    if (rootData && rootData.blockFields && rootData.blockFields[blockKey]) {
                        blockKeys = [...blockKeys, ...rootData.blockFields[blockKey]];
                    }
                }
                emitterObj['unique_ids'] = blockKeys;
                break;
            case 'step':
                const stepAppValues = this.appDataService.getAllAppStoreData();
                stepList = clearObject[keys[0]];
                const stepfieldIds = [];
                for (const stepVal of stepAppValues) {
                    if (stepList.includes(stepVal.stepId)) {
                        if (stepVal.repeatedBlockFieldId != "") {
                            const repeatFieldArr = stepVal.id.split('$');
                            if (repeatFieldArr.length > 0 && !skipFieldsIds.includes(repeatFieldArr[1])) {
                                stepfieldIds.push(stepVal.id);
                            }
                        }
                        else {
                            if (!skipFieldsIds.includes(stepVal.id)) {
                                stepfieldIds.push(stepVal.id);
                            }
                        }
                    }
                }
                emitterObj['unique_ids'] = [...new Set(stepfieldIds)];
                break;
            case 'section':
                sectionKeys = [];
                for (const blockKey of clearObject[keys[0]]) {
                    if (rootData && rootData.sectionFields && rootData.sectionFields[blockKey]) {
                        sectionKeys = [...sectionKeys, ...rootData.sectionFields[blockKey]];
                    }
                }
                sectionKeys = sectionKeys.filter(e => !skipFieldsIds.includes(e));
                emitterObj['unique_ids'] = sectionKeys;
                break;
            case 'repeatable_block':
                const stepValues = this.appDataService.getAllAppStoreData();
                const repeatedBlockIds = clearObject[keys[0]];
                const fieldIds = [];
                for (const stepVal of stepValues) {
                    if (repeatedBlockIds.includes(stepVal.repeatedBlockFieldId)) {
                        const repeatFieldArr = stepVal.id.split('$');
                        if (!skipFieldsIds.includes(repeatFieldArr[1])) {
                            fieldIds.push(stepVal.id);
                        }
                    }
                }
                emitterObj['unique_ids'] = [...new Set(fieldIds)];
                break;
            case 'associated_field':
            case 'field':
                if (keys[0] === 'associated_field') {
                    isAssociated = true;
                }
                emitterObj['unique_ids'] = clearObject[keys[0]];
                break;
            case 'api_key':
                emitterObj['apiKeys'] = clearObject[keys[0]];
                emitterObj['skipFieldsIds'] = skipFieldsIds;
                break;
        }
        // console.log(emitterObj);
        if (isAssociated) {
            emitterObj['isAssociated'] = true;
        }
        const callBackData = handlerData.invoke_event_config.callback_config;
        if (emitterObj.unique_ids.length > 0) {
            // for repeatable field
            if (isRBKey) {
                let unique_id = primaryData?.value?.unique_id;
                if (unique_id) {
                    let words = unique_id.split('$');
                    if (words.length === 3) {
                        emitterObj.unique_ids.forEach((ele, index, arr) => {
                            arr[index] = `${words[0]}$${ele}$${words[2]}`;
                        });
                    }
                    else if (words.length === 4) {
                        emitterObj.unique_ids.forEach((ele, index, arr) => {
                            arr[index] = `${words[0]}$${ele}$${words[2]}$${words[3]}`;
                        });
                    }
                }
            }
            this.appDataService.clearDataUsingUniqueIds(emitterObj.unique_ids, (message) => {
                setTimeout(() => {
                    this.sharedEventsServices.emitForEmptySession.emit(emitterObj);
                    if (message) {
                        if (callBackData && callBackData.OnSuccess) {
                            this.triggerSuccessOrFailure(callBackData.OnSuccess);
                        }
                    }
                    else {
                        // console.log('Error Occurred while clearing session data', message);
                    }
                }, 0);
            });
        }
        else if (emitterObj.apiKeys.length > 0) {
            this.appDataService.clearDataUsingApiKeys(emitterObj.apiKeys, (message) => {
                this.sharedEventsServices.emitForEmptySession.emit(emitterObj);
                if (message) {
                    if (callBackData && callBackData.OnSuccess) {
                        this.triggerSuccessOrFailure(callBackData.OnSuccess);
                    }
                }
                else {
                    // console.log('Error Occurred while clearing session data', message);
                }
            });
        }
        else {
            this.sharedEventsServices.emitForEmptySession.emit(emitterObj);
            if (callBackData && callBackData.onFailure) {
                this.triggerSuccessOrFailure(callBackData.onFailure, false);
            }
        }
    }
    /**
     * function triggers success or failure based on the type
     * true for success and false for failure
     */
    triggerSuccessOrFailure(callbacks, type = true) {
        if (callbacks) {
            callbacks.forEach(callback => {
                if (type) {
                    this.getOnSuccess(callback);
                }
                else {
                    this.getOnFailure(callback);
                }
            });
        }
        else {
            return;
        }
    }
    async switchMandatoryCheckType(clearObject, handlerData) {
        const keys = Object.keys(clearObject);
        const additionalParam = this.getAdditionalParameter();
        const fieldData = [];
        let stepIds = [];
        let blockKeys = [];
        const emptyFieldIds = [];
        let blocks;
        const appStoreData = this.appDataService.getAllAppStoreData();
        const mandatoryArr = []; // only done because dcss requires to check all the mandatory keys and show labels as a modal
        switch (keys[0]) {
            case 'workflow':
                for (const steps of clearObject[keys[0]]) {
                    stepIds = [...stepIds, ...this.wfeStepLoaderService.getListOfStepIdsByWorkflow(steps)];
                }
                for (const data of appStoreData) {
                    if (stepIds.includes(data.stepId)) {
                        emptyFieldIds.push(data.id);
                        if (data.mandatory && this.emptyUtil.isEmpty(data.value)) {
                            mandatoryArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(data.fieldLabel);
                            }
                        }
                        else {
                            mandatoryArr.push(true);
                        }
                    }
                }
                break;
            case 'block':
                blocks = await this.wfeStepLoaderService.loadWFEUniqueIdJSON().toPromise();
                blockKeys = [];
                for (const blockKey of clearObject[keys[0]]) {
                    blockKeys = [...blockKeys, ...this.getSessionKeyByBlock(blockKey, blocks)];
                }
                appStoreData.forEach(element => {
                    if (blockKeys.includes(element.id)) {
                        emptyFieldIds.push(element.id);
                        if (element.mandatory && this.emptyUtil.isEmpty(element.value)) {
                            mandatoryArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            mandatoryArr.push(true);
                        }
                    }
                });
                break;
            case 'step':
                stepIds = clearObject[keys[0]];
                for (const data of appStoreData) {
                    if (stepIds.includes(data.stepId)) {
                        emptyFieldIds.push(data.id);
                        if (data.mandatory && this.emptyUtil.isEmpty(data.value)) {
                            mandatoryArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(data.fieldLabel);
                            }
                        }
                        else {
                            mandatoryArr.push(true);
                        }
                    }
                }
                break;
            case 'section':
                blocks = await this.wfeStepLoaderService.loadWFEUniqueIdJSON().toPromise();
                blockKeys = [];
                for (const blockKey of clearObject[keys[0]]) {
                    blockKeys = [...blockKeys, ...this.getSessionKeyBySection(blockKey, blocks)];
                }
                appStoreData.forEach(element => {
                    if (blockKeys.includes(element.id)) {
                        emptyFieldIds.push(element.id);
                        if (element.mandatory && this.emptyUtil.isEmpty(element.value)) {
                            mandatoryArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            mandatoryArr.push(true);
                        }
                    }
                });
                break;
            case 'repeatable_block':
                appStoreData.forEach(element => {
                    if (clearObject[keys[0]].includes(element.repeatedBlockFieldId)) {
                        emptyFieldIds.push(element.id);
                        if (element.mandatory && this.emptyUtil.isEmpty(element.value)) {
                            mandatoryArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            mandatoryArr.push(true);
                        }
                    }
                });
                break;
            case 'field':
                appStoreData.forEach(element => {
                    if (clearObject[keys[0]].includes(element.id)) {
                        emptyFieldIds.push(element.id);
                        if (element.mandatory && this.emptyUtil.isEmpty(element.value)) {
                            mandatoryArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            mandatoryArr.push(true);
                        }
                    }
                });
                break;
            case 'api_key':
                appStoreData.forEach(element => {
                    if (clearObject[keys[0]].includes(element.apiKey)) {
                        emptyFieldIds.push(element.id);
                        if (element.mandatory && this.emptyUtil.isEmpty(element.value)) {
                            mandatoryArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            mandatoryArr.push(true);
                        }
                    }
                });
                break;
        }
        // console.log(emptyFieldIds, mandatoryArr);
        if (additionalParam.MandatoryCheck?.toLowerCase() === 'true') {
            this.sharedEventsServices.showMandatoryErrorMsg.emit({ fields: emptyFieldIds, type: 'event' });
        }
        const callBackData = handlerData.invoke_event_config.callback_config;
        if (mandatoryArr.includes(false)) {
            if (additionalParam['DisplayAsModal']) {
                const modalData = {
                    showMandateFields: true,
                    heading: additionalParam['DisplayAsModal'],
                    fields: fieldData
                };
                this.openAlert(modalData);
            }
            else {
                if (callBackData && callBackData.onFailure) {
                    this.triggerSuccessOrFailure(callBackData.onFailure, false);
                }
            }
        }
        else {
            if (callBackData && callBackData.OnSuccess) {
                this.triggerSuccessOrFailure(callBackData.OnSuccess);
            }
        }
    }
    async switchValidationCheckType(clearObject, handlerData) {
        const keys = Object.keys(clearObject);
        const additionalParam = this.getAdditionalParameter();
        const fieldData = [];
        let stepIds = [];
        let blockKeys = [];
        const invalidFieldIds = [];
        let blocks;
        const appStoreData = this.appDataService.getAllAppStoreData();
        const validArr = []; // only done because dcss requires to check all the valid keys and show labels as a modal
        switch (keys[0]) {
            case 'workflow':
                for (const steps of clearObject[keys[0]]) {
                    stepIds = [...stepIds, ...this.wfeStepLoaderService.getListOfStepIdsByWorkflow(steps)];
                }
                for (const data of appStoreData) {
                    if (stepIds.includes(data.stepId)) {
                        invalidFieldIds.push(data.id);
                        if (data.mandatory && (this.emptyUtil.isEmpty(data.value) || !data.isValid)) {
                            validArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(data.fieldLabel);
                            }
                        }
                        else {
                            validArr.push(true);
                        }
                    }
                }
                break;
            case 'block':
                blocks = await this.wfeStepLoaderService.loadWFEUniqueIdJSON().toPromise();
                blockKeys = [];
                for (const blockKey of clearObject[keys[0]]) {
                    blockKeys = [...blockKeys, ...this.getSessionKeyByBlock(blockKey, blocks)];
                }
                appStoreData.forEach(element => {
                    if (blockKeys.includes(element.id)) {
                        invalidFieldIds.push(element.id);
                        if (element.mandatory && (this.emptyUtil.isEmpty(element.value) || !element.isValid)) {
                            validArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            validArr.push(true);
                        }
                    }
                });
                break;
            case 'step':
                stepIds = clearObject[keys[0]];
                for (const data of appStoreData) {
                    if (stepIds.includes(data.stepId)) {
                        invalidFieldIds.push(data.id);
                        if (data.mandatory && (this.emptyUtil.isEmpty(data.value) || !data.isValid)) {
                            validArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(data.fieldLabel);
                            }
                        }
                        else {
                            validArr.push(true);
                        }
                    }
                }
                break;
            case 'section':
                blocks = await this.wfeStepLoaderService.loadWFEUniqueIdJSON().toPromise();
                blockKeys = [];
                for (const blockKey of clearObject[keys[0]]) {
                    blockKeys = [...blockKeys, ...this.getSessionKeyBySection(blockKey, blocks)];
                }
                appStoreData.forEach(element => {
                    if (blockKeys.includes(element.id)) {
                        invalidFieldIds.push(element.id);
                        if (element.mandatory && (this.emptyUtil.isEmpty(element.value) || !element.isValid)) {
                            validArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            validArr.push(true);
                        }
                    }
                });
                break;
            case 'repeatable_block':
                appStoreData.forEach(element => {
                    if (clearObject[keys[0]].includes(element.repeatedBlockFieldId)) {
                        invalidFieldIds.push(element.id);
                        if (element.mandatory && (this.emptyUtil.isEmpty(element.value) || !element.isValid)) {
                            validArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            validArr.push(true);
                        }
                    }
                });
                break;
            case 'field':
                appStoreData.forEach(element => {
                    if (clearObject[keys[0]].includes(element.id)) {
                        invalidFieldIds.push(element.id);
                        if (element.mandatory && (this.emptyUtil.isEmpty(element.value) || !element.isValid)) {
                            validArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            validArr.push(true);
                        }
                    }
                });
                break;
            case 'api_key':
                appStoreData.forEach(element => {
                    if (clearObject[keys[0]].includes(element.apiKey)) {
                        invalidFieldIds.push(element.id);
                        if (element.mandatory && (this.emptyUtil.isEmpty(element.value) || !element.isValid)) {
                            validArr.push(false);
                            if (additionalParam['ShowFieldLabels']) {
                                fieldData.push(element.fieldLabel);
                            }
                        }
                        else {
                            validArr.push(true);
                        }
                    }
                });
                break;
        }
        // console.log(invalidFieldIds, validArr);
        if (additionalParam.ValidationCheck.toLowerCase() === 'true') {
            this.sharedEventsServices.showValidationErrorMsg.emit({ fields: invalidFieldIds, type: 'event' });
        }
        const callBackData = handlerData.invoke_event_config.callback_config;
        if (validArr.includes(false)) {
            if (additionalParam['DisplayAsModal']) {
                const modalData = {
                    showMandateFields: true,
                    heading: additionalParam['DisplayAsModal'],
                    fields: fieldData
                };
                this.openAlert(modalData);
            }
            else {
                if (callBackData && callBackData.onFailure) {
                    this.triggerSuccessOrFailure(callBackData.onFailure, false);
                }
            }
        }
        else {
            if (callBackData && callBackData.OnSuccess) {
                this.triggerSuccessOrFailure(callBackData.OnSuccess);
            }
        }
    }
    switchCustomHandlerFunction(handler, variables, targets, primaryData) {
        const variableValues = {};
        const targetValues = [];
        // tslint:disable-next-line: no-unused-expression
        variables.length && (variables.forEach((element) => {
            this.appDataService.getIndividualAppData(element).subscribe(res => {
                if (res[0]) {
                    variableValues[res[0].id] = res[0].value;
                }
            });
        }));
        // tslint:disable-next-line: no-unused-expression
        targets.length && (targets.forEach((element) => {
            targetValues.push(element);
        }));
        const customEventVariableEmitterObject = {
            handler: handler.event_handler,
            variables: variableValues,
            targets: targetValues,
            primaryData: primaryData
        };
        const callBackData = handler.invoke_event_config?.callback_config;
        if (typeof this.inBuildFunctionsUtil[customEventVariableEmitterObject.handler] === "function") {
            const r = this.inBuildFunctionsUtil[customEventVariableEmitterObject.handler](customEventVariableEmitterObject);
            if (typeof r === 'object' && typeof r['then'] === "function") {
                r.then(ret => {
                    if (!ret) {
                        if (callBackData && callBackData.onFailure) {
                            this.triggerSuccessOrFailure(callBackData.onFailure);
                        }
                    }
                    else {
                        if (callBackData && callBackData.OnSuccess) {
                            this.triggerSuccessOrFailure(callBackData.OnSuccess);
                        }
                    }
                });
            }
            else if (typeof r === 'boolean') {
                if (!r) {
                    if (callBackData && (callBackData.onFailure)) {
                        this.triggerSuccessOrFailure(callBackData.onFailure);
                    }
                    else if (callBackData && callBackData.OnFailure) {
                        this.triggerSuccessOrFailure(callBackData.OnFailure);
                    }
                }
                else {
                    if (callBackData && callBackData.OnSuccess) {
                        this.triggerSuccessOrFailure(callBackData.OnSuccess);
                    }
                    else if (callBackData && callBackData.onSuccess) {
                        this.triggerSuccessOrFailure(callBackData.onSuccess);
                    }
                }
            }
        }
        else {
            this.sharedEventsServices.customEventVariableEmitter.emit(customEventVariableEmitterObject);
            if (callBackData && callBackData.OnSuccess) {
                this.triggerSuccessOrFailure(callBackData.OnSuccess);
            }
        }
    }
    switchCopyToClipboardType(object) {
        const keys = Object.keys(object);
        let copied_fields = [];
        switch (keys[0]) {
            case 'Fieldvalue':
                object[keys[0]].split('|').forEach(element => {
                    this.appDataService.getIndividualAppData(element.trim()).subscribe(res => {
                        copied_fields.push(res[0].value);
                    });
                });
                this.copyToClipboard(copied_fields.join(','));
                break;
            case 'URL':
                this.copyToClipboard(document.URL);
                break;
        }
    }
    copyToClipboard(val) {
        const selBox = document.createElement('textarea');
        selBox.style.position = 'fixed';
        selBox.style.left = '0';
        selBox.style.top = '0';
        selBox.style.opacity = '0';
        selBox.value = val;
        document.body.appendChild(selBox);
        selBox.focus();
        selBox.select();
        document.execCommand('copy');
        document.body.removeChild(selBox);
    }
    getSessionKeyByBlock(blockId, uniqueIdJSON) {
        let sessionKeys = [];
        const uniqueIds = [];
        for (const singleObject of uniqueIdJSON) {
            for (const blocksData of singleObject.data.blocks) {
                for (const singleBlock in blocksData) {
                    if (singleBlock === blockId) {
                        sessionKeys = [...sessionKeys, ...blocksData[singleBlock]];
                    }
                }
            }
        }
        for (const key of sessionKeys) {
            uniqueIds.push(this.sessionKeyUtil.getFieldNameFromSessionKey(key));
        }
        return [...new Set(uniqueIds)];
    }
    getSessionKeyBySteps(stepIds, uniqueIdJSON) {
        const uniqueIds = [];
        let sessionKeys = [];
        for (const obj of uniqueIdJSON) {
            if (stepIds.includes(obj.stepId)) {
                for (const sectionData of obj.data.sections) {
                    // tslint:disable-next-line: forin
                    for (const singleSection in sectionData) {
                        sessionKeys = [...sessionKeys, ...sectionData[singleSection]];
                    }
                }
                for (const blocksData of obj.data.blocks) {
                    // tslint:disable-next-line: forin
                    for (const singleBlock in blocksData) {
                        sessionKeys = [...sessionKeys, ...blocksData[singleBlock]];
                    }
                }
            }
        }
        for (const key of sessionKeys) {
            uniqueIds.push(this.sessionKeyUtil.getFieldNameFromSessionKey(key));
        }
        return [...new Set(uniqueIds)];
    }
    getSessionKeyBySection(sectionId, uniqueIdJSON) {
        const uniqueIds = [];
        let sessionKeys = [];
        for (const singleObject of uniqueIdJSON) {
            for (const sectionData of singleObject.data.sections) {
                for (const singleSection in sectionData) {
                    if (singleSection === sectionId) {
                        sessionKeys = [...sessionKeys, ...sectionData[singleSection]];
                    }
                }
            }
        }
        for (const key of sessionKeys) {
            uniqueIds.push(this.sessionKeyUtil.getFieldNameFromSessionKey(key));
        }
        return [...new Set(uniqueIds)];
    }
    // this is the additional parameter object that is in the root
    // of the invoke_event_config
    getAdditionalParameter() {
        const additionalParam = {};
        for (const param of this.additionalParameters) {
            additionalParam[param.parameter_type] = param.value;
        }
        return additionalParam;
    }
    // function that sets cell data of list or table
    setCellData(primaryData, handler) {
        this.cellAppData.stepId = primaryData.stepId;
        if (primaryData.type === 'table') {
            for (const field of primaryData.value.fields) {
                if (primaryData.value.data[field.unique_id] !== undefined && field.field_type !== "Menu") {
                    const obj = {};
                    obj.id = field.unique_id;
                    obj.value = primaryData.value.data[field.unique_id] || '';
                    // not using concatenation because child field within list does not support concatenation
                    obj.responseApiKey =
                        this.apiKeyUtil.getMultipleApiKeys(field.response_api_key);
                    obj.requestApiKey = this.apiKeyUtil.getMultipleApiKeys(field.request_api_key);
                    obj.apiKey = field.api_key;
                    this.appDataService.setAppData({ ...this.cellAppData, ...obj });
                }
            }
        }
        else {
            this.getListCellData(primaryData.value.fields);
        }
        if (handler.invoke_event_config) {
            const callBackData = handler.invoke_event_config.callback_config;
            if (callBackData && callBackData.OnSuccess) {
                this.triggerSuccessOrFailure(callBackData.OnSuccess);
            }
        }
    }
    // recursive function to find all the keys which has request response api key
    // and store the data in the akita store app data
    getListCellData(data) {
        for (const field of data) {
            if (field.child_fields && field.child_fields.length) {
                this.getListCellData(field.child_fields);
            }
            else {
                if (localStorage.getItem('singleApiKey') === 'true' ? field.api_key : (field.request_api_key || field.response_api_key) && field.field_type !== "Menu") {
                    const object = {};
                    object.id = field.unique_id;
                    object.value = field.rowData.value || '';
                    // not using concatenation because child field within list does not support concatenation
                    object.responseApiKey =
                        this.apiKeyUtil.getMultipleApiKeys(field.response_api_key);
                    object.requestApiKey = this.apiKeyUtil.getMultipleApiKeys(field.request_api_key);
                    object.apiKey = field.api_key;
                    this.appDataService.setAppData({ ...this.cellAppData, ...object });
                }
            }
        }
    }
    get hasUnsavedData() {
        return localStorage.getItem('has_unsaved_data') === 'true' ? true : false;
    }
    get modalOnPageLeave() {
        return localStorage.getItem('modal_on_page_leave') ? localStorage.getItem('modal_on_page_leave') : false;
    }
    get pageLeaveStepId() {
        return localStorage.getItem('page_leave_step_id') ? localStorage.getItem('page_leave_step_id') : false;
    }
    get pageLeaveHref() {
        return localStorage.getItem('page_leave_href') ? localStorage.getItem('page_leave_href') : false;
    }
    get pageLeaveHrefTarget() {
        return localStorage.getItem('page_leave_href_target') ? localStorage.getItem('page_leave_href_target') : '';
    }
    get getOnPageLeaveCheckType() {
        return localStorage.getItem('OnPageLeaveCheckType') ? localStorage.getItem('OnPageLeaveCheckType') : false;
    }
    redirectTo(stepId, ModalOnPageLeave = null, target = null) {
        if ((this.modalOnPageLeave || ModalOnPageLeave) && !(this.getOnPageLeaveCheckType === 'saved' && !this.hasUnsavedData)) {
            this.pageLeaveHref && localStorage.removeItem('page_leave_href');
            localStorage.setItem('page_leave_step_id', stepId);
            this.wfeStepLoaderService.loadStepById(ModalOnPageLeave ? ModalOnPageLeave : this.modalOnPageLeave).subscribe((data) => {
                if (data !== undefined && data.display_as_modal === 1) {
                    this.openDialog(data);
                }
            });
        }
        else {
            this.redirectionUtil.redirectTo(stepId, target);
        }
    }
    redirectToHref(link, ModalOnPageLeave = null, target = null) {
        const globalParameters = this.wfeStepLoaderService.additionalParameters;
        if (this.hasUnsavedData && (this.modalOnPageLeave || ModalOnPageLeave)) {
            this.pageLeaveStepId && localStorage.removeItem('page_leave_step_id');
            localStorage.setItem('page_leave_href', link);
            if (target) {
                localStorage.setItem('page_leave_href_target', target);
            }
            this.wfeStepLoaderService.loadStepById(ModalOnPageLeave ? ModalOnPageLeave : this.modalOnPageLeave).subscribe((data) => {
                if (data !== undefined && data.display_as_modal === 1) {
                    this.openDialog(data);
                }
            });
        }
        else if (globalParameters['externalSitePrompt'] && !this.pageLeaveHref) {
            this.pageLeaveStepId && localStorage.removeItem('page_leave_step_id');
            localStorage.setItem('page_leave_href', link);
            if (target) {
                localStorage.setItem('page_leave_href_target', target);
            }
            this.displayModal({ event_handler: globalParameters['externalSitePrompt'] });
        }
        else {
            if (target) {
                window.open(link, target);
            }
            else {
                window.location.href = link;
            }
        }
    }
    /**
     * function that emits the value of the field state event with the fields and the value
     * @param obj the type of the event can be block, section, field and the field ids
     * @param type the type of the state to be change like visibility, mandatory, editable
     */
    async fieldStateChangeEvent(obj, type, readDataFromModal) {
        const stateChangedObj = {
            type,
            ids: [],
            value: this.getAdditionalParameter()['FieldStateValue'].split('|').map(str => Number(str.trim()))
        };
        let uniqueIdJSON;
        switch (Object.keys(obj)[0]) {
            case 'field':
                stateChangedObj.ids = obj['field'];
                break;
            case 'step':
                const stepIds = obj['step'];
                const appStoreData = this.appDataService.getAllAppStoreData();
                for (const data of appStoreData) {
                    if (stepIds.includes(data.stepId)) {
                        stateChangedObj.ids.push(String(data.id));
                    }
                }
                break;
            case 'section':
                uniqueIdJSON = await this.wfeStepLoaderService.loadWFEUniqueIdJSON().toPromise();
                let stepId = readDataFromModal ? window['currentModalId'] : window['currentStepId'];
                uniqueIdJSON = uniqueIdJSON.filter(i => i.stepId === stepId);
                for (const sectionKey of obj['section']) {
                    stateChangedObj.ids = [...stateChangedObj.ids, ...this.getSessionKeyBySection(sectionKey, uniqueIdJSON)];
                }
                break;
            case 'block':
                uniqueIdJSON = await this.wfeStepLoaderService.loadWFEUniqueIdJSON().toPromise();
                for (const blockKey of obj['block']) {
                    stateChangedObj.ids = [...stateChangedObj.ids, ...this.getSessionKeyByBlock(blockKey, uniqueIdJSON)];
                }
                break;
        }
        // console.log(stateChangedObj);
        this.sharedEventsServices.emitFieldStateChangeEventEmitter.emit(stateChangedObj);
    }
    // set field values
    setValuesOnEvent(handler, primaryData = {}) {
        const additionalParams = this.getAdditionalParameter();
        const obj = {
            uniqueIds: [],
            apiKeys: [],
            values: [],
            triggerUpdate: additionalParams.TriggerOnUpdateEvent && additionalParams.TriggerOnUpdateEvent.toLowerCase() === 'false' ? true : false
        };
        if (!additionalParams['TargetFields'] || !additionalParams['ValueFields']) {
            return;
        }
        switch (handler.event_handler) {
            case 'single_static_value':
            case 'multi_static_value':
                obj['uniqueIds'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
                obj['values'] = additionalParams['ValueFields'].split('|').map(str => str.trim());
                //arithmetic operations
                for (let index = 0; index < obj['values'].length; index++) {
                    let v = obj['values'][index];
                    if (v.includes('%value%') && obj['uniqueIds'][index]) {
                        const tVal = this.appDataService.getFieldDataByFieldId(obj['uniqueIds'][index]);
                        v = v.replace(/%value%/, tVal);
                    }
                    if (v.includes('(calc)')) {
                        try {
                            v = eval(v.split('(calc)')[1]);
                        }
                        catch (error) {
                            console.error(error);
                        }
                    }
                    obj['values'][index] = v;
                }
                break;
            case 'single_field_value':
            case 'multi_field_value':
                let uniqueIds = additionalParams['TargetFields'].split('|').map(str => str.trim());
                let valueFields = additionalParams['ValueFields'];
                if (additionalParams['TargetFields'].includes('(dateCalc)')) {
                    obj['uniqueIds'] = [];
                    obj['values'] = [];
                    let values = additionalParams['ValueFields'].split('|').map(str => str.trim());
                    for (let index = 0; index < values.length; index++) {
                        let tVal = uniqueIds[index];
                        if (tVal.includes('(dateCalc)')) {
                            try {
                                tVal = tVal.split('(dateCalc)')[1];
                                var arrStr = tVal.split(/[%%]/);
                                obj['uniqueIds'].push(arrStr[1]);
                                const targetValue = new Date(this.appDataService.getFieldDataByFieldId(values[index]));
                                var calString = arrStr[2].trim();
                                if (calString && calString.length > 0) {
                                    let operator = calString[0];
                                    let unit = calString[calString.length - 1];
                                    let amount = Number(calString.replace(unit, '').replace(operator, '').trim());
                                    switch (unit) {
                                        case 'd':
                                            switch (operator) {
                                                case '+':
                                                    targetValue.setDate(targetValue.getDate() + amount);
                                                    break;
                                                case '-':
                                                    targetValue.setDate(targetValue.getDate() - amount);
                                                    break;
                                            }
                                            break;
                                        case 'm':
                                            switch (operator) {
                                                case '+':
                                                    targetValue.setMonth(targetValue.getMonth() + amount);
                                                    break;
                                                case '-':
                                                    targetValue.setMonth(targetValue.getMonth() - amount);
                                                    break;
                                            }
                                            break;
                                        case 'y':
                                            switch (operator) {
                                                case '+':
                                                    targetValue.setFullYear(targetValue.getFullYear() + amount);
                                                    break;
                                                case '-':
                                                    targetValue.setFullYear(targetValue.getFullYear() - amount);
                                                    break;
                                            }
                                            break;
                                    }
                                }
                                let finalDate = ((targetValue.getMonth() > 8) ? (targetValue.getMonth() + 1) : ('0' + (targetValue.getMonth() + 1))) + '/' + ((targetValue.getDate() > 9) ? targetValue.getDate() : ('0' + targetValue.getDate())) + '/' + targetValue.getFullYear();
                                obj['values'].push(finalDate);
                            }
                            catch (error) {
                                console.error(error);
                            }
                        }
                    }
                }
                else {
                    if (primaryData && primaryData.value && primaryData.value.isRepeatable && primaryData.stepId) {
                        valueFields = valueFields.split('|')
                            .map((targetField) => {
                            if (targetField.startsWith(primaryData.stepId))
                                return targetField;
                            ;
                            let targetId = primaryData.stepId + '$' + targetField;
                            if (primaryData.value.parentPosition != null && primaryData.value.parentPosition != undefined) {
                                targetId += '$' + primaryData.value.parentPosition;
                            }
                            if (primaryData.value.position != null || primaryData.value.position != undefined) {
                                targetId += '$' + primaryData.value.position;
                            }
                            return targetId;
                        }).join('|');
                    }
                    obj['uniqueIds'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
                    obj['values'] = this.appDataService.getFieldDataByFieldIds(valueFields, '|');
                }
                // console.log('obj', obj);
                break;
            case 'single_api_key_value':
            case 'multi_api_key_value':
                obj['apiKeys'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
                obj['values'] = this.apiDataService.getApiKeyValueByKeyString(additionalParams['ValueFields'], '|');
                break;
            case 'single_field_api_key_value':
            case 'multi_field_api_key_value':
                obj['uniqueIds'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
                if (this.isCheckboxValueAsArray()) {
                    obj['values'] = this.apiDataService.getAPIKeyValueByArray(additionalParams['ValueFields'], '|');
                }
                else {
                    obj['values'] = this.apiDataService.getApiKeyValueByKeyString(additionalParams['ValueFields'], '|');
                }
                break;
            case 'single_api_key_field_value':
            case 'multi_api_key_field_value':
                obj['apiKeys'] = additionalParams['TargetFields'].split('|').map(str => str.trim());
                obj['values'] = this.appDataService.getFieldDataByFieldIds(additionalParams['ValueFields'], '|');
                break;
            default:
                break;
        }
        let isWaitForDataSet = additionalParams['CEE_event_wait_for_data_set']?.toLowerCase() == 'true';
        if (isWaitForDataSet) {
            const subscription = this.sharedEventsServices.settingFieldValueEventFinished.subscribe(() => {
                subscription.unsubscribe();
                this.eventSetValueFinished(handler);
            });
            this.sharedEventsServices.emitSetFieldValueOnEvent.emit(obj);
        }
        else {
            this.sharedEventsServices.emitSetFieldValueOnEvent.emit(obj);
            setTimeout(() => {
                this.eventSetValueFinished(handler);
            }, 0);
        }
    }
    eventSetValueFinished(handler) {
        const callBackData = handler.invoke_event_config.callback_config;
        if (callBackData && callBackData.OnSuccess) {
            this.triggerSuccessOrFailure(callBackData.OnSuccess);
        }
    }
    isCheckboxValueAsArray() {
        const isCheckArray = this.additionalParameters ? this.additionalParameters.find(i => i.parameter_type == 'CheckAllCheckboxGroup') : [];
        if (isCheckArray && isCheckArray['value'] == 'true') {
            return true;
        }
        return false;
    }
    // set geo location
    getLocation(globalParameters, handler) {
        // if there are global parameters CEE_DeviceLatitude or CEE_DeviceLongitude
        // then get the location information
        if (globalParameters.CEE_DeviceLatitude ||
            globalParameters.CEE_DeviceLongitude) {
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition((position) => {
                    this.saveGeoLocation(globalParameters, position.coords.latitude, position.coords.longitude);
                    const callBackData = handler.invoke_event_config.callback_config;
                    if (callBackData && callBackData.OnSuccess) {
                        this.triggerSuccessOrFailure(callBackData.OnSuccess);
                    }
                }, error => {
                    this.saveGeoLocation(globalParameters, '', '');
                    // Display error based on the error code.
                    const { code } = error;
                    switch (code) {
                        case 3:
                            console.error('Error occurred while getting device location: Handle timeout.');
                            break;
                        case 1:
                            console.error('Error occurred while getting device location: User denied the request.');
                            break;
                        case 2:
                            console.error('Error occurred while getting device location: Position not available.');
                            break;
                    }
                });
            }
            else {
                console.error('Geolocation is not supported by this browser.');
            }
        }
        if (globalParameters.CEE_DeviceInfo) {
            if (navigator.userAgent) {
                let deviceInfoBox = {
                    browserAgent: navigator.userAgent,
                    currentBrowser: this.detectBrowser(),
                    currentOs: this.detectOperatingSystem(),
                    currentOsVersion: this.detectOperatingSystemVersion(),
                    currentDevice: this.detectDeviceType(),
                    browserLanguage: navigator.language,
                    browserTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };
                this.saveDeviceInfo(globalParameters, deviceInfoBox);
                const callBackData = handler.invoke_event_config.callback_config;
                if (callBackData && callBackData.OnSuccess) {
                    this.triggerSuccessOrFailure(callBackData.OnSuccess);
                }
            }
            else {
                this.saveDeviceInfo(globalParameters, {});
            }
        }
    }
    detectBrowser() {
        const userAgent = navigator.userAgent;
        if (userAgent.includes("Firefox")) {
            return "Mozilla Firefox";
        }
        else if (userAgent.includes("Chrome")) {
            return "Google Chrome";
        }
        else if (userAgent.includes("Safari")) {
            return "Apple Safari";
        }
        else if (userAgent.includes("Edge")) {
            return "Microsoft Edge";
        }
        else if (userAgent.includes("Opera") || userAgent.includes("OPR")) {
            return "Opera";
        }
        else if (userAgent.includes("Trident") || userAgent.includes("MSIE")) {
            return "Internet Explorer";
        }
        else {
            return "Unknown browser";
        }
    }
    detectOperatingSystem() {
        const userAgent = navigator.userAgent;
        if (/Win/i.test(userAgent)) {
            return "Windows";
        }
        else if (/Mac/i.test(userAgent)) {
            return "Mac OS";
        }
        else if (/Linux/i.test(userAgent)) {
            return "Linux";
        }
        else if (/iPhone|iPad|iPod/i.test(userAgent)) {
            return "iOS";
        }
        else if (/Android/i.test(userAgent)) {
            return "Android";
        }
        else {
            return "Unknown operating system";
        }
    }
    detectOperatingSystemVersion() {
        const userAgent = navigator.userAgent;
        if (/Win/i.test(userAgent)) {
            const windowsVersionRegex = /Windows NT (\d+\.\d+)/;
            const windowsVersionMatch = userAgent.match(windowsVersionRegex);
            if (windowsVersionMatch) {
                return "Windows " + windowsVersionMatch[1];
            }
        }
        else if (/Mac/i.test(userAgent)) {
            const macVersionRegex = /Mac OS X (\d+[\._]\d+(?:[\._]\d+)?)/;
            const macVersionMatch = userAgent.match(macVersionRegex);
            if (macVersionMatch) {
                return "Mac OS " + macVersionMatch[1].replace(/_/g, ".");
            }
        }
        else if (/Linux/i.test(userAgent)) {
            const linuxVersionRegex = /Linux (\d+\.\d+\.\d+)/;
            const linuxVersionMatch = userAgent.match(linuxVersionRegex);
            if (linuxVersionMatch) {
                return "Linux " + linuxVersionMatch[1];
            }
        }
        else if (/iPhone|iPad|iPod/i.test(userAgent)) {
            const iosVersionRegex = /OS (\d+_\d+(?:_\d+)?)/;
            const iosVersionMatch = userAgent.match(iosVersionRegex);
            if (iosVersionMatch) {
                return "iOS " + iosVersionMatch[1].replace(/_/g, ".");
            }
        }
        else if (/Android/i.test(userAgent)) {
            const androidVersionRegex = /Android (\d+\.\d+(?:\.\d+)?)/;
            const androidVersionMatch = userAgent.match(androidVersionRegex);
            if (androidVersionMatch) {
                return "Android " + androidVersionMatch[1];
            }
        }
        return "Unknown operating system version";
    }
    detectDeviceType() {
        const userAgent = navigator.userAgent;
        if (/Mobi/i.test(userAgent) || /Android/i.test(userAgent)) {
            return "Mobile";
        }
        else if (/iPad/i.test(userAgent) || /Tablet/i.test(userAgent)) {
            return "Tablet";
        }
        else {
            return "Desktop";
        }
    }
    saveDeviceInfo(globalParameters, browserAgent) {
        const browserAgentApiKey = globalParameters.CEE_DeviceInfo &&
            globalParameters.CEE_DeviceInfo.includes('$$') ?
            globalParameters.CEE_DeviceInfo.split('$$')[1] : globalParameters.CEE_DeviceInfo;
        this.saveData(browserAgentApiKey, '', browserAgent);
        this.emitData(browserAgentApiKey, browserAgent);
    }
    saveGeoLocation(globalParameters, latitude, longitude) {
        const latApiKey = globalParameters.CEE_DeviceLatitude &&
            globalParameters.CEE_DeviceLatitude.includes('$$') ?
            globalParameters.CEE_DeviceLatitude.split('$$')[1] : globalParameters.CEE_DeviceLatitude;
        const longApiKey = globalParameters.CEE_DeviceLongitude &&
            globalParameters.CEE_DeviceLongitude.includes('$$') ?
            globalParameters.CEE_DeviceLongitude.split('$$')[1] : globalParameters.CEE_DeviceLongitude;
        this.saveData(latApiKey, '', latitude);
        this.saveData(longApiKey, '', longitude);
        this.emitData(latApiKey, latitude);
        this.emitData(longApiKey, longitude);
    }
    emitData(response_api_key, data) {
        const obj = {};
        obj[response_api_key] = data;
        if (response_api_key.includes('##')) {
            obj['handler_name'] = response_api_key.split('##')[0];
        }
        this.sharedEventsServices.emitApiSuccessResponse.emit(obj);
    }
    //special event handler for context menu
    contextMenu(handler, primaryData) {
        const additionalParams = this.getAdditionalParameter();
        let contextArray = [additionalParams['TargetFields'].split('|').map(str => str.trim())[0], primaryData.x, primaryData.y];
        if (additionalParams['TargetFields']) {
            this.sharedEventsServices.contextMenuEmitter.emit(contextArray);
        }
    }
    extractEmailIds(event) {
        this.eventAdditionalParams = this.getAdditionalParameter();
        const sourceFieldName = this.eventAdditionalParams && this.eventAdditionalParams['CEE_EXTRACT_EMAIL_SOURCE_FIELD'] ? this.eventAdditionalParams['CEE_EXTRACT_EMAIL_SOURCE_FIELD'] : '';
        const extractEmailIdsStoreKey = this.eventAdditionalParams && this.eventAdditionalParams['CEE_EXTRACT_EMAIL_STORE_FIELD'] ? this.eventAdditionalParams['CEE_EXTRACT_EMAIL_STORE_FIELD'] : '';
        let sourceFieldValue;
        if (sourceFieldName) {
            sourceFieldValue = this.appDataService.getFieldDataByFieldId(sourceFieldName);
        }
        let extractedEmailIds = '';
        if (sourceFieldValue) {
            //regex to match emails inside data-id attribute
            const dataIdRegex = /data-id="([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6})"/g;
            let matchArray;
            const matchedEmails = [];
            // Collect all matches
            while ((matchArray = dataIdRegex.exec(sourceFieldValue)) !== null) {
                matchedEmails.push(matchArray[1]); // Group 1 contains just the email
            }
            if (matchedEmails.length > 0) {
                const uniqueEmails = [...new Set(matchedEmails)];
                extractedEmailIds = uniqueEmails.join(",");
            }
        }
        if (extractEmailIdsStoreKey) {
            this.appDataService.getIndividualAppData(extractEmailIdsStoreKey).pipe(take(1)).subscribe(fieldData => {
                if (fieldData.length > 0) {
                    let changeValue = {
                        ...fieldData[0],
                        value: extractedEmailIds
                    };
                    this.appDataService.updateAppData(changeValue);
                }
            });
        }
    }
    cleanUpMaterialFields(combinedContainer) {
        // Remove datepicker-related elements
        combinedContainer.querySelectorAll('[mat-datepicker-input],mat-datepicker-input,shadow-dateInput').forEach(el => {
            // console.log('Removing element:', el);
            el.remove();
        });
        combinedContainer.querySelectorAll('.mat-mdc-form-field-icon-suffix').forEach(el => {
            // console.log('Removing element:', el);
            el.remove();
        });
        combinedContainer.querySelectorAll('input.mat-datepicker-input').forEach(input => {
            input.remove();
        });
        combinedContainer.querySelectorAll('mat-icon[aria-label="close date picker"]').forEach(el => el.remove());
        // Remove error message elements
        combinedContainer.querySelectorAll('div.error-message-validation').forEach(div => div.remove());
        // Set background color for text field wrappers
        combinedContainer.querySelectorAll('.mat-mdc-text-field-wrapper').forEach(wrapper => {
            wrapper.style.background = 'white';
        });
    }
    // Helper function to show the loader
    showLoader(message = 'Processing your download...') {
        // Create loader if it doesn't exist
        if (!document.getElementById('download-loader')) {
            const loader = document.createElement('div');
            loader.id = 'download-loader';
            loader.className = 'loader-overlay';
            loader.innerHTML = `
                <div class="loader-spinner">
                    <div class="spinner"></div>
                    <p>${message}</p>
                </div>
                `;
            document.body.appendChild(loader);
            // Add styles if needed
            const style = document.createElement('style');
            style.textContent = `
                .loader-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                }
                .loader-spinner {
                    background-color: white;
                    padding: 20px;
                    border-radius: 5px;
                    text-align: center;
                }
                .spinner {
                    border: 4px solid #f3f3f3;
                    border-top: 4px solid #3498db;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    animation: spin 2s linear infinite;
                    margin: 0 auto 10px;
                }
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
                `;
            document.head.appendChild(style);
        }
        else {
            // Update message if loader already exists
            const messageElement = document.querySelector('#download-loader .loader-spinner p');
            if (messageElement) {
                messageElement.textContent = message;
            }
        }
        // Show the loader
        document.getElementById('download-loader').style.display = 'flex';
    }
    // Helper function to hide the loader
    hideLoader() {
        const loader = document.getElementById('download-loader');
        if (loader) {
            loader.style.display = 'none';
        }
    }
    static ɵfac = function WFEEventListHandler_Factory(t) { return new (t || WFEEventListHandler)(i0.ɵɵinject(CeeApiService), i0.ɵɵinject(i11.Router), i0.ɵɵinject(SharedEventsServiceService), i0.ɵɵinject(CEEInternalEmitterService), i0.ɵɵinject(WfeStepLoaderService), i0.ɵɵinject(AppDataService), i0.ɵɵinject(ApiDataService), i0.ɵɵinject(i7$1.MatDialog), i0.ɵɵinject(i8.MatSnackBar), i0.ɵɵinject(i9.HttpClient), i0.ɵɵinject(FileUploadService)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WFEEventListHandler, factory: WFEEventListHandler.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WFEEventListHandler, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: CeeApiService }, { type: i11.Router }, { type: SharedEventsServiceService }, { type: CEEInternalEmitterService }, { type: WfeStepLoaderService }, { type: AppDataService }, { type: ApiDataService }, { type: i7$1.MatDialog }, { type: i8.MatSnackBar }, { type: i9.HttpClient }, { type: FileUploadService }], null); })();
function boldFormatingOnSomeForms(combinedContainer) {
    const downpayment = combinedContainer.querySelectorAll('.downpayment');
    //  console.log("downpayment", downpayment);
    downpayment.forEach((el) => {
        if (el.textContent.toLowerCase().includes('total')) {
            el.style.color = '#333';
            el.style.letterSpacing = '1';
            el.style.fontWeight = 'bold';
            //el.style.margin = '16px 0';
            el.style.fontFamily = 'Quicksand';
        }
    });
    const forminvestorlenderdi = combinedContainer.querySelectorAll('.forminvestorlenderdi');
    //  console.log("forminvestorlenderdi", forminvestorlenderdi);
    forminvestorlenderdi.forEach((el) => {
        // if (el.textContent.toLowerCase().includes('total')) {
        el.style.color = '#000';
        el.style.letterSpacing = '1';
        el.style.fontWeight = 'bold';
        //el.style.margin = '16px 0';
        el.style.fontFamily = 'Quicksand';
        // }
    });
    const downpaymentvalue = combinedContainer.querySelectorAll('.comp-558905.downpayment');
    // console.log("downpayment", downpaymentvalue);
    downpaymentvalue.forEach((el) => {
        // if (el.textContent.toLowerCase().includes('total')) {
        el.style.color = '#333';
        el.style.letterSpacing = '1';
        el.style.fontWeight = 'bold';
        //el.style.margin = '16px 0';
        el.style.fontFamily = 'Quicksand';
        // }
    });
    // cf-label-border-top comp-129398 fees ng-star-inserted
    const totalFees = combinedContainer.querySelectorAll('.cf-label-border-top.comp-129398.fees.ng-star-inserted');
    //    console.log("downpayment", downpaymentvalue);
    totalFees.forEach((el) => {
        // if (el.textContent.toLowerCase().includes('total')) {
        el.style.color = '#333';
        el.style.letterSpacing = '1';
        el.style.fontWeight = 'bold';
        //el.style.margin = '16px 0';
        el.style.fontFamily = 'Quicksand';
        // }
    });
    // class="amortizationschedule cf-border-top comp-537946 ng-star-inserted"
    const amortizationschedule = combinedContainer.querySelectorAll('.cf-border-top,.comp-151851120759569.ng-star-inserted,.comp-238698.findersfeedisclosure,.comp-876320.findersfeedisclosure,.comp-054542.findersfeedisclosure,.comp-077658.findersfeedisclosure,.comp-852414.findersfeedisclosure,.comp-029222.findersfeedisclosure,.comp-401941.findersfeedisclosure,.comp-735575.themortgagorsacknowl');
    //    console.log("downpayment", downpaymentvalue);
    amortizationschedule.forEach((el) => {
        // if (el.textContent.toLowerCase().includes('total')) {
        el.style.color = '#333';
        el.style.letterSpacing = '1';
        el.style.fontWeight = 'bold';
        //el.style.margin = '16px 0';
        el.style.fontFamily = 'Quicksand';
    });
}
function tableHeadersElements(combinedContainer) {
    // const tableHeaders = combinedContainer.querySelectorAll('th.mat-mdc-header-cell.mat-sort-header');
    // // const tableHeaders = combinedContainer.querySelectorAll('mat-mdc-table thead tr th');
    // // console.log("tableHeaders--",tableHeaders);
    // tableHeaders.forEach((header: HTMLElement) => {
    //     // Set background color and text color
    //     header.style.backgroundColor = '#656772';
    //     header.style.color = '#ffffff'; // White text
    //     // Calculate and set dynamic font size based on content length
    //     const content = header.textContent || '';
    //     const contentLength = content.trim().length;
    //     // Dynamic font size calculation - smaller font for longer text
    //     let fontSize = '14px'; // Default size
    //     if (contentLength > 20) {
    //         fontSize = '12px';
    //     }
    //     if (contentLength > 30) {
    //         fontSize = '11px';
    //     }
    //     if (contentLength > 40) {
    //         fontSize = '10px';
    //     }
    //     // header.style.fontSize = fontSize;
    //     // header.style.fontWeight = 'bold';
    //     // header.style.padding = '8px 4px'; // Add adequate padding
    //     // header.style.whiteSpace = 'normal'; // Allow text wrapping
    //     // header.style.wordBreak = 'break-word'; // Break long words if needed
    //     // header.style.lineHeight = '1.2'; // Tighter line height for wrapped text
    //     // header.style.maxHeight = 'none'; // Remove any height restrictions
    //     // header.style.overflow = 'visible'; // Ensure text is not cut off
    //     // ✅ New: Center-align text horizontally and vertically
    //     header.style.textAlign = 'center'; // Horizontal center
    //     header.style.verticalAlign = 'middle'; // Vertical center
    //     const innerTextDiv = header.querySelector('.width_clear');
    //     if (innerTextDiv) {
    //         const innerElem = innerTextDiv as HTMLElement;
    //         // innerElem.style.fontFamily = 'Arial, sans-serif';  // Or your preferred font
    //         innerElem.style.fontSize = '12px'; //fontSize;
    //         innerElem.style.fontWeight = 'bold';
    //         innerElem.style.color = '#ffffff';
    //         innerElem.style.textAlign = 'left';
    //         innerElem.style.verticalAlign = 'middle';
    //         // innerElem.style.whiteSpace = 'normal';
    //         // innerElem.style.overflow = 'visible';
    //         innerElem.style.whiteSpace = 'nowrap'; // Prevent new lines
    //         innerElem.style.overflow = 'hidden';
    //         innerElem.style.textOverflow = 'ellipsis'; // Add ellipsis if text overflows
    //     }
    // });
    const headers = combinedContainer.querySelectorAll('th.mat-mdc-header-cell.mat-sort-header');
    headers.forEach((header) => {
        header.style.backgroundColor = '#656772';
        header.style.color = '#ffffff';
        header.style.textAlign = 'center';
        header.style.verticalAlign = 'middle';
        header.style.fontSize = '13px';
        header.style.fontWeight = 'bold';
        header.style.padding = '8px 4px';
        header.style.whiteSpace = 'nowrap'; // Prevent wrapping
        header.style.overflow = 'visible'; // Ensure full text
        // header.style.position = 'static';   // Remove sticky if present
        // Optionally, don't set height unless you must:
        // header.style.height = '28px'; // Or whatever is appropriate
        header.style.tableLayout = 'auto';
        // Also style any direct inner content if needed
        const innerDiv = header.querySelector('.width_clear');
        if (innerDiv) {
            innerDiv.style.fontSize = '12px';
            innerDiv.style.fontWeight = 'bold';
            innerDiv.style.color = '#ffffff';
            innerDiv.style.whiteSpace = 'nowrap';
        }
    });
    // cf-label-bold comp-177164 liabilitiescombined ng-star-inserted
    const innerTextDiv = combinedContainer.querySelectorAll('.liabilitiescombined.ng-star-inserted');
    innerTextDiv.forEach((innerElem) => {
        // const innerElem = innerTextDiv as HTMLElement;
        // innerElem.style.fontFamily = 'Arial, sans-serif';  // Or your preferred font
        innerElem.style.fontSize = '14px'; // fontSize;
        // innerElem.style.fontWeight = 'bold';
        // innerElem.style.color = '#ffffff';
        // innerElem.style.textAlign = 'center';
        // innerElem.style.padding = '4px 4px'; // Add adequate padding
        // innerElem.style.whiteSpace = 'normal'; // Allow text wrapping
        innerElem.style.wordBreak = 'break-word'; // Break long words if needed
        innerElem.style.lineHeight = '1.2'; // Tighter line height for wrapped text
        // innerElem.style.maxHeight = 'none'; // Remove any height restrictions
        innerElem.style.overflow = 'visible';
    });
}

const _c0$2 = a0 => ({ "show-menu": a0 });
const _c1$2 = a0 => ({ "rotate-caret": a0 });
function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_a_1_Template(rf, ctx) { if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 10);
    i0.ɵɵlistener("click", function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_a_1_Template_a_click_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(2); const item_r3 = ctx_r1.$implicit; const i_r4 = ctx_r1.index; const ctx_r4 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r4.ddToggle(item_r3, i_r4)); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r3 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵclassMapInterpolate2("", item_r3.menuclass, " ", item_r3.menu ? "active" : "", "");
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(item_r3.linkText);
} }
function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r6 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 10);
    i0.ɵɵlistener("click", function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_a_2_Template_a_click_0_listener() { i0.ɵɵrestoreView(_r6); const ctx_r1 = i0.ɵɵnextContext(2); const item_r3 = ctx_r1.$implicit; const i_r4 = ctx_r1.index; const ctx_r4 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r4.ddToggle(item_r3, i_r4)); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r3 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵclassMapInterpolate2("", item_r3.menuclass, " ", item_r3.menu ? "active" : "", "");
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(item_r3.linkText);
} }
function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 11);
    i0.ɵɵlistener("click", function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_div_3_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r7); const ctx_r1 = i0.ɵɵnextContext(2); const item_r3 = ctx_r1.$implicit; const i_r4 = ctx_r1.index; const ctx_r4 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r4.ddToggle(item_r3, i_r4)); });
    i0.ɵɵtext(1, "\u25BC");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r3 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(1, _c1$2, item_r3.menu));
} }
function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_app_sidemenu_bar_renderer_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "app-sidemenu-bar-renderer", 12);
} if (rf & 2) {
    const item_r3 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("sidemenuBlockElements", item_r3.submenu)("sidemenuBlock", ctx_r4.sidemenuBlock)("currentStep", ctx_r4.currentStep);
} }
function SidemenuBarRendererComponent_div_1_ng_container_1_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtemplate(1, SidemenuBarRendererComponent_div_1_ng_container_1_div_1_a_1_Template, 2, 5, "a", 6)(2, SidemenuBarRendererComponent_div_1_ng_container_1_div_1_a_2_Template, 2, 5, "a", 6)(3, SidemenuBarRendererComponent_div_1_ng_container_1_div_1_div_3_Template, 2, 3, "div", 7);
    i0.ɵɵelementStart(4, "div", 8);
    i0.ɵɵtemplate(5, SidemenuBarRendererComponent_div_1_ng_container_1_div_1_app_sidemenu_bar_renderer_5_Template, 1, 3, "app-sidemenu-bar-renderer", 9);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const item_r3 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", item_r3.submenu.length);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !item_r3.submenu.length);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", item_r3.submenu.length);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(5, _c0$2, item_r3.menu));
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", item_r3.menu && item_r3.submenu && item_r3.submenu.length > 0);
} }
function SidemenuBarRendererComponent_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, SidemenuBarRendererComponent_div_1_ng_container_1_div_1_Template, 6, 7, "div", 4);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r3 = ctx.$implicit;
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", item_r3.isVisible);
} }
function SidemenuBarRendererComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 2);
    i0.ɵɵtemplate(1, SidemenuBarRendererComponent_div_1_ng_container_1_Template, 2, 1, "ng-container", 3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r4.sidemenuBlockElements)("ngForTrackBy", ctx_r4.trackByIdsideBar);
} }
class SidemenuBarRendererComponent {
    router;
    appDataService;
    apiDataService;
    eventListHandler;
    sharedEventsService;
    renderer;
    sidemenuBlock;
    sidemenuBlockElements = [];
    currentStep;
    currentStepName = "";
    expandAll = false;
    redirectionUtil;
    constructor(router, appDataService, apiDataService, eventListHandler, sharedEventsService, renderer) {
        this.router = router;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.eventListHandler = eventListHandler;
        this.sharedEventsService = sharedEventsService;
        this.renderer = renderer;
        // thhs may solve the issue of eventListHandler being singleton (make it public first)
        // eventListHandler.sharedEventsServices = sharedEventsService;
    }
    ngOnInit() {
        this.sharedEventsService.sideMenuSelectionResetEmitter.subscribe(() => {
            sessionStorage.removeItem("menuState_id");
            this.restoreMenuState();
        });
    }
    ngOnChanges() {
        this.restoreMenuState();
    }
    restoreMenuState() {
        const savedMenuState = JSON.parse(sessionStorage.getItem("menuState_id") || "null");
        if (savedMenuState) {
            // console.log('savedMenuState', savedMenuState);
            var preselectedMenuId = "";
            this.sidemenuBlockElements.forEach((item) => {
                item.submenu?.forEach((submenuItem) => {
                    if (item.menu && submenuItem.menu) {
                        preselectedMenuId = submenuItem._id.toString();
                    }
                    submenuItem.menu = false;
                });
                item.menu = false;
            });
            this.sidemenuBlockElements.forEach((item, index) => {
                item.submenu?.forEach((submenuItem, subindex) => {
                    if (savedMenuState.menuitem._id === submenuItem._id) {
                        item.menu = true;
                        submenuItem.menu = true;
                    }
                });
                if (savedMenuState.menuitem._id === item._id) {
                    item.menu = true;
                }
            });
        }
    }
    trackByIdsideBar(index, item) {
        return item._id;
    }
    // notify step redirection, if this is actual page navigation
    notifyStepRedirection(route) {
        const currentUrlWithoutFragment = this.router.url.split('#')[0];
        var targetUrlWithoutFragment = route.split('#')[0];
        if (currentUrlWithoutFragment.startsWith('/') && !targetUrlWithoutFragment.startsWith('/')) {
            targetUrlWithoutFragment = '/' + targetUrlWithoutFragment;
        }
        // Only emit for actual page changes, not hash navigation
        if (currentUrlWithoutFragment !== targetUrlWithoutFragment) {
            this.sharedEventsService.targetStepRedirection.emit({
                event_handler: "overRideWorkflow"
            });
        }
    }
    ddToggle(item, index) {
        if (!item)
            return;
        if (item.attachtoStep == '') {
            item.menu = !item.menu;
            return;
        }
        if (item.attachtoStep == this.currentStep) {
            item.menu = !item.menu;
            return;
        }
        if (this.currentStepName && item.attachtoStep == this.currentStepName.replace(/\s+/g, '-')) {
            item.menu = !item.menu;
            return;
        }
        this.sidemenuBlockElements.forEach((otherItem, i) => {
            otherItem.menu = i === index;
        });
        sessionStorage.setItem("menuState_id", JSON.stringify({ menuitem: item }));
        item.menu = true;
        if (item.attachtoStep) {
            let route = this.resolveRoute(item.attachtoStep, index);
            this.notifyStepRedirection(route);
            this.eventListHandler.redirectToHref(route, null, "");
        }
        this.scrollToSection(item, index);
    }
    resolveRoute(route, index) {
        let stepObj = route.split("#");
        if (stepObj.length === 2) {
            stepObj[0] = this.replaceApiKeys(stepObj[0]);
            stepObj[1] = stepObj[1].replace("{{i}}", String(index));
        }
        return stepObj.join("#");
    }
    replaceApiKeys(sentence) {
        return sentence.replace(/%(.*?)%/g, (_, key) => {
            return this.appDataService.getFieldDataByFieldId(key) || key;
        });
    }
    scrollToSection(item, i) {
        if (item.attchedmenuClass) {
            const menuElement = document.querySelector("." + item.attchedmenuClass);
            if (menuElement) {
                const errorField = this.renderer.selectRootElement("." + item.attchedmenuClass, true);
                if (errorField) {
                    errorField.scrollIntoView({
                        behavior: "smooth",
                        block: "center",
                        inline: "nearest",
                    });
                }
            }
            else {
                let attachtoStepParts = item.attachtoStep.split("#");
                if (attachtoStepParts.length > 1) {
                    let part = attachtoStepParts[1];
                    if (part && part.indexOf("{{i}}") !== -1) {
                        part = part.replace("{{i}}", i - 1);
                        const errorField = this.renderer.selectRootElement("." + part, true);
                        if (errorField) {
                            errorField.scrollIntoView({
                                behavior: "smooth",
                                block: "center",
                                inline: "nearest",
                            });
                        }
                    }
                }
            }
        }
    }
    toggleAll() {
        this.expandAll = !this.expandAll;
        this.sidemenuBlock.submenu?.forEach((submenu) => {
            submenu.menu = this.expandAll;
        });
    }
    ngAfterViewInit() {
        const stepObj = this.router.url.split("#");
        if (stepObj.length > 1) {
            setTimeout(() => {
                this.scrollToSection({ attchedmenuClass: stepObj[1] }, 1);
            }, 5000);
        }
    }
    static ɵfac = function SidemenuBarRendererComponent_Factory(t) { return new (t || SidemenuBarRendererComponent)(i0.ɵɵdirectiveInject(i11.Router), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(WFEEventListHandler), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(i0.Renderer2)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SidemenuBarRendererComponent, selectors: [["app-sidemenu-bar-renderer"]], inputs: { sidemenuBlock: "sidemenuBlock", sidemenuBlockElements: "sidemenuBlockElements", currentStep: "currentStep", currentStepName: "currentStepName" }, standalone: true, features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature], decls: 2, vars: 1, consts: [[1, "dynamic-sidebar"], ["class", "wrapper element-shadow", 4, "ngIf"], [1, "wrapper", "element-shadow"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "group", 4, "ngIf"], [1, "group"], [3, "class", "click", 4, "ngIf"], ["class", "caret", 3, "ngClass", "click", 4, "ngIf"], [1, "sub-menu", 3, "ngClass"], [3, "sidemenuBlockElements", "sidemenuBlock", "currentStep", 4, "ngIf"], [3, "click"], [1, "caret", 3, "click", "ngClass"], [3, "sidemenuBlockElements", "sidemenuBlock", "currentStep"]], template: function SidemenuBarRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementStart(0, "div", 0);
            i0.ɵɵtemplate(1, SidemenuBarRendererComponent_div_1_Template, 2, 2, "div", 1);
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.sidemenuBlockElements && ctx.sidemenuBlockElements.length > 0);
        } }, dependencies: [SidemenuBarRendererComponent, MatTreeModule, MatIconModule, CommonModule, i13.NgClass, i13.NgForOf, i13.NgIf], styles: [".dynamic-sidebar{font: 13px sans-serif;box-sizing:border-box;position:relative}.dynamic-sidebar .expand-all{font-size:12px;text-align:right;display:block;margin-bottom:5px;margin-right:15px;cursor:pointer}.dynamic-sidebar .wrapper .group{overflow:hidden;position:relative}.dynamic-sidebar .wrapper .group>a{color:#fff;padding:7px 0 6px 20px;display:block;cursor:pointer;background-color:#03658c;text-decoration:none;border-bottom:1px solid #fff}.dynamic-sidebar .wrapper .group .caret{position:absolute;transition:transform ease-out .2s;top:15px;right:10px;color:#fff;font-size:10px;transform:translateY(-50%) rotate(-90deg)}.dynamic-sidebar .wrapper .sub-menu{transition:max-height .2s;max-height:0}.dynamic-sidebar .wrapper .sub-menu ul{margin:0;padding:0}.dynamic-sidebar .wrapper .sub-menu li{list-style-type:none;background-color:#313b3f;font: 10pt sans-serif;line-height:19px;letter-spacing:.1pt}.dynamic-sidebar .wrapper .sub-menu li a{color:#fff;padding:7px 0 6px 20px;text-decoration:none;cursor:pointer;display:block}.dynamic-sidebar .wrapper .sub-menu li:hover{background-color:#03658c;color:#fff}.rotate-caret{transform:translateY(-50%) rotate(0)!important}.show-menu{max-height:1000px!important}@media screen and (max-width: 768px){.dynamic-sidebar{margin-top:10px}}\n"], encapsulation: 2 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SidemenuBarRendererComponent, [{
        type: Component,
        args: [{ selector: "app-sidemenu-bar-renderer", standalone: true, encapsulation: ViewEncapsulation.None, imports: [MatTreeModule, MatIconModule, NgTemplateOutlet, CommonModule], template: "<div class=\"dynamic-sidebar\">\r\n        <!-- <span class=\"expand-all\" (click)=\"toggleAll()\">{{\r\n          !expandAll ? 'Expand All' : 'Close All'\r\n        }}</span> -->\r\n        <div *ngIf=\"sidemenuBlockElements && sidemenuBlockElements.length > 0\" class=\"wrapper element-shadow\">\r\n            <ng-container *ngFor=\"let item of sidemenuBlockElements; let i = index; trackBy: trackByIdsideBar;\">\r\n                <div class=\"group\"*ngIf=\"item.isVisible\">\r\n                    <a *ngIf=\"item.submenu.length\" (click)=\"ddToggle(item, i)\" class=\"{{item.menuclass}} {{item.menu ? 'active' : ''}}\">{{ item.linkText }}</a>\r\n                    <a *ngIf=\"!item.submenu.length\" (click)=\"ddToggle(item, i)\" class=\"{{item.menuclass}} {{item.menu ? 'active' : ''}}\">{{ item.linkText }}</a>\r\n                    <div *ngIf=\"item.submenu.length\" (click)=\"ddToggle(item, i)\" class=\"caret\" [ngClass]=\"{ 'rotate-caret': item.menu }\">&#9660;</div>\r\n                    <div class=\"sub-menu\" [ngClass]=\"{ 'show-menu': item.menu }\">\r\n                      <app-sidemenu-bar-renderer *ngIf=\"item.menu && item.submenu && item.submenu.length > 0\" [sidemenuBlockElements]=\"item.submenu\" [sidemenuBlock]=\"sidemenuBlock\"\r\n                    [currentStep]=\"currentStep\"></app-sidemenu-bar-renderer>\r\n                    </div>\r\n                </div>\r\n            </ng-container>\r\n        </div>\r\n</div>", styles: [".dynamic-sidebar{font: 13px sans-serif;box-sizing:border-box;position:relative}.dynamic-sidebar .expand-all{font-size:12px;text-align:right;display:block;margin-bottom:5px;margin-right:15px;cursor:pointer}.dynamic-sidebar .wrapper .group{overflow:hidden;position:relative}.dynamic-sidebar .wrapper .group>a{color:#fff;padding:7px 0 6px 20px;display:block;cursor:pointer;background-color:#03658c;text-decoration:none;border-bottom:1px solid #fff}.dynamic-sidebar .wrapper .group .caret{position:absolute;transition:transform ease-out .2s;top:15px;right:10px;color:#fff;font-size:10px;transform:translateY(-50%) rotate(-90deg)}.dynamic-sidebar .wrapper .sub-menu{transition:max-height .2s;max-height:0}.dynamic-sidebar .wrapper .sub-menu ul{margin:0;padding:0}.dynamic-sidebar .wrapper .sub-menu li{list-style-type:none;background-color:#313b3f;font: 10pt sans-serif;line-height:19px;letter-spacing:.1pt}.dynamic-sidebar .wrapper .sub-menu li a{color:#fff;padding:7px 0 6px 20px;text-decoration:none;cursor:pointer;display:block}.dynamic-sidebar .wrapper .sub-menu li:hover{background-color:#03658c;color:#fff}.rotate-caret{transform:translateY(-50%) rotate(0)!important}.show-menu{max-height:1000px!important}@media screen and (max-width: 768px){.dynamic-sidebar{margin-top:10px}}\n"] }]
    }], () => [{ type: i11.Router }, { type: AppDataService }, { type: ApiDataService }, { type: WFEEventListHandler }, { type: SharedEventsServiceService }, { type: i0.Renderer2 }], { sidemenuBlock: [{
            type: Input
        }], sidemenuBlockElements: [{
            type: Input
        }], currentStep: [{
            type: Input
        }], currentStepName: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(SidemenuBarRendererComponent, { className: "SidemenuBarRendererComponent", filePath: "lib\\components\\sidemenu-bar-renderer\\sidemenu-bar-renderer.component.ts", lineNumber: 26 }); })();

const _c0$1 = ["printableContainer"];
const _c1$1 = ["*"];
class ContentProjectionWrapperComponent {
    elementRef;
    sharedEventsServices;
    wfeEventListHandler;
    http;
    renderer;
    eventAdditionalParams = [];
    additionalParameters = [];
    event = {}; // for file service call
    destroy$ = new Subject();
    sectionData;
    // @Input() title?: string;
    showHeader = true;
    showFooter = true;
    /* @Input() showBefore: boolean = false;
    @Input() showAfter: boolean = false;
    @Input() showSidebar: boolean = true;
    @Input() showActions: boolean = true; */
    isolateStyles = true; // Option to isolate styles similar to Shadow DOM
    fonts = [];
    logoBase64 = '';
    loadedStylesheets = [];
    mutationObserver;
    contentProjectionOptions = {
        showHeader: false,
        showBefore: false,
        showAfter: false,
        showSidebar: false,
        showFooter: false,
        showActions: false,
        wrapperClass: '',
        isolateStyles: true,
        logoPath: '',
        fontPath: '',
        stylesheetPath: '',
        headerElementId: ''
    };
    generatePdfSubscription;
    //headerElementId: string = "2_45094"
    pdfStyles = '';
    printableContainer;
    pdfFileName = 'document.pdf';
    constructor(elementRef, sharedEventsServices, wfeEventListHandler, http, renderer) {
        this.elementRef = elementRef;
        this.sharedEventsServices = sharedEventsServices;
        this.wfeEventListHandler = wfeEventListHandler;
        this.http = http;
        this.renderer = renderer;
        this.generatePdfSubscription = this.sharedEventsServices.generatePdfUsingShadowDom
            .pipe(takeUntil(this.destroy$))
            .subscribe((data) => {
            // Handle the emitted data here
            if (data && data.additionalParameters) {
                this.eventAdditionalParams = data.additionalParameters;
            }
            if (data && data.pdfFileName) {
                this.pdfFileName = data.pdfFileName;
            }
            if (data && data.event) {
                this.event = data.event;
            }
            this.action('download');
        });
    }
    ngAfterViewInit() {
    }
    prepareAdditionalParams() {
        if (this.sectionData.additional_parameters && this.sectionData.additional_parameters.length > 0) {
            for (const parameter of this.sectionData.additional_parameters) {
                this.additionalParameters[parameter.parameter_type] = parameter.value;
                this.processParameter(parameter);
            }
        }
    }
    processParameter(parameter) {
        switch (parameter.parameter_type) {
            case 'CEE_ShowHeader':
                this.contentProjectionOptions.showHeader = parameter.value === 'true';
                break;
            case 'CEE_ShowBefore':
                this.contentProjectionOptions.showBefore = parameter.value === 'true';
                break;
            case 'CEE_ShowAfter':
                this.contentProjectionOptions.showAfter = parameter.value === 'true';
                break;
            case 'CEE_ShowSidebar':
                this.contentProjectionOptions.showSidebar = parameter.value === 'true';
                break;
            case 'CEE_ShowFooter':
                this.contentProjectionOptions.showFooter = parameter.value === 'true';
                break;
            case 'CEE_ShowActions':
                this.contentProjectionOptions.showActions = parameter.value === 'true';
                break;
            case 'CEE_WrapperClass':
                this.contentProjectionOptions.wrapperClass = parameter.value;
                break;
            case 'CEE_IsolateStyles':
                this.contentProjectionOptions.isolateStyles = parameter.value === 'true';
                break;
            case 'CEE_LogoPath':
                this.contentProjectionOptions.logoPath = parameter.value;
                break;
            case 'CEE_FontPath':
                this.contentProjectionOptions.fontPath = parameter.value;
                break;
            case 'CEE_Stylesheets':
                this.contentProjectionOptions.stylesheetPath = parameter.value;
                break;
            case 'CEE_HeaderSectionId':
                this.contentProjectionOptions.headerElementId = parameter.value;
                break;
            default:
                break;
        }
    }
    loadExternalStyles(stylesheetPath) {
        try {
            return this.http.get(stylesheetPath, { responseType: 'text' });
        }
        catch (error) {
            // console.error('Error in loadExternalStyles method:', error);
            throw error; // Re-throw to be handled by the subscriber
        }
    }
    ngOnInit() {
        // Prepare additional parameters
        this.prepareAdditionalParams();
        // First remove unwanted styles
        this.removeStyleTags();
        this.setupStyleMonitoring();
        // Then load the intentional stylesheet
        setTimeout(() => {
            if (this.contentProjectionOptions.stylesheetPath !== "") {
                //this.loadExternalStylesheet(this.contentProjectionOptions.stylesheetPath);
                this.loadExternalStyles(this.contentProjectionOptions.stylesheetPath).subscribe({
                    next: (response) => {
                        this.pdfStyles = response;
                        const shadowRoot = this.elementRef.nativeElement.shadowRoot;
                        if (!shadowRoot) {
                            console.warn('Shadow DOM not available for loading stylesheet');
                            return;
                        }
                        // Find the head element inside the shadow DOM
                        let headElement = shadowRoot.querySelector('head');
                        // If head doesn't exist, create it
                        if (!headElement) {
                            headElement = this.renderer.createElement('head');
                            const htmlElement = shadowRoot.querySelector('html');
                            if (htmlElement) {
                                this.renderer.insertBefore(htmlElement, headElement, htmlElement.firstChild);
                            }
                            else {
                                // If no html element, append to shadow root
                                this.renderer.appendChild(shadowRoot, headElement);
                            }
                        }
                        // Handle successful loading of external styles
                        const styleElement = this.renderer.createElement('style');
                        styleElement.setAttribute('data-pdf-only', 'true');
                        styleElement.innerHTML = response;
                        // Append to the head element instead of shadow root
                        this.renderer.appendChild(headElement, styleElement);
                        this.loadedStylesheets.push(styleElement);
                    },
                    error: (error) => {
                        console.error('Error loading external styles:', error);
                    }
                });
            }
        }, 0);
        // Convert and compress the logo image if a path is provided
        /* if (this.contentProjectionOptions.logoPath !== "") {
            //Convert and compress the logo image to base64
            this.convertAndCompressImage(this.contentProjectionOptions.logoPath, 140, 50, 0.7).then((compressedLogo) => {
                this.logoBase64 = compressedLogo;
            });
        } */
        if (this.contentProjectionOptions.fontPath !== "") {
            // Load Fonts
            try {
                this.loadFonts(this.contentProjectionOptions.fontPath)
                    .pipe(takeUntil(this.destroy$))
                    .subscribe({
                    next: (response) => {
                        this.fonts = response;
                    },
                    error: (error) => {
                        console.error('Error loading fonts:', error);
                        this.fonts = []; // Fallback to empty array
                    }
                });
            }
            catch (error) {
                console.error('Error initializing font loading:', error);
                this.fonts = [];
            }
        }
    }
    ngOnDestroy() {
        // Emit destroy signal to complete all subscriptions
        this.destroy$.next();
        this.destroy$.complete();
        // Clean up dynamically loaded stylesheets
        this.loadedStylesheets.forEach(stylesheet => {
            if (stylesheet.parentNode) {
                this.renderer.removeChild(stylesheet.parentNode, stylesheet);
            }
        });
        this.loadedStylesheets = [];
        if (this.generatePdfSubscription) {
            this.generatePdfSubscription.unsubscribe();
        }
    }
    loadFonts(fontPath) {
        try {
            return this.http.get(fontPath);
        }
        catch (error) {
            console.error('Error in loadFonts method:', error);
            throw error; // Re-throw to be handled by the subscriber
        }
    }
    action(actionType) {
        // const fileName = this.getFileName();
        const shadowRoot = this.elementRef.nativeElement.shadowRoot;
        if (!shadowRoot) {
            console.warn('Template reference is not available for PDF generation.');
            return;
        }
        this.generateAdvancedSearchablePDF(shadowRoot, this.pdfFileName, actionType);
    }
    createPDFDocument() {
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4',
            putOnlyUsedFonts: false,
            floatPrecision: 16,
            compress: true
        });
        // doc.setProperties({
        //     title: 'Invoice',
        //     author: 'Your Company Name',
        //     subject: 'Invoice Document',
        //     keywords: 'invoice, pdf, jsPDF'
        // });
        if (this.fonts.length > 0) {
            this.loadFontsForPDF(doc);
        }
        return doc;
    }
    handlePDFAction(doc, actionType, fileName) {
        const printUpload = this.eventAdditionalParams['CEE_PRINT_UPLOAD'] === "true";
        fileName = fileName.includes('.pdf') ? fileName : `${fileName}.pdf`;
        //    setTimeout(() => {
        //        this.openHtmlPreview();
        //        const blob1 = doc.output('blob');
        //        const url1 = URL.createObjectURL(blob1);
        //        window.open(url1, '_blank');
        //        URL.revokeObjectURL(url1);
        //    }, 300);
        //     return;
        doc.save(fileName, { returnPromise: true })
            .then(() => {
            if (printUpload) {
                let success, failure;
                if (this.event.invoke_event_config) {
                    success = this.event.invoke_event_config.callback_config.OnSuccess ||
                        this.event.invoke_event_config.callback_config.onResponse;
                    failure = this.event.invoke_event_config.callback_config.onFailure ||
                        this.event.invoke_event_config.callback_config.onException;
                }
                const blobObj = doc.output('blob');
                blobObj.name = `${fileName}`; // set ilename in blob
                //self.printUpload(blobObj,`${fileName}`, success, failure);
                const res = {
                    blob: blobObj,
                    fileName: `${fileName}`,
                    success: success,
                    failure: failure
                };
                this.sharedEventsServices.printUploadUsingShadowDom.emit(res);
            }
            else {
                // console.log('PDF downloaded successfully');
            }
        });
        // switch (actionType) {
        //     case 'download':
        //         doc.save(fileName, { returnPromise: true }).then(() => {
        //             console.log('PDF downloaded successfully');
        //         });
        //         break;
        //     case 'print':
        //         doc.autoPrint();
        //         const blob = doc.output('blob');
        //         const url = URL.createObjectURL(blob);
        //         window.open(url, '_blank');
        //         URL.revokeObjectURL(url);
        //         break;
        //     case 'preview':
        //         const blob1 = doc.output('blob');
        //         const url1 = URL.createObjectURL(blob1);
        //         window.open(url1, '_blank');
        //         URL.revokeObjectURL(url1);
        //         break;
        //     default:
        //         console.warn('Unknown action type:', actionType);
        // }
    }
    loadFontsForPDF(doc) {
        try {
            this.fonts.forEach(font => {
                try {
                    doc.addFileToVFS(font.name, font.base64);
                    doc.addFont(font.name, font.family, font.type);
                    doc.setFont(font.family, font.type);
                }
                catch (fontError) {
                    console.error(`Error adding font ${font.name}:`, fontError);
                    // Continue with other fonts even if one fails
                }
            });
        }
        catch (error) {
            console.error('Error loading fonts for PDF:', error);
            // PDF generation can continue without custom fonts
        }
    }
    /**
     * Prepare content for PDF by copying form values to visible elements
     */
    prepareContentForPDF(shadowRoot) {
        // Create a temporary container
        const tempContainer = document.createElement('div');
        tempContainer.innerHTML = shadowRoot.innerHTML;
        // Process all form elements in the cloned content
        this.processFormElements(tempContainer, shadowRoot);
        // Apply app-view-renderer page break logic
        // this.handleAppViewRendererPageBreaks(tempContainer);
        // Remove all global style references from the cloned content
        //this.cleanClonedContent(tempContainer);
        this.cleanDatePickerElements(tempContainer);
        return tempContainer;
    }
    /**
     * Handle page breaks for app-view-renderer elements to prevent content cutting
     */
    handleAppViewRendererPageBreaks(container) {
        try {
            const appViewRenderers = container.querySelectorAll('app-view-renderer');
            if (appViewRenderers.length === 0) {
                // console.log('No app-view-renderer elements found');
                return;
            }
            // console.log(`Processing ${appViewRenderers.length} app-view-renderer elements for page breaks`);
            // A4 page dimensions at 96 DPI (standard web resolution)
            const pageHeightPx = 1122; // A4 height in pixels at 96 DPI
            const marginTop = 60; // Top margin in pixels
            const marginBottom = 40; // Bottom margin in pixels
            const availablePageHeight = pageHeightPx - marginTop - marginBottom;
            let currentY = 0;
            let pageNumber = 1;
            appViewRenderers.forEach((renderer, index) => {
                const rendererElement = renderer;
                // Get the estimated height of the app-view-renderer
                const rendererHeight = this.estimateElementHeight(rendererElement);
                // console.log(`App-view-renderer ${index + 1}: Height=${rendererHeight}px, CurrentY=${currentY}px`);
                // Check if this renderer would exceed the current page
                if (currentY + rendererHeight > availablePageHeight && currentY > 0) {
                    // console.log(`App-view-renderer ${index + 1} would exceed page ${pageNumber}, forcing page break`);
                    // Force a page break before this renderer
                    this.forcePageBreakBefore(rendererElement);
                    // Reset position for new page
                    currentY = rendererHeight;
                    pageNumber++;
                }
                else {
                    // Element fits on current page
                    currentY += rendererHeight;
                }
                // Apply enhanced page break styles to ensure content stays together
                this.applyPageBreakStyles(rendererElement);
            });
            // console.log(`Processed app-view-renderer elements across ${pageNumber} pages`);
        }
        catch (error) {
            // console.error('Error handling app-view-renderer page breaks:', error);
        }
    }
    /**
     * Estimate the height of an element including all its children
     */
    estimateElementHeight(element) {
        try {
            // Create a temporary clone to measure
            const clone = element.cloneNode(true);
            // Apply styles that will help with measurement
            clone.style.position = 'absolute';
            clone.style.left = '-9999px';
            clone.style.top = '0';
            clone.style.width = '800px'; // Standard PDF content width
            clone.style.visibility = 'hidden';
            clone.style.display = 'block';
            // Append to document body for measurement
            document.body.appendChild(clone);
            // Get the height
            const height = clone.offsetHeight;
            // Clean up
            document.body.removeChild(clone);
            // Add some padding for safety (20% buffer)
            const estimatedHeight = Math.ceil(height * 1.2);
            // Minimum height to ensure page break logic works
            return Math.max(estimatedHeight, 100);
        }
        catch (error) {
            console.warn('Could not estimate element height, using default:', error);
            return 150; // Default fallback height
        }
    }
    /**
     * Force a page break before an element
     */
    forcePageBreakBefore(element) {
        // Create a page break div
        const pageBreakDiv = document.createElement('div');
        pageBreakDiv.className = 'pdf-page-break-before';
        pageBreakDiv.style.cssText = `
            page-break-before: always !important;
            break-before: page !important;
            display: block !important;
            height: 1px !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            background: transparent !important;
            clear: both !important;
        `;
        // Insert the page break div before the element
        if (element.parentNode) {
            element.parentNode.insertBefore(pageBreakDiv, element);
        }
    }
    /**
     * Apply comprehensive page break styles to an app-view-renderer element
     */
    applyPageBreakStyles(element) {
        // Apply page break styles to the main element
        element.style.cssText += `
            page-break-inside: avoid !important;
            break-inside: avoid !important;
            -webkit-column-break-inside: avoid !important;
            -moz-column-break-inside: avoid !important;
            display: block !important;
            overflow: visible !important;
            margin-bottom: 5px !important;
            //min-height: 20px !important;
        `;
        // .form-field,
        // Apply page break styles to child form elements
        const formElements = element.querySelectorAll(`
            .form-group,
            .field-container,
            .input-group,
            .mat-form-field,
            .mat-mdc-form-field,
            .radio-group,
            .checkbox-group,
            .select-container,
            .textarea-container,
            .date-picker-container
        `);
        formElements.forEach(formEl => {
            const formElement = formEl;
            formElement.style.cssText += `
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                -moz-column-break-inside: avoid !important;
                margin-bottom: 10px !important;
            `;
        });
        // Handle labels to stay with their inputs
        // const labels = element.querySelectorAll('label, .form-label, .field-label');
        // labels.forEach(label => {
        //     const labelElement = label as HTMLElement;
        //     labelElement.style.cssText += `
        //         page-break-after: avoid !important;
        //         break-after: avoid !important;
        //         -webkit-column-break-after: avoid !important;
        //         -moz-column-break-after: avoid !important;
        //     `;
        // });
        // Handle nested app-view-renderer elements
        // const nestedRenderers = element.querySelectorAll('app-view-renderer');
        // nestedRenderers.forEach(nested => {
        //     const nestedElement = nested as HTMLElement;
        //     nestedElement.style.cssText += `
        //         page-break-inside: avoid !important;
        //         break-inside: avoid !important;
        //         margin-bottom: 10px !important;
        //         display: block !important;
        //     `;
        // });
        // Handle Bootstrap grid elements within app-view-renderer
        // const gridElements = element.querySelectorAll('.row, .col, .col-auto, [class*="col-"]');
        const gridElements = element.querySelectorAll('.row, .col, .col-12, col-md-12, .col-sm-12, .col-lg-12, .col-xl-12, .col-xxl-12');
        gridElements.forEach(grid => {
            const gridElement = grid;
            gridElement.style.cssText += `
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            `;
        });
    }
    cleanDatePickerElements(container) {
        // Remove ALL date picker related elements
        const datePickerElements = container.querySelectorAll(`
        mat-datepicker-toggle,
        mat-icon,
        .mat-datepicker-toggle,
        .mat-icon,
        .mat-mdc-form-field-icon-suffix,
        button[mat-icon-button],
        svg,
        .mdc-icon-button,
        [matdatepickertoggle],
        .shadow-dateInput
    `);
        datePickerElements.forEach(element => {
            element.remove();
        });
    }
    /**
     * Clean cloned content of global style references
     */
    cleanClonedContent(container) {
        // Remove all style and link elements
        const stylesAndLinks = container.querySelectorAll('style, link[rel="stylesheet"]');
        stylesAndLinks.forEach(element => {
            if (!element.hasAttribute('data-pdf-only')) {
                element.remove();
            }
        });
        // Remove style attributes and problematic classes from all elements
        const allElements = container.querySelectorAll('*');
        allElements.forEach(element => {
            // Remove inline styles
            element.removeAttribute('style');
            // Remove Angular attributes
            Array.from(element.attributes).forEach(attr => {
                if (attr.name.includes('_ngcontent') ||
                    attr.name.includes('_nghost') ||
                    attr.name.startsWith('ng-')) {
                    element.removeAttribute(attr.name);
                }
            });
            // Remove problematic CSS classes
            const classList = Array.from(element.classList);
            classList.forEach(className => {
                if (this.isProblematicClass(className)) {
                    element.classList.remove(className);
                }
            });
        });
    }
    /**
     * Enhance cloned document for better form element rendering and remove ALL global styles
     */
    enhanceClonedDocument(clonedDoc) {
        const style = clonedDoc.createElement('style');
        style.setAttribute('data-pdf-only', 'true');
        style.textContent = this.pdfStyles.concat(`
        
            /* Hide ALL Material Date Picker Components */
            .mat-mdc-form-field-icon-suffix,
            .mat-datepicker-toggle,
            .mat-datepicker-toggle-default-icon,
            .mat-mdc-form-field-flex .mat-mdc-form-field-icon-suffix,
            mat-datepicker-toggle,
            mat-datepicker-toggle *,
            mat-icon[matdatetimepickertoggleicon],
            mat-icon[matdatetoggleicon],
            mat-icon,
            button[mat-icon-button],
            .mat-icon,
            .mat-datepicker-toggle-default-icon,
            [matdatepickertoggle],
            [mat-datepicker-toggle],
            .mdc-icon-button,
            svg[data-mat-icon-name],
            .mat-mdc-icon-button {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                width: 0 !important;
                height: 0 !important;
                overflow: hidden !important;
            }

            /* Hide shadow date input elements */
            .shadow-dateInput {
                display: none !important;
            }

            /* Material form field adjustments */
            mat-form-field,
            .mat-mdc-form-field {
                .mat-mdc-text-field-wrapper {
                    .mat-mdc-form-field-flex {
                        .mat-mdc-form-field-icon-suffix {
                            display: none !important;
                        }

                        .mat-mdc-form-field-infix {
                            width: 100% !important;
                            padding-right: 0 !important;
                        }
                    }
                }
            }

            /* Remove any SVG icons */
            svg {
                display: none !important;
            }

            /* Hide any button elements within form fields */
            mat-form-field button,
            .mat-mdc-form-field button {
                display: none !important;
            }

            /* Style for PDF converted input divs */
            .pdf-converted-input {
                background-color: white !important;
                background: white !important;
                color: #000 !important;
                border: none !important;
                border-bottom: 2px solid #ffffff !important;
                font-family: "Quicksand", sans-serif !important;
                font-weight: 700 !important;
                padding: 10px 0 !important;
                margin: 0 0 15px 0 !important;
                width: 100% !important;
                display: block !important;
                min-height: 20px !important;
                word-wrap: break-word !important;
                white-space: normal !important;
            }

            /* Ensure date inputs are visible and properly styled */
            input[type="date"],
            input[type="datetime-local"],
            input[type="time"] {
                background-color: white !important;
                background: white !important;
                color: #000 !important;
                border: none !important;
                border-bottom: 2px solid #ffffff !important;
                font-family: "Quicksand", sans-serif !important;
                font-weight: 700 !important;
                padding: 10px 0 !important;
                margin: 0 0 15px 0 !important;
                width: 100% !important;
            }

            /* Additional targeting for Angular Material components */
            .mat-form-field-suffix,
            .mat-form-field-suffix *,
            .mat-datepicker-toggle-container,
            .mat-datepicker-toggle-container * {
                display: none !important;
                visibility: hidden !important;
            }`);
        clonedDoc.head.appendChild(style);
    }
    /**
     * Remove ALL styles from the cloned document
     */
    removeAllStylesFromDocument(doc) {
        // console.log(doc)
        // Remove style elements that don't have data-pdf-only attribute
        const styles = doc.querySelectorAll('style:not([data-pdf-only])');
        styles.forEach(style => style.remove());
        // Remove link elements with stylesheets that don't have data-pdf-only attribute
        // const links = doc.querySelectorAll('link[rel="stylesheet"]:not([data-pdf-only]), link[rel="preload"][as="style"]:not([data-pdf-only])');
        // links.forEach(link => link.remove());
        // console.log("links to remove", links);
        // Remove style attributes from ALL elements
        // const allElements = doc.querySelectorAll('*');
        // allElements.forEach(element => {
        //     element.removeAttribute('style');
        //     // Remove Angular attributes
        //     Array.from(element.attributes).forEach(attr => {
        //         if (attr.name.includes('_ngcontent') ||
        //             attr.name.includes('_nghost') ||
        //             attr.name.startsWith('ng-')) {
        //             element.removeAttribute(attr.name);
        //         }
        //     });
        //     // Remove problematic CSS classes
        //     const classList = Array.from(element.classList);
        //     classList.forEach(className => {
        //         if (this.isProblematicClass(className)) {
        //             element.classList.remove(className);
        //         }
        //     });
        // });
        // Remove any remaining CSS imports or external references
        // const head = doc.head;
        // if (head) {
        //     const metaStyles = head.querySelectorAll('meta, base');
        //     metaStyles.forEach(meta => {
        //         const httpEquiv = meta.getAttribute('http-equiv');
        //         if (httpEquiv && httpEquiv.toLowerCase() === 'content-style-type') {
        //             meta.remove();
        //         }
        //     });
        // }
    }
    /**
 * Check if a CSS class is problematic for PDF generation
 */
    isProblematicClass(className) {
        const problematicPrefixes = [
            'mat-', 'md-', 'mdc-',
            'bootstrap-', 'btn-', 'form-',
            'container', 'row', 'col-',
            'd-', 'p-', 'm-', 'text-',
            'ng-', 'cdk-',
            'fa-', 'fas-', 'far-',
            'ui-', 'ant-', 'el-' // Other UI frameworks
        ];
        return problematicPrefixes.some(prefix => className.startsWith(prefix));
    }
    /**
     * Process form elements to make their values visible in PDF
     */
    processFormElements(clonedContainer, originalShadowRoot) {
        // Process input elements
        const originalInputs = originalShadowRoot.querySelectorAll('input');
        const clonedInputs = clonedContainer.querySelectorAll('input');
        originalInputs.forEach((originalInput, index) => {
            const clonedInput = clonedInputs[index];
            if (clonedInput) {
                this.processInputElement(originalInput, clonedInput);
            }
        });
        // Process textarea elements
        const originalTextareas = originalShadowRoot.querySelectorAll('textarea');
        const clonedTextareas = clonedContainer.querySelectorAll('textarea');
        originalTextareas.forEach((originalTextarea, index) => {
            const clonedTextarea = clonedTextareas[index];
            if (clonedTextarea) {
                this.processTextareaElement(originalTextarea, clonedTextarea);
            }
        });
        // Process select elements
        const originalSelects = originalShadowRoot.querySelectorAll('select');
        const clonedSelects = clonedContainer.querySelectorAll('select');
        originalSelects.forEach((originalSelect, index) => {
            const clonedSelect = clonedSelects[index];
            if (clonedSelect) {
                this.processSelectElement(originalSelect, clonedSelect);
            }
        });
    }
    /**
     * Process individual input elements - Replace with div while keeping classes
     */
    processInputElement(originalInput, clonedInput) {
        const inputType = originalInput.type.toLowerCase();
        switch (inputType) {
            case 'text':
            case 'email':
            case 'password':
            case 'number':
            case 'tel':
            case 'url':
            case 'search':
                // Replace input with div while preserving classes and value
                this.replaceInputWithDiv(clonedInput, originalInput.value, originalInput);
                break;
            case 'checkbox':
            case 'radio':
                if (originalInput.checked) {
                    this.replaceWithVisualIndicator(clonedInput, true, inputType);
                }
                else {
                    this.replaceWithVisualIndicator(clonedInput, false, inputType);
                }
                break;
            case 'date':
            case 'datetime-local':
            case 'time':
                // Replace date inputs with div while preserving classes
                if (originalInput.value) {
                    this.replaceInputWithDiv(clonedInput, originalInput.value, originalInput);
                }
                else {
                    this.replaceInputWithDiv(clonedInput, '', originalInput);
                }
                break;
            case 'hidden':
                // Keep hidden inputs hidden
                break;
            default:
                // Replace all other input types with div
                this.replaceInputWithDiv(clonedInput, originalInput.value, originalInput);
                break;
        }
    }
    /**
     * Process textarea elements
     */
    processTextareaElement(originalTextarea, clonedTextarea) {
        clonedTextarea.textContent = originalTextarea.value;
        clonedTextarea.style.color = '#000';
        clonedTextarea.style.backgroundColor = '#ffffff';
        // Alternatively, replace with a div to ensure text is visible
        if (originalTextarea.value) {
            this.replaceWithTextDiv(clonedTextarea, originalTextarea.value);
        }
    }
    /**
     * Process select elements
     */
    processSelectElement(originalSelect, clonedSelect) {
        // Copy the selected state
        Array.from(originalSelect.options).forEach((originalOption, index) => {
            const clonedOption = clonedSelect.options[index];
            if (clonedOption) {
                clonedOption.selected = originalOption.selected;
            }
        });
        // Replace with visible text
        const selectedText = originalSelect.selectedOptions.length > 0
            ? Array.from(originalSelect.selectedOptions).map(option => option.text).join(', ')
            : '';
        if (selectedText) {
            this.replaceWithTextSpan(clonedSelect, selectedText);
        }
    }
    replaceWithVisualIndicator(element, isChecked, inputType) {
        const span = document.createElement('span');
        span.classList.add("pdf-dynamic-visual-indicator");
        // Apply common styles
        Object.assign(span.style, {
            backgroundColor: '#ffffff',
            // color: '#000',
            display: 'inline-block',
            fontWeight: 'bold',
            width: '11px',
            height: '11px',
            border: '2px solid #2b2b2bff',
            marginRight: '4px',
            marginTop: '2px',
            flexShrink: '0 !important',
        });
        if (inputType === 'radio') {
            span.style.borderRadius = '50%';
        }
        if (isChecked) {
            // span.style.outline = '1px solid #054d85';
            span.style.border = '2px solid #054d85';
            span.style.backgroundColor = '#0078d4';
        }
        element.parentNode?.replaceChild(span, element);
    }
    /**
     * Replace input element with div while preserving classes and attributes
     */
    replaceInputWithDiv(inputElement, text, originalInput) {
        const div = document.createElement('div');
        // Copy all classes from the original input
        if (originalInput.className) {
            div.className = originalInput.className;
        }
        // Copy relevant attributes (excluding form-specific ones)
        const attributesToCopy = ['id', 'data-*', 'aria-*', 'role'];
        Array.from(originalInput.attributes).forEach(attr => {
            if (attributesToCopy.some(pattern => pattern.endsWith('*') ? attr.name.startsWith(pattern.slice(0, -1)) : attr.name === pattern)) {
                div.setAttribute(attr.name, attr.value);
            }
        });
        // Set the text content
        div.textContent = text ? text : '--';
        // Add a class to identify PDF-converted elements
        div.classList.add('pdf-converted-input');
        // Apply basic styling to maintain visual consistency
        const computedStyle = window.getComputedStyle(originalInput);
        Object.assign(div.style, {
            padding: computedStyle.padding || '8px',
            backgroundColor: '#ffffff',
            color: '#000',
            fontSize: computedStyle.fontSize || 'inherit',
            fontFamily: computedStyle.fontFamily || 'inherit',
            fontWeight: computedStyle.fontWeight || 'normal',
            border: 'none',
            borderBottom: '2px solid #ffffff',
            // minHeight: computedStyle.height || 'auto',
            width: computedStyle.width || 'auto',
            display: 'block',
            marginBottom: '15px',
            borderRadius: '0 !important'
        });
        // Replace the input element with the div
        if (inputElement.parentNode) {
            inputElement.parentNode.replaceChild(div, inputElement);
        }
    }
    /**
     * Replace form element with text span
     */
    replaceWithTextSpan(element, text) {
        const span = document.createElement('span');
        span.classList.add("pdf-dynamic-span");
        const computedStyle = window.getComputedStyle(element);
        span.textContent = text;
        Object.assign(span.style, {
            padding: '4px 8px',
            border: '1px solid #ffffffff',
            // borderRadius: '4px',
            backgroundColor: '#ffffffff',
            color: '#000',
            fontSize: computedStyle.fontSize,
            fontFamily: computedStyle.fontFamily,
            display: 'inline-block',
            minWidth: '100px'
        });
        element.parentNode?.replaceChild(span, element);
    }
    /**
     * Replace textarea with div
     */
    replaceWithTextDiv(element, text) {
        const div = document.createElement('div');
        const computedStyle = window.getComputedStyle(element);
        div.classList.add("pdf-dynamic-text-div");
        div.textContent = text ? text : '--';
        Object.assign(div.style, {
            padding: '8px',
            // border: '1px solid #ccc',
            // borderRadius: '4px',
            // backgroundColor: '#f9f9f9',
            color: '#000',
            fontSize: computedStyle.fontSize,
            fontFamily: computedStyle.fontFamily,
            // minHeight: element.offsetHeight + 'px',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-word',
            fontWeight: 700,
            borderBottom: '2px solid #ffffff'
        });
        element.parentNode?.replaceChild(div, element);
    }
    /**
     * Generate PDF with advanced searchable header using headerElementId
     */
    generateAdvancedSearchablePDF(shadowRoot, fileName, actionType) {
        // Get header and main content elements
        // Use CSS.escape for IDs that start with numbers or contain special characters
        const escapedId = CSS.escape(this.contentProjectionOptions.headerElementId);
        const headerElement = document.querySelector(`#${escapedId}`);
        const mainContent = this.prepareContentForPDF(shadowRoot);
        if (!headerElement) {
            console.warn(`Header element with ID '${this.contentProjectionOptions.headerElementId}' not found.`);
            return;
        }
        this.generateAdvancedPDF(headerElement, mainContent, fileName);
    }
    /**
     * Generate PDF with advanced searchable header functionality
     */
    async generateAdvancedPDF(headerElement, mainContent, fileName) {
        try {
            const doc = this.createPDFDocument();
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const marginTop = 45;
            const marginBottom = 20;
            const marginLeft = 15;
            const marginRight = 10;
            const headerLineGap = 3; // Gap between header Line and header and content
            // Extract advanced header content
            const headerContent = this.extractAdvancedHeaderContent(headerElement);
            // Process header images
            const processedImages = await this.processHeaderImages(headerContent.images);
            // Function to add advanced searchable header to each page
            const addAdvancedSearchableHeader = (pageNum, totalPages) => {
                // Header background
                doc.setFillColor(255, 255, 255);
                doc.rect(0, 0, pageWidth, 30, 'F');
                // Header border
                doc.setLineWidth(0.5);
                doc.setDrawColor(225, 228, 228);
                doc.line(0, (marginTop - headerLineGap), pageWidth, (marginTop - headerLineGap));
                // Add images on the left side
                let imageXPosition = marginLeft;
                let imageYPosition = 8;
                processedImages.forEach((img, index) => {
                    if (img.data) {
                        doc.addImage(img.data, 'PNG', imageXPosition - 5, imageYPosition, 35, 15);
                        imageXPosition += 40; // Space between images
                    }
                    // Add invisible searchable alt text for accessibility
                    if (img.alt) {
                        doc.setFontSize(1);
                        doc.setTextColor(255, 255, 255); // White text (invisible)
                        doc.text(img.alt, imageXPosition - 35, 2);
                        doc.setTextColor(0, 0, 0); // Reset to black
                    }
                });
                // Calculate text starting position (after images)
                const textStartX = imageXPosition + 10; // 10mm space after last image
                const maxTextWidth = pageWidth - textStartX - marginRight;
                // Add searchable text elements on the right side (right-aligned)
                let yPosition = 10;
                headerContent.textElements.forEach((textEl, index) => {
                    const fontSize = index === 0 ? 12 : 10;
                    const fontWeight = index === 0 ? 'bold' : 'normal';
                    doc.setFontSize(fontSize);
                    doc.setFont('Quicksand', fontWeight);
                    doc.setTextColor(0, 0, 0);
                    // Handle long text by wrapping with available width
                    const lines = doc.splitTextToSize(textEl.text, maxTextWidth);
                    if (Array.isArray(lines)) {
                        lines.forEach((line, lineIndex) => {
                            // Right align the text
                            doc.text(line, pageWidth - marginRight, yPosition + (lineIndex * (fontSize === 12 ? 8 : 6)), { align: 'right' });
                        });
                        yPosition += lines.length * (fontSize === 12 ? 8 : 6);
                    }
                    else {
                        // Right align the text
                        doc.text(lines, pageWidth - marginRight, yPosition, { align: 'right' });
                        yPosition += fontSize === 12 ? 8 : 6;
                    }
                });
            };
            // Add initial header
            addAdvancedSearchableHeader(1, 1);
            // Generate PDF with main content
            await new Promise((resolve) => {
                const pdfWidthMm = 210;
                const totalPx = 1000;
                const marginPx = 5;
                const usablePx = totalPx - marginPx * 2; // 980px
                const scaleFactor = (pdfWidthMm / usablePx - 0.01).toFixed(2) || 0.21; // ≈ 0.2143
                doc.html(mainContent, {
                    /* x: marginLeft,
                    y: marginTop,
                    width: pageWidth - marginLeft - marginRight,
                    windowWidth: 800, */
                    x: 0,
                    y: 0,
                    width: 1000,
                    windowWidth: 1000,
                    autoPaging: 'text',
                    //margin: [marginTop, marginRight, marginBottom, marginLeft],
                    margin: [marginTop, marginPx, marginBottom, marginPx],
                    html2canvas: {
                        //scale: 0.21,
                        scale: scaleFactor,
                        useCORS: true,
                        allowTaint: true,
                        logging: false,
                        backgroundColor: '#ffffff',
                        // CRITICAL: Ignore ALL external stylesheets and global styles
                        /* ignoreElements: (element: Element) => {
                            
                            // Ignore ALL style elements
                            if (element.tagName === 'STYLE') {
                                //console.log(element);
                                return !element.hasAttribute('data-pdf-only');
                            }

                            // Ignore ALL link elements with stylesheets
                            if (element.tagName === 'LINK' && element.getAttribute('rel') === 'stylesheet') {
                                return !element.hasAttribute('data-pdf-only');
                            }

                            // Ignore elements with global framework classes
                            const classList = Array.from(element.classList);
                            const hasGlobalClasses = classList.some(className => this.isProblematicClass(className));

                            return hasGlobalClasses;
                        }, */
                        onclone: (clonedDoc) => {
                            this.setCustomViewport(clonedDoc);
                            // console.log(clonedDoc);
                            this.removeAllStylesFromDocument(clonedDoc);
                            this.enhanceClonedDocument(clonedDoc);
                        }
                    },
                    callback: (pdf) => {
                        const totalPages = pdf.internal.getNumberOfPages();
                        // Add headers to all pages
                        for (let i = 1; i <= totalPages; i++) {
                            pdf.setPage(i);
                            addAdvancedSearchableHeader(i, totalPages);
                        }
                        // Add PDF metadata for searchability
                        pdf.setProperties({
                            title: `${fileName}`,
                            author: 'Inadev',
                            subject: `${fileName}`,
                            keywords: `${fileName}, pdf`,
                            creator: 'Inadev'
                        });
                        setTimeout(() => {
                            this.handlePDFAction(pdf, 'download', fileName);
                            resolve();
                        }, 0);
                    }
                });
            });
        }
        catch (error) {
            // console.error('Error generating advanced searchable PDF:', error);
        }
    }
    setCustomViewport(doc) {
        const viewport = doc.querySelector('meta[name="viewport"]');
        if (viewport) {
            // Set custom viewport for PDF generation
            viewport.setAttribute('content', 'width=1000, initial-scale=1.0, shrink-to-fit=no, maximum-scale=1.0, user-scalable=no, minimum-scale=1.0');
        }
        else {
            // Create new viewport meta tag if none exists
            const meta = doc.createElement('meta');
            meta.setAttribute('name', 'viewport');
            meta.setAttribute('content', 'width=1000, initial-scale=1.0, shrink-to-fit=no, maximum-scale=1.0, user-scalable=no, minimum-scale=1.0');
            doc.head.appendChild(meta);
        }
    }
    /**
     * Extract advanced content from header element
     */
    extractAdvancedHeaderContent(element) {
        const content = {
            textElements: [],
            images: []
        };
        // Extract text nodes with their styling context using TreeWalker
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
        let node;
        while (node = walker.nextNode()) {
            const text = node.textContent?.trim();
            if (text && text.length > 0) {
                const parentElement = node.parentElement;
                if (parentElement) {
                    const computedStyle = window.getComputedStyle(parentElement);
                    content.textElements.push({
                        text: text,
                        color: computedStyle.color,
                        fontSize: computedStyle.fontSize,
                        fontWeight: computedStyle.fontWeight
                    });
                }
            }
        }
        // Extract images with their metadata
        const images = element.querySelectorAll('img');
        images.forEach(img => {
            if (img.src) {
                content.images.push({
                    src: img.src,
                    alt: img.alt || 'Header Image',
                    width: img.width || img.offsetWidth,
                    height: img.height || img.offsetHeight
                });
            }
        });
        return content;
    }
    /**
     * Process header images for PDF inclusion
     */
    async processHeaderImages(images) {
        const processed = [];
        for (const imgInfo of images) {
            try {
                const dataUrl = await this.convertAndCompressImage(imgInfo.src, 140, 50, 0.9);
                processed.push({
                    data: dataUrl,
                    alt: imgInfo.alt,
                    width: imgInfo.width,
                    height: imgInfo.height
                });
            }
            catch (error) {
                console.warn('Could not process header image:', error);
                // Add placeholder for failed images
                processed.push({
                    data: null,
                    alt: imgInfo.alt || 'Image not available',
                    width: imgInfo.width,
                    height: imgInfo.height
                });
            }
        }
        return processed;
    }
    convertAndCompressImage(url, maxWidth = 800, maxHeight = 800, quality = 0.7) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = () => {
                try {
                    const { compressedDataUrl } = this.processImageCompression(img, maxWidth, maxHeight, quality, url);
                    resolve(compressedDataUrl);
                }
                catch (error) {
                    reject(error);
                }
            };
            img.onerror = (err) => reject(err);
            img.src = url;
        });
    }
    processImageCompression(img, maxWidth, maxHeight, quality, url) {
        let { width, height } = img;
        // Calculate new size while preserving aspect ratio
        if (width > maxWidth || height > maxHeight) {
            const ratio = Math.min(maxWidth / width, maxHeight / height);
            width = width * ratio;
            height = height * ratio;
        }
        const canvas = this.createCanvas(width, height);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);
        const originalFormat = this.getImageFormat(url);
        if (originalFormat === 'png' || this.hasTransparency(canvas)) {
            return { compressedDataUrl: canvas.toDataURL('image/png') };
        }
        else {
            const tempCanvas = this.createCanvasWithBackground(canvas, width, height);
            return { compressedDataUrl: tempCanvas.toDataURL('image/jpeg', quality) };
        }
    }
    createCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        return canvas;
    }
    createCanvasWithBackground(sourceCanvas, width, height) {
        const tempCanvas = this.createCanvas(width, height);
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = '#FFFFFF';
        tempCtx.fillRect(0, 0, width, height);
        tempCtx.drawImage(sourceCanvas, 0, 0);
        return tempCanvas;
    }
    getImageFormat(url) {
        const extension = url.split('.').pop()?.toLowerCase();
        return extension || 'png';
    }
    hasTransparency(canvas) {
        const ctx = canvas.getContext('2d');
        if (!ctx)
            return false;
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        // Check if any pixel has alpha channel less than 255 (transparent)
        for (let i = 3; i < data.length; i += 4) {
            if (data[i] < 255) {
                return true;
            }
        }
        return false;
    }
    /* Styles related helper functions */
    removeStyleTags() {
        const shadowRoot = this.elementRef.nativeElement.shadowRoot;
        if (!shadowRoot)
            return;
        // Remove all <style> tags from projected content EXCEPT intentionally loaded ones
        const styleTags = shadowRoot.querySelectorAll('style');
        styleTags.forEach(styleTag => {
            if (!styleTag.hasAttribute('data-pdf-only')) {
                styleTag.remove();
            }
        });
        // Remove all <link> tags with stylesheets EXCEPT intentionally loaded ones
        const linkTags = shadowRoot.querySelectorAll('link[rel="stylesheet"]');
        linkTags.forEach(linkTag => {
            if (!linkTag.hasAttribute('data-pdf-only')) {
                linkTag.remove();
            }
        });
        // Also check specifically in the head element
        const headElement = shadowRoot.querySelector('head');
        if (headElement) {
            const headStyles = headElement.querySelectorAll('style:not([data-pdf-only])');
            const headLinks = headElement.querySelectorAll('link[rel="stylesheet"]:not([data-pdf-only])');
            headStyles.forEach(style => style.remove());
            headLinks.forEach(link => link.remove());
        }
    }
    // Monitor style changes within the shadow DOM
    setupStyleMonitoring() {
        const shadowRoot = this.elementRef.nativeElement.shadowRoot;
        if (!shadowRoot)
            return;
        this.mutationObserver = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            const element = node;
                            // Only remove style/link tags that are NOT intentionally loaded
                            if (element.tagName === 'STYLE' && !element.hasAttribute('data-pdf-only')) {
                                element.remove();
                            }
                            else if (element.tagName === 'LINK' &&
                                element.getAttribute('rel') === 'stylesheet' &&
                                !element.hasAttribute('data-pdf-only')) {
                                element.remove();
                            }
                            // Check for nested style tags (excluding intentionally loaded ones)
                            const nestedStyles = element.querySelectorAll('style:not([data-pdf-only]), link[rel="stylesheet"]:not([data-pdf-only])');
                            nestedStyles.forEach(style => style.remove());
                        }
                    });
                }
            });
        });
        this.mutationObserver.observe(shadowRoot, {
            childList: true,
            subtree: true
        });
    }
    // Load an external stylesheet into the shadow DOM
    loadExternalStylesheet(cssPath) {
        if (!cssPath || this.isStylesheetAlreadyLoaded(cssPath)) {
            return;
        }
        const shadowRoot = this.elementRef.nativeElement.shadowRoot;
        if (!shadowRoot) {
            console.warn('Shadow DOM not available for loading stylesheet');
            return;
        }
        // Find the head element inside the shadow DOM
        let headElement = shadowRoot.querySelector('head');
        // If head doesn't exist, create it
        if (!headElement) {
            headElement = this.renderer.createElement('head');
            const htmlElement = shadowRoot.querySelector('html');
            if (htmlElement) {
                this.renderer.insertBefore(htmlElement, headElement, htmlElement.firstChild);
            }
            else {
                // If no html element, append to shadow root
                this.renderer.appendChild(shadowRoot, headElement);
            }
        }
        const link = this.renderer.createElement('link');
        this.renderer.setAttribute(link, 'rel', 'stylesheet');
        this.renderer.setAttribute(link, 'type', 'text/css');
        this.renderer.setAttribute(link, 'href', cssPath);
        // IMPORTANT: Mark as intentionally loaded to prevent removal
        this.renderer.setAttribute(link, 'data-pdf-only', 'true');
        // Append to the head element instead of shadow root
        this.renderer.appendChild(headElement, link);
        this.loadedStylesheets.push(link);
    }
    isStylesheetAlreadyLoaded(cssPath) {
        const shadowRoot = this.elementRef.nativeElement.shadowRoot;
        if (!shadowRoot)
            return false;
        // Check within shadow DOM's head tag
        const headElement = shadowRoot.querySelector('head');
        if (!headElement)
            return false;
        return headElement.querySelector(`link[href="${cssPath}"]`) !== null;
    }
    cleanGlobalStyleReferences(container) {
        // Remove any elements that might be pulling in external styles
        const elementsWithStyleRefs = container.querySelectorAll('[style], [class*="mat-"], [class*="bootstrap-"], [class*="btn-"]');
        elementsWithStyleRefs.forEach(element => {
            // Remove problematic classes
            const classList = Array.from(element.classList);
            classList.forEach(className => {
                if (className.startsWith('mat-') ||
                    className.startsWith('bootstrap-') ||
                    className.startsWith('btn-') ||
                    className.startsWith('form-') ||
                    className.startsWith('container') ||
                    className.startsWith('row') ||
                    className.startsWith('col-')) {
                    element.classList.remove(className);
                }
            });
        });
    }
    /**
     * Open HTML preview in a new tab before PDF generation
     */
    openHtmlPreview() {
        try {
            const shadowRoot = this.elementRef.nativeElement.shadowRoot;
            if (!shadowRoot) {
                console.warn('Shadow DOM not available for HTML preview');
                return;
            }
            // Prepare content for preview (same as PDF preparation)
            const previewContent = this.prepareContentForPDF(shadowRoot);
            // Create a complete HTML document
            const htmlDocument = this.createPreviewHtmlDocument(previewContent);
            // Open in new tab
            const newWindow = window.open('', '_blank');
            if (newWindow) {
                newWindow.document.write(htmlDocument);
                newWindow.document.close();
                // Optional: Set window title
                newWindow.document.title = this.pdfFileName.replace('.pdf', '') + ' - Preview';
            }
            else {
                console.warn('Failed to open preview window. Please check popup blocker settings.');
            }
        }
        catch (error) {
            console.error('Error opening HTML preview:', error);
        }
    }
    /**
     * Create a complete HTML document for preview
     */
    createPreviewHtmlDocument(content) {
        // Get header content if available
        let headerHtml = '';
        if (this.contentProjectionOptions.headerElementId) {
            const escapedId = CSS.escape(this.contentProjectionOptions.headerElementId);
            const headerElement = document.querySelector(`#${escapedId}`);
            if (headerElement) {
                headerHtml = this.createHeaderPreviewHtml(headerElement);
            }
        }
        // Create complete HTML document
        const htmlDocument = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=1000, initial-scale=1.0, shrink-to-fit=no, maximum-scale=1.0, user-scalable=no, minimum-scale=1.0" style="transition-property: none;">
                <title>${this.pdfFileName.replace('.pdf', '')} - Preview</title>
                <style>
                    ${this.pdfStyles}
                    body {
                        font-family: "Quicksand", sans-serif;
                        margin: 0;
                        padding: 20px;
                        background-color: #ffffff;
                        color: #000;
                        line-height: 1.6;
                    }
                    .preview-container {
                        max-width: 210mm;
                        margin: 0 auto;
                        background: white;
                        box-shadow: 0 0 10px rgba(0,0,0,0.1);
                        padding: 20px;
                    }
                </style>
            </head>
            <body>
                <div class="preview-container">
                    ${headerHtml ? `<div class="header-section">${headerHtml}</div>` : ''}
                    <div class="content-section">
                        ${content.innerHTML}
                    </div>
                </div>
            </body>
            </html>
        `;
        return htmlDocument;
    }
    /**
     * Create header HTML for preview
     */
    createHeaderPreviewHtml(headerElement) {
        // Clone the header element
        const clonedHeader = headerElement.cloneNode(true);
        // Process any form elements in the header
        this.processFormElements(clonedHeader, headerElement.getRootNode());
        // Clean up the header content
        this.cleanDatePickerElements(clonedHeader);
        return clonedHeader.innerHTML;
    }
    static ɵfac = function ContentProjectionWrapperComponent_Factory(t) { return new (t || ContentProjectionWrapperComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(WFEEventListHandler), i0.ɵɵdirectiveInject(i9.HttpClient), i0.ɵɵdirectiveInject(i0.Renderer2)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ContentProjectionWrapperComponent, selectors: [["print-preview-wrapper"]], viewQuery: function ContentProjectionWrapperComponent_Query(rf, ctx) { if (rf & 1) {
            i0.ɵɵviewQuery(_c0$1, 5);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.printableContainer = _t.first);
        } }, inputs: { sectionData: "sectionData" }, standalone: true, features: [i0.ɵɵStandaloneFeature], ngContentSelectors: _c1$1, decls: 4, vars: 3, consts: [[1, "content-projection-container", "content-container"], [1, "section-main"]], template: function ContentProjectionWrapperComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵelementStart(0, "div", 0)(1, "div")(2, "div", 1);
            i0.ɵɵprojection(3);
            i0.ɵɵelementEnd()()();
        } if (rf & 2) {
            i0.ɵɵadvance();
            i0.ɵɵclassMapInterpolate1("viewport-wrapper ", ctx.contentProjectionOptions == null ? null : ctx.contentProjectionOptions.wrapperClass, "");
        } }, dependencies: [CommonModule], encapsulation: 3 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ContentProjectionWrapperComponent, [{
        type: Component,
        args: [{ selector: 'print-preview-wrapper', standalone: true, imports: [CommonModule], encapsulation: ViewEncapsulation.ShadowDom, template: "<div class=\"content-projection-container content-container\">\r\n    <div class=\"viewport-wrapper {{contentProjectionOptions?.wrapperClass}}\">\r\n        <!-- Main content projection (default slot) -->\r\n        <div class=\"section-main\">\r\n            <ng-content></ng-content>\r\n        </div>\r\n    </div>\r\n</div>" }]
    }], () => [{ type: i0.ElementRef }, { type: SharedEventsServiceService }, { type: WFEEventListHandler }, { type: i9.HttpClient }, { type: i0.Renderer2 }], { sectionData: [{
            type: Input,
            args: ['sectionData']
        }], printableContainer: [{
            type: ViewChild,
            args: ['printableContainer', { static: false }]
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(ContentProjectionWrapperComponent, { className: "ContentProjectionWrapperComponent", filePath: "lib\\components\\content-projection-wrapper\\content-projection-wrapper.component.ts", lineNumber: 40 }); })();

const _c0 = (a0, a1, a2, a3, a4, a5) => ({ stepId: a0, rootData: a1, paginateValue: a2, fieldData: a3, sectionData: a4, type: a5 });
const _c1 = (a0, a1, a2, a3, a4) => ({ stepId: a0, rootData: a1, templateId: a2, sectionData: a3, type: a4 });
const _c2 = (a0, a1, a2, a3) => ({ stepId: a0, rootData: a1, rowData: a2, fieldData: a3, keepState: true });
const _c3 = a0 => ({ stepId: a0 });
function SectionRendererComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelement(1, "app-dynamic-renderer", 7);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("cee_loader cee_loader_", ctx_r0.sectionData.section_id, "");
} }
function SectionRendererComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "section");
    i0.ɵɵelement(2, "app-sidemenu-bar-renderer", 8);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("sub-menu-bar ", ctx_r0.sideBarData.sidemenuBlock ? ctx_r0.sideBarData.sidemenuBlock == null ? null : ctx_r0.sideBarData.sidemenuBlock.side_menu_class : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("sidemenuBlockElements", ctx_r0.sideBarData.sidemenuBlock.submenu)("sidemenuBlock", ctx_r0.sideBarData.sidemenuBlock)("currentStep", ctx_r0.stepId)("currentStepName", ctx_r0.stepName);
} }
function SectionRendererComponent_ng_container_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function SectionRendererComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div", 9);
    i0.ɵɵtemplate(2, SectionRendererComponent_ng_container_3_ng_container_2_Template, 1, 0, "ng-container", 10);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 2, ctx_r0.componentMap["Table"]))("ngComponentOutletInputs", i0.ɵɵpureFunction6(4, _c0, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.paginateValue, ctx_r0.fieldValue, ctx_r0.sectionData, ctx_r0.componentName));
} }
function SectionRendererComponent_ng_container_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function SectionRendererComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, SectionRendererComponent_ng_container_4_ng_container_2_Template, 1, 0, "ng-container", 10);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("app-list-renderer ", ctx_r0.is_bootstrap ? ctx_r0.sectionData.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap["List"]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(7, _c1, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.templateId, ctx_r0.sectionData, ctx_r0.componentName));
} }
function SectionRendererComponent_ng_container_5_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function SectionRendererComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtemplate(2, SectionRendererComponent_ng_container_5_ng_container_2_Template, 1, 0, "ng-container", 10);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate1("app-tree-renderer ", ctx_r0.is_bootstrap ? ctx_r0.sectionData.field_style.custom_class_name : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(3, 5, ctx_r0.componentMap["TreeView"]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(7, _c1, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.templateId, ctx_r0.sectionData, ctx_r0.componentName));
} }
function SectionRendererComponent_ng_container_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function SectionRendererComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, SectionRendererComponent_ng_container_6_ng_container_1_Template, 1, 0, "ng-container", 10);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 2, ctx_r0.componentMap["Accordion"]))("ngComponentOutletInputs", i0.ɵɵpureFunction5(4, _c1, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.templateId, ctx_r0.sectionData, ctx_r0.componentName));
} }
function SectionRendererComponent_ng_container_7_ng_container_2_div_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function SectionRendererComponent_ng_container_7_ng_container_2_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, SectionRendererComponent_ng_container_7_ng_container_2_div_2_ng_container_1_Template, 1, 0, "ng-container", 10);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    const field_r3 = ctx_r1.$implicit;
    const pos_r4 = ctx_r1.index;
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMapInterpolate1("field-", pos_r4, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 5, ctx_r0.componentMap["ContextMenu"]))("ngComponentOutletInputs", i0.ɵɵpureFunction4(7, _c2, ctx_r0.stepId, ctx_r0.rootData, ctx_r0.generateRowData(field_r3), field_r3));
} }
function SectionRendererComponent_ng_container_7_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-view-renderer", 14);
    i0.ɵɵtemplate(2, SectionRendererComponent_ng_container_7_ng_container_2_div_2_Template, 3, 12, "div", 1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const field_r3 = ctx.$implicit;
    const pos_r4 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate3("app-view-renderer-", ctx_r0.sectionData.section_id, "-", pos_r4, " ", field_r3.field_style ? ctx_r0.commonUtil.bootstrapColClass(field_r3.field_style.bootstrap_class_name, ctx_r0.is_bootstrap, ctx_r0.rootData.templateClass, ctx_r0.conditionalUtil.evaluteBootstrapCondition(field_r3)) : "", "");
    i0.ɵɵproperty("stepId", ctx_r0.stepId)("field", field_r3)("position", pos_r4)("templateId", ctx_r0.templateId)("rootData", ctx_r0.rootData)("mandatoryCondition", ctx_r0.mandatoryCondition)("editableCondition", ctx_r0.editableCondition)("visibleCondition", ctx_r0.visibleCondition)("rowData", ctx_r0.generateRowData(field_r3));
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", field_r3.field_type == "ContextMenu");
} }
function SectionRendererComponent_ng_container_7_Conditional_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function SectionRendererComponent_ng_container_7_Conditional_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 13);
    i0.ɵɵtemplate(1, SectionRendererComponent_ng_container_7_Conditional_3_ng_container_1_Template, 1, 0, "ng-container", 10);
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵpropertyInterpolate1("id", "inner-step-renderer-", ctx_r0.isRenderStep, "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngComponentOutlet", i0.ɵɵpipeBind1(2, 4, ctx_r0.componentMap["Step"]))("ngComponentOutletInputs", i0.ɵɵpureFunction1(6, _c3, ctx_r0.isRenderStep));
} }
function SectionRendererComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "section", 11);
    i0.ɵɵtemplate(2, SectionRendererComponent_ng_container_7_ng_container_2_Template, 3, 15, "ng-container", 12)(3, SectionRendererComponent_ng_container_7_Conditional_3_Template, 3, 8, "div", 13);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵclassMapInterpolate4("cee-section template-", ctx_r0.templateId, " step-", ctx_r0.stepId, "  section-", ctx_r0.stepPosition, " ", ctx_r0.is_bootstrap ? "row" : "", "");
    i0.ɵɵpropertyInterpolate("id", ctx_r0.sectionData.section_id);
    i0.ɵɵattribute("aria-label", ctx_r0.additionalParameter["Aria-Label"] ? ctx_r0.additionalParameter["Aria-Label"] : undefined)("role", ctx_r0.additionalParameter["Aria-Role"]);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.sectionData.fields)("ngForTrackBy", ctx_r0.trackBySectionFields);
    i0.ɵɵadvance();
    i0.ɵɵconditional(3, ctx_r0.isRenderStep ? 3 : -1);
} }
function SectionRendererComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "app-dynamic-renderer", 15);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("moduleName", ctx_r0.componentName);
} }
function SectionRendererComponent_section_9_ng_container_1_app_section_renderer_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "app-section-renderer", 19);
} if (rf & 2) {
    const section_r5 = ctx.$implicit;
    const pos_r6 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate4("compliance-form-wrapper section-child-", pos_r6, " block-main-", pos_r6, "-", ctx_r0.stepPosition, " ", section_r5.section_style ? ctx_r0.commonUtil.bootstrapColClass(ctx_r0.commonUtil.implodeClassName(section_r5.section_style.bootstrap_class_name), ctx_r0.is_bootstrap, "", ctx_r0.conditionalUtil.evaluteBootstrapCondition(section_r5)) : "", "");
    i0.ɵɵproperty("templateId", ctx_r0.templateId)("sectionData", section_r5)("stepPosition", ctx_r0.stepPosition + "-" + pos_r6)("sideBarData", ctx_r0.sideBarData)("stepId", ctx_r0.stepId)("stepName", ctx_r0.stepName)("rootData", ctx_r0.rootData);
} }
function SectionRendererComponent_section_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "print-preview-wrapper", 17);
    i0.ɵɵtemplate(2, SectionRendererComponent_section_9_ng_container_1_app_section_renderer_2_Template, 1, 13, "app-section-renderer", 18);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("sectionData", ctx_r0.sectionData);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngForOf", ctx_r0.sectionData.sections)("ngForTrackBy", ctx_r0.trackBySections);
} }
function SectionRendererComponent_section_9_ng_template_2_app_section_renderer_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "app-section-renderer", 19);
} if (rf & 2) {
    const section_r7 = ctx.$implicit;
    const pos_r8 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate4("section-child-", pos_r8, " block-main-", pos_r8, "-", ctx_r0.stepPosition, "  ", section_r7.section_style ? ctx_r0.commonUtil.bootstrapColClass(ctx_r0.commonUtil.implodeClassName(section_r7.section_style.bootstrap_class_name), ctx_r0.is_bootstrap, "", ctx_r0.conditionalUtil.evaluteBootstrapCondition(section_r7)) : "", "");
    i0.ɵɵproperty("templateId", ctx_r0.templateId)("sectionData", section_r7)("stepPosition", ctx_r0.stepPosition + "-" + pos_r8)("sideBarData", ctx_r0.sideBarData)("stepId", ctx_r0.stepId)("stepName", ctx_r0.stepName)("rootData", ctx_r0.rootData);
} }
function SectionRendererComponent_section_9_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, SectionRendererComponent_section_9_ng_template_2_app_section_renderer_0_Template, 1, 13, "app-section-renderer", 18);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngForOf", ctx_r0.sectionData.sections)("ngForTrackBy", ctx_r0.trackBySections);
} }
function SectionRendererComponent_section_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "section", 11);
    i0.ɵɵtemplate(1, SectionRendererComponent_section_9_ng_container_1_Template, 3, 3, "ng-container", 16)(2, SectionRendererComponent_section_9_ng_template_2_Template, 1, 2, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const regularSection_r9 = i0.ɵɵreference(3);
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("section-nested-body ", ctx_r0.is_bootstrap ? "row" : "", "");
    i0.ɵɵpropertyInterpolate1("id", "section-nested-", ctx_r0.sectionData ? ctx_r0.sectionData.section_id : "", "");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r0.useContentProjection)("ngIfElse", regularSection_r9);
} }
class SectionRendererComponent {
    sharedEventsService;
    appDataService;
    apiDataService;
    cdRef;
    sectionData;
    stepPosition;
    stepId;
    stepName;
    templateId;
    rootData;
    sideBarData;
    emitterObj = {};
    additionalParameter = {};
    componentName = 'none';
    paginateValue;
    fieldValue;
    is_bootstrap = false;
    loader = {
        name: 'CEE_LOADER',
        showSection: false
    };
    isVisible = true;
    mandatoryCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    editableCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    visibleCondition = {
        value: false,
        fields: [],
        exceptionFields: [],
        isActive: false,
        override: false,
        overrideAll: false
    };
    commonUtil;
    conditionalUtil;
    generateUtil;
    componentList = {};
    componentMap = {
        Table: defer(() => {
            if (this.componentList['Table']) {
                return this.componentList['Table'];
            }
            else {
                const c = import('./ng-cee-core-cee-table.component-Dj5GWWHv.mjs').then(m => m.CeeTableComponent);
                this.componentList['Table'] = c;
                return c;
            }
        }),
        List: defer(() => {
            if (this.componentList['List']) {
                return this.componentList['List'];
            }
            else {
                const c = import('./ng-cee-core-list-renderer.component-nDakO_mU.mjs').then(m => m.ListRendererComponent);
                this.componentList['List'] = c;
                return c;
            }
        }),
        TreeView: defer(() => {
            if (this.componentList['TreeView']) {
                return this.componentList['TreeView'];
            }
            else {
                const c = import('./ng-cee-core-tree-renderer.component-W51n06MU.mjs').then(m => m.TreeRendererComponent);
                this.componentList['TreeView'] = c;
                return c;
            }
        }),
        Accordion: defer(() => {
            if (this.componentList['Accordion']) {
                return this.componentList['Accordion'];
            }
            else {
                const c = import('./ng-cee-core-accordion-renderer.component-Dktp3JsQ.mjs').then(m => m.AccordionRendererComponent);
                this.componentList['Accordion'] = c;
                return c;
            }
        }),
        ContextMenu: defer(() => {
            if (this.componentList['ContextMenu']) {
                return this.componentList['ContextMenu'];
            }
            else {
                const c = import('./ng-cee-core-cee-menucontext.component-DeirpWHX.mjs').then(m => m.CeeMenucontextComponent);
                this.componentList['ContextMenu'] = c;
                return c;
            }
        }),
        Step: defer(() => {
            if (this.componentList['Step']) {
                return this.componentList['Step'];
            }
            else {
                const c = Promise.resolve().then(function () { return stepRenderer_component; }).then(m => m.StepRendererComponent);
                this.componentList['Step'] = c;
                return c;
            }
        })
    };
    isRenderStep;
    useShadowDom = false;
    useContentProjection = false;
    constructor(sharedEventsService, appDataService, apiDataService, cdRef) {
        this.sharedEventsService = sharedEventsService;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.cdRef = cdRef;
        this.commonUtil = new CommonUtil();
        this.conditionalUtil = new ConditionalUtil(false, appDataService, apiDataService);
        this.generateUtil = new GenerateFieldRow(appDataService);
        if (localStorage.getItem('is_bootstrap') === 'true') {
            this.is_bootstrap = true;
        }
    }
    trackBySectionFields(index, item) {
        return item.unique_id;
    }
    trackBySections(index, item) {
        return item.section_id;
    }
    ngOnInit() {
        if (this.sectionData.additional_parameters && this.sectionData.additional_parameters.length > 0) {
            for (const paramter of this.sectionData.additional_parameters) {
                this.additionalParameter[paramter.parameter_type] = paramter.value;
                switch (paramter.parameter_type) {
                    case 'CEE_pdfGenerationShadoDomEnabled':
                        this.useContentProjection = paramter.value == 'true' ? true : false;
                        break;
                    /* case 'CEE_ShowHeader':
                        this.contentProjectionOptions.showHeader = paramter.value == 'true' ? true : false;
                        break;
                    case 'CEE_ShowBefore':
                        this.contentProjectionOptions.showBefore = paramter.value == 'true' ? true : false;
                        break;
                    case 'CEE_ShowAfter':
                        this.contentProjectionOptions.showAfter = paramter.value == 'true' ? true : false;
                        break;
                    case 'CEE_ShowSidebar':
                        this.contentProjectionOptions.showSidebar = paramter.value == 'true' ? true : false;
                        break;
                    case 'CEE_ShowFooter':
                        this.contentProjectionOptions.showFooter = paramter.value == 'true' ? true : false;
                        break;
                    case 'CEE_ShowActions':
                        this.contentProjectionOptions.showActions = paramter.value == 'true' ? true : false;
                        break;
                    case 'CEE_WrapperClass':
                        this.contentProjectionOptions.wrapperClass = paramter.value;
                        break;
                    case 'CEE_IsolateStyles':
                        this.contentProjectionOptions.isolateStyles = paramter.value == 'true' ? true : false;
                        break;
                    case 'CEE_LogoPath':
                        this.contentProjectionOptions.logoPath = paramter.value;
                        break;
                    case 'CEE_FontPath':
                        this.contentProjectionOptions.fontPath = paramter.value;
                        break; */
                    case 'renderType':
                        this.componentName = paramter.value;
                        break;
                    case 'WebSectionTemplate':
                        this.componentName = paramter.value;
                        this.fieldValue = this.sectionData.fields;
                        break;
                    case 'DataTablePagination':
                        this.paginateValue = paramter.value;
                        break;
                    case 'OverrideConditions':
                        if (paramter.value && paramter.value !== 'NONE' && paramter.value !== 'ALL') {
                            const fields = paramter.value.split('|').map(val => val.trim());
                            this.mandatoryCondition.fields = fields;
                            this.editableCondition.fields = fields;
                            this.visibleCondition.fields = fields;
                        }
                        break;
                    case 'ExceptionConditions':
                        const fields = paramter.value.split('|').map(val => val.trim());
                        this.mandatoryCondition.exceptionFields = fields;
                        this.editableCondition.exceptionFields = fields;
                        this.visibleCondition.exceptionFields = fields;
                        break;
                    default:
                        break;
                }
            }
        }
        // subscribe to field changes
        if ((this.sectionData.conditional_visible && this.sectionData.conditional_visible.length > 0) ||
            (this.sectionData.conditional_editable && this.sectionData.conditional_editable.length) > 0 ||
            (this.sectionData.conditional_mandatory && this.sectionData.conditional_mandatory.length > 0)) {
            this.onFieldDataUpdated(null, null);
            this.emitterObj[this.sectionData.section_id + '_emitOnDataSetOrUpdatedForSection'] =
                this.sharedEventsService.emitOnDataSetOrUpdatedForSection.subscribe((res) => {
                    this.onFieldDataUpdated(res.apiKey, res.value);
                });
        }
        if (this.sectionData.conditional_visible && this.sectionData.conditional_visible.length > 0) {
            this.visibleCondition.isActive = true;
        }
        if (this.sectionData.conditional_editable && this.sectionData.conditional_editable.length > 0) {
            this.editableCondition.isActive = true;
        }
        if (this.sectionData.conditional_mandatory && this.sectionData.conditional_mandatory.length > 0) {
            this.mandatoryCondition.isActive = true;
        }
        this.rootData['sectionFields'][this.sectionData.section_id] = [];
        if (this.sectionData.fields) {
            for (let i = 0; i < this.sectionData.fields.length; i++) {
                const field = this.sectionData.fields[i];
                // bootstrap_class_name configuration
                if (this.is_bootstrap && this.componentName === 'none' && field.field_style && this.sectionData.section_style) {
                    if (this.sectionData.section_style.bootstrap_class_name && !field.field_style.bootstrap_class_name) {
                        field.field_style.bootstrap_class_name = this.sectionData.section_style.bootstrap_class_name;
                    }
                    field.field_style.bootstrap_class_name = this.commonUtil.implodeClassName(field.field_style.bootstrap_class_name);
                    field.field_style.custom_class_name = this.commonUtil.implodeClassName(field.field_style.custom_class_name);
                }
                this.rootData['sectionFields'][this.sectionData.section_id].push(field.unique_id);
            }
        }
        this.cdRef.detectChanges();
        if (this.additionalParameter['Loader Handler name']) {
            this.emitterObj[this.sectionData.section_id + '_customSectionLoaderEmitter'] =
                this.sharedEventsService.customSectionLoaderEmitter.subscribe((res) => {
                    if (this.additionalParameter['Loader Handler name'].split('|').map(str => str.trim()).includes(res.handlerName)) {
                        this.loader.showSection = res.loading;
                    }
                });
        }
        this.emitterObj[this.sectionData.section_id + '_targetStepRedirection'] =
            this.sharedEventsService.targetStepRedirection.subscribe(res => {
                if (res?.target && this.sectionData.section_id === res.target && res?.stepId) {
                    this.isRenderStep = res.stepId;
                }
            });
    }
    // Uses cases for the following function
    // 1: override NONE child can override r override all false;
    // 2: override ALL child cannot override;
    // 3: when value is false child cannot override
    // 4: when value is true and override condition is not NONE or ALL and override condition
    // has pipe separated field values then only those fields will be overridden set override to true
    onFieldDataUpdated(fieldId, value) {
        if (this.additionalParameter.OverrideConditions !== 'NONE') {
            const display = this.conditionalUtil.checkVisibility(this.sectionData, fieldId, value);
            if (display !== undefined) {
                this.isVisible = display;
                this.visibleCondition.value = display;
                this.setOverride(display, 'visibleCondition');
            }
            const editable = this.conditionalUtil.checkEditable(this.sectionData, fieldId, value);
            if (editable !== undefined) {
                this.editableCondition.value = editable;
                this.setOverride(editable, 'editableCondition');
            }
            const mandatory = this.conditionalUtil.checkMandatory(this.sectionData, fieldId, value);
            if (mandatory !== undefined) {
                this.mandatoryCondition.value = mandatory;
                this.setOverride(mandatory, 'mandatoryCondition');
            }
            this.visibleCondition = JSON.parse(JSON.stringify(this.visibleCondition));
            this.editableCondition = JSON.parse(JSON.stringify(this.editableCondition));
            this.mandatoryCondition = JSON.parse(JSON.stringify(this.mandatoryCondition));
        }
    }
    setOverride(property, value) {
        if (!this.additionalParameter.hasOwnProperty('OverrideConditions')) {
            return;
        }
        // use case 1
        if (this.additionalParameter.OverrideConditions === 'NONE') {
            this[value].overrideAll = false;
            this[value].override = false;
        }
        // use case 2 and 3
        if (!property || this.additionalParameter.OverrideConditions === 'ALL') {
            this[value].overrideAll = true;
            this[value].override = true;
        }
        // use case 4
        if (property && this.additionalParameter.OverrideConditions !== 'NONE' &&
            this.additionalParameter.OverrideConditions !== 'ALL' &&
            this[value].fields.length > 0) {
            this[value].overrideAll = false;
            this[value].override = true;
        }
        // use case 5
        if (this.additionalParameter.OverrideConditions === 'AUTO') {
            this[value].overrideAll = true;
            this[value].override = true;
            if (property) {
                this[value].overrideAll = false;
                this[value].override = false;
            }
        }
    }
    ngOnDestroy() {
        for (const key in this.emitterObj) {
            if (this.emitterObj[key]) {
                this.emitterObj[key].unsubscribe();
            }
        }
    }
    generateRowData(field) {
        return this.generateUtil.generateRowData(field);
    }
    static ɵfac = function SectionRendererComponent_Factory(t) { return new (t || SectionRendererComponent)(i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SectionRendererComponent, selectors: [["app-section-renderer"]], inputs: { sectionData: "sectionData", stepPosition: "stepPosition", stepId: "stepId", stepName: "stepName", templateId: "templateId", rootData: "rootData", sideBarData: "sideBarData" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 10, vars: 13, consts: [["regularSection", ""], [3, "class", 4, "ngIf"], [3, "hidden", "ngSwitch"], [4, "ngIf"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "id", "class", 4, "ngIf"], ["moduleName", "CEE_LOADER"], [3, "sidemenuBlockElements", "sidemenuBlock", "currentStep", "currentStepName"], [1, "app-cee-table"], [4, "ngComponentOutlet", "ngComponentOutletInputs"], [3, "id"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "inner-step-renderer", 3, "id"], [3, "stepId", "field", "position", "templateId", "rootData", "mandatoryCondition", "editableCondition", "visibleCondition", "rowData"], [3, "moduleName"], [4, "ngIf", "ngIfElse"], [3, "sectionData"], [3, "templateId", "sectionData", "stepPosition", "sideBarData", "stepId", "stepName", "class", "rootData", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "templateId", "sectionData", "stepPosition", "sideBarData", "stepId", "stepName", "rootData"]], template: function SectionRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, SectionRendererComponent_div_0_Template, 2, 3, "div", 1);
            i0.ɵɵelementStart(1, "div", 2);
            i0.ɵɵtemplate(2, SectionRendererComponent_ng_container_2_Template, 3, 7, "ng-container", 3)(3, SectionRendererComponent_ng_container_3_Template, 4, 11, "ng-container", 4)(4, SectionRendererComponent_ng_container_4_Template, 4, 13, "ng-container", 4)(5, SectionRendererComponent_ng_container_5_Template, 4, 13, "ng-container", 4)(6, SectionRendererComponent_ng_container_6_Template, 3, 10, "ng-container", 4)(7, SectionRendererComponent_ng_container_7_Template, 4, 12, "ng-container", 4)(8, SectionRendererComponent_ng_container_8_Template, 2, 1, "ng-container", 5)(9, SectionRendererComponent_section_9_Template, 4, 7, "section", 6);
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            i0.ɵɵproperty("ngIf", ctx.loader.showSection);
            i0.ɵɵadvance();
            i0.ɵɵclassMap(ctx.sectionData.section_style ? ctx.commonUtil.implodeClassName(ctx.sectionData.section_style.custom_class_name) : "");
            i0.ɵɵproperty("hidden", ctx.loader.showSection || !ctx.isVisible)("ngSwitch", true);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.sideBarData && ctx.sideBarData.sidemenuBlock && (ctx.sideBarData.sidemenuBlock.section_id == null ? null : ctx.sideBarData.sidemenuBlock.section_id.includes(ctx.sectionData.section_id)));
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", ctx.componentName === "Table" || ctx.componentName === "Table-Single-Select" || ctx.componentName === "Table-Multi-Select" || ctx.componentName === "Table-Expandable");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", ctx.componentName === "List" || ctx.componentName === "List-Single-Select" || ctx.componentName === "List-Multi-Select" || ctx.componentName === "List-Expandable");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", ctx.componentName === "TreeView");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", ctx.componentName === "Accordion");
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngSwitchCase", ctx.componentName === "none");
            i0.ɵɵadvance(2);
            i0.ɵɵproperty("ngIf", ctx.sectionData.sections && ctx.sectionData.sections.length);
        } }, dependencies: () => [SectionRendererComponent, SidemenuBarRendererComponent,
            DynamicRendererComponent,
            MatInputModule,
            MatFormFieldModule,
            CommonModule, i13.NgComponentOutlet, i13.NgForOf, i13.NgIf, i13.NgSwitch, i13.NgSwitchCase, i13.NgSwitchDefault, i13.AsyncPipe, ViewRendererComponent, ContentProjectionWrapperComponent] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SectionRendererComponent, [{
        type: Component,
        args: [{ selector: 'app-section-renderer', standalone: true, imports: [
                    SidemenuBarRendererComponent,
                    DynamicRendererComponent,
                    MatInputModule,
                    MatFormFieldModule,
                    CommonModule,
                    NgSwitch,
                    forwardRef(() => ViewRendererComponent),
                    ContentProjectionWrapperComponent
                ], template: "<div *ngIf=\"loader.showSection\" class=\"cee_loader cee_loader_{{sectionData.section_id}}\">\r\n    <app-dynamic-renderer moduleName=\"CEE_LOADER\"></app-dynamic-renderer>\r\n</div>\r\n<div [hidden]=\"loader.showSection || !isVisible\" [ngSwitch]=\"true\"\r\n    class=\"{{sectionData.section_style?commonUtil.implodeClassName(sectionData.section_style.custom_class_name):''}}\">\r\n    <!-- Sidemenu Blocks -->\r\n    <ng-container *ngIf=\"sideBarData && sideBarData.sidemenuBlock && sideBarData.sidemenuBlock.section_id?.includes(sectionData.section_id)\">\r\n        <section class=\"sub-menu-bar {{sideBarData.sidemenuBlock ? sideBarData.sidemenuBlock ?.side_menu_class: ''}}\">\r\n            <app-sidemenu-bar-renderer [sidemenuBlockElements]=\"sideBarData.sidemenuBlock.submenu\" [sidemenuBlock]=\"sideBarData.sidemenuBlock\"\r\n            [currentStep]=\"stepId\" [currentStepName] = \"stepName\"></app-sidemenu-bar-renderer>\r\n        </section>\r\n    </ng-container>\r\n    <ng-container\r\n        *ngSwitchCase=\"componentName === 'Table' || componentName === 'Table-Single-Select' || componentName === 'Table-Multi-Select' || componentName === 'Table-Expandable'\">\r\n        <div class=\"app-cee-table\">\r\n            <ng-container\r\n                *ngComponentOutlet=\"componentMap['Table'] | async; \r\n                                    inputs: {stepId: stepId, rootData: rootData, paginateValue: paginateValue, fieldData: fieldValue, \r\n                                    sectionData: sectionData, type: componentName}\"></ng-container>\r\n        </div>\r\n        <!-- <app-cee-table [stepId]=\"stepId\" class=\"app-cee-table\" [paginateValue]=\"paginateValue\" [fieldData]=\"fieldValue\"\r\n            [sectionData]=\"sectionData\" [type]=\"componentName\">\r\n        </app-cee-table> -->\r\n    </ng-container>\r\n\r\n    <ng-container\r\n        *ngSwitchCase=\"componentName === 'List' || componentName === 'List-Single-Select' || componentName === 'List-Multi-Select' || componentName === 'List-Expandable'\">\r\n        <div class=\"app-list-renderer {{is_bootstrap?sectionData.field_style.custom_class_name:''}}\">\r\n            <ng-container\r\n                *ngComponentOutlet=\"componentMap['List'] | async; \r\n                                    inputs: {stepId: stepId, rootData: rootData, templateId: templateId, \r\n                                    sectionData: sectionData, type: componentName}\"></ng-container>\r\n        </div>\r\n        <!-- <app-list-renderer class=\"app-list-renderer {{is_bootstrap?sectionData.field_style.custom_class_name:''}}\"\r\n            [sectionData]=\"sectionData\" [stepId]=\"stepId\" [templateId]=\"templateId\" [type]=\"componentName\"\r\n            [rootData]=\"rootData\">\r\n        </app-list-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container\r\n        *ngSwitchCase=\"componentName === 'TreeView'\">\r\n        <div class=\"app-tree-renderer {{is_bootstrap?sectionData.field_style.custom_class_name:''}}\">\r\n            <ng-container\r\n                *ngComponentOutlet=\"componentMap['TreeView'] | async; \r\n                                    inputs: {stepId: stepId, rootData: rootData, templateId: templateId, \r\n                                    sectionData: sectionData, type: componentName}\"></ng-container>\r\n        </div>\r\n        <!-- <app-tree-renderer class=\"app-tree-renderer {{is_bootstrap?sectionData.field_style.custom_class_name:''}}\"\r\n            [sectionData]=\"sectionData\" [stepId]=\"stepId\" [templateId]=\"templateId\" [type]=\"componentName\"\r\n            [rootData]=\"rootData\">\r\n        </app-tree-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"componentName === 'Accordion'\">\r\n        <ng-container\r\n                *ngComponentOutlet=\"componentMap['Accordion'] | async; \r\n                                    inputs: {stepId: stepId, rootData: rootData, templateId: templateId, \r\n                                    sectionData: sectionData, type: componentName}\"></ng-container>\r\n        <!-- <app-accordion-renderer class=\"app-accordion-renderer\" [sectionData]=\"sectionData\" [stepId]=\"stepId\"\r\n            [templateId]=\"templateId\" [rootData]=\"rootData\"></app-accordion-renderer> -->\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchCase=\"componentName === 'none'\">\r\n        <section [attr.aria-label]=\"additionalParameter['Aria-Label'] ? additionalParameter['Aria-Label'] : undefined\"\r\n            [attr.role]=\"additionalParameter['Aria-Role']\" id=\"{{ sectionData.section_id }}\"\r\n            class=\"cee-section template-{{ templateId }} step-{{ stepId }}  section-{{stepPosition}} {{is_bootstrap?'row':''}}\">\r\n            <ng-container *ngFor=\"let field of sectionData.fields; index as pos; trackBy: trackBySectionFields;\">\r\n                <app-view-renderer\r\n                    class=\"app-view-renderer-{{ sectionData.section_id }}-{{pos}} {{field.field_style?commonUtil.bootstrapColClass(field.field_style.bootstrap_class_name, is_bootstrap, rootData.templateClass, conditionalUtil.evaluteBootstrapCondition(field)):''}}\"\r\n                    [stepId]=\"stepId\" [field]=\"field\" [position]=\"pos\" [templateId]=\"templateId\" [rootData]=\"rootData\"\r\n                    [mandatoryCondition]=\"mandatoryCondition\" [editableCondition]=\"editableCondition\"\r\n                    [visibleCondition]=\"visibleCondition\" [rowData]=\"generateRowData(field)\">\r\n                </app-view-renderer>\r\n                <div *ngIf=\"field.field_type == 'ContextMenu'\" class=\"field-{{ pos }}\" >\r\n                    <ng-container *ngComponentOutlet=\"componentMap['ContextMenu'] | async; \r\n                                            inputs: {stepId: stepId, rootData: rootData, rowData: generateRowData(field), \r\n                                                fieldData: field, keepState: true}\"></ng-container>\r\n                </div>\r\n                <!-- <app-cee-menucontext *ngIf=\"field.field_type == 'ContextMenu'\" [stepId]=\"stepId\" [fieldData]=\"field\" [rootData]=\"rootData\" [keepState]=\"true\"\r\n                    class=\"field-{{ pos }}\" [rowData]=\"generateRowData(field)\">\r\n                </app-cee-menucontext> -->\r\n            </ng-container>            \r\n\r\n            @if (isRenderStep) {\r\n                <div class=\"inner-step-renderer\" id=\"inner-step-renderer-{{isRenderStep}}\">\r\n                    <ng-container *ngComponentOutlet=\"componentMap['Step'] | async;  inputs: {stepId: isRenderStep}\"></ng-container>\r\n                </div>\r\n            }\r\n        </section>\r\n    </ng-container>\r\n\r\n    <ng-container *ngSwitchDefault>\r\n        <app-dynamic-renderer [moduleName]=\"componentName\"></app-dynamic-renderer>\r\n    </ng-container>\r\n\r\n\r\n    <section *ngIf=\"sectionData.sections && sectionData.sections.length\"\r\n        id=\"section-nested-{{sectionData?sectionData.section_id:''}}\"\r\n        class=\"section-nested-body {{is_bootstrap?'row':''}}\">\r\n        <!-- <app-section-renderer [templateId]=\"templateId\" [sectionData]=\"section\" [stepPosition]=\"stepPosition+'-'+pos\" [sideBarData]=\"sideBarData\"\r\n            [stepId]=\"stepId\" [stepName]=\"stepName\" *ngFor=\"let section of sectionData.sections; let pos = index; trackBy: trackBySections;\"\r\n            class=\"section-child-{{pos}} block-main-{{pos}}-{{stepPosition}}  {{section.section_style?commonUtil.bootstrapColClass(commonUtil.implodeClassName(section.section_style.bootstrap_class_name), is_bootstrap, '', conditionalUtil.evaluteBootstrapCondition(section)):''}}\"\r\n            [rootData]=\"rootData\">\r\n        </app-section-renderer> -->\r\n\r\n        <ng-container *ngIf=\"useContentProjection; else regularSection\">\r\n            <print-preview-wrapper [sectionData]=\"sectionData\">\r\n                <!-- Main content (default slot) -->\r\n                <app-section-renderer \r\n                    [templateId]=\"templateId\" \r\n                    [sectionData]=\"section\" \r\n                    [stepPosition]=\"stepPosition+'-'+pos\" \r\n                    [sideBarData]=\"sideBarData\"\r\n                    [stepId]=\"stepId\" \r\n                    [stepName]=\"stepName\" \r\n                    *ngFor=\"let section of sectionData.sections; let pos = index; trackBy: trackBySections;\"\r\n                    class=\"compliance-form-wrapper section-child-{{pos}} block-main-{{pos}}-{{stepPosition}} {{section.section_style?commonUtil.bootstrapColClass(commonUtil.implodeClassName(section.section_style.bootstrap_class_name), is_bootstrap, '', conditionalUtil.evaluteBootstrapCondition(section)):''}}\"\r\n                    [rootData]=\"rootData\">\r\n                </app-section-renderer>\r\n            </print-preview-wrapper>\r\n        </ng-container>\r\n        \r\n        <ng-template #regularSection>\r\n            <app-section-renderer [templateId]=\"templateId\" [sectionData]=\"section\" [stepPosition]=\"stepPosition+'-'+pos\" [sideBarData]=\"sideBarData\"\r\n                [stepId]=\"stepId\" [stepName]=\"stepName\" *ngFor=\"let section of sectionData.sections; let pos = index; trackBy: trackBySections;\"\r\n                class=\"section-child-{{pos}} block-main-{{pos}}-{{stepPosition}}  {{section.section_style?commonUtil.bootstrapColClass(commonUtil.implodeClassName(section.section_style.bootstrap_class_name), is_bootstrap, '', conditionalUtil.evaluteBootstrapCondition(section)):''}}\"\r\n                [rootData]=\"rootData\">\r\n            </app-section-renderer>\r\n        </ng-template>\r\n\r\n    </section>\r\n\r\n</div>\r\n" }]
    }], () => [{ type: SharedEventsServiceService }, { type: AppDataService }, { type: ApiDataService }, { type: i0.ChangeDetectorRef }], { sectionData: [{
            type: Input
        }], stepPosition: [{
            type: Input
        }], stepId: [{
            type: Input
        }], stepName: [{
            type: Input
        }], templateId: [{
            type: Input
        }], rootData: [{
            type: Input
        }], sideBarData: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(SectionRendererComponent, { className: "SectionRendererComponent", filePath: "lib\\components\\section-renderer\\section-renderer.component.ts", lineNumber: 39 }); })();

var Constant;
(function (Constant) {
    Constant[Constant["listInitialDisplayValue"] = 5] = "listInitialDisplayValue";
    Constant[Constant["listDisplayLoopLength"] = 3] = "listDisplayLoopLength";
    Constant[Constant["listDefaultValue"] = 20] = "listDefaultValue";
})(Constant || (Constant = {}));

let Event$1 = class Event {
    display_type;
    event_id;
    event_name;
    isDefault;
    next_event_id;
    event_params;
};

/**
 * class file mainly used to expose the store
 * data to the project side so that they can
 * access the store values
 */
class NgCEEStoreService {
    appDataQuery;
    appDataStore;
    apiDataStore;
    apiDataQuery;
    constructor(appDataQuery, appDataStore, apiDataStore, apiDataQuery) {
        this.appDataQuery = appDataQuery;
        this.appDataStore = appDataStore;
        this.apiDataStore = apiDataStore;
        this.apiDataQuery = apiDataQuery;
    }
    getAllAppData() {
        return this.appDataQuery.getAll();
    }
    getIndividualAppData(id) {
        return this.appDataQuery.getAll({
            filterBy: entity => entity.id === id
        });
    }
    getAllApiData() {
        return this.apiDataQuery.getAll();
    }
    getIndividualApiData(id) {
        return this.apiDataQuery.getAll({
            filterBy: entity => entity.id === id
        });
    }
    getAppStore() {
        return this.appDataStore.getValue().entities;
    }
    getApiStore() {
        return this.apiDataStore.getValue().entities;
    }
    static ɵfac = function NgCEEStoreService_Factory(t) { return new (t || NgCEEStoreService)(i0.ɵɵinject(AppDataQuery), i0.ɵɵinject(AppDataStore), i0.ɵɵinject(ApiDataStore), i0.ɵɵinject(ApiDataQuery)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: NgCEEStoreService, factory: NgCEEStoreService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NgCEEStoreService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: AppDataQuery }, { type: AppDataStore }, { type: ApiDataStore }, { type: ApiDataQuery }], null); })();

class WfeEncryptionUtil {
    constructor() { }
    getEncryptedData(encryptType, value) {
        switch (encryptType) {
            case 'MD5':
                const md5 = new Md5();
                return md5.appendStr(value).end();
            case 'SHA-256':
                return sha256(value);
            case 'Base64':
                return btoa(value);
            case 'DoubleBase64':
                return btoa(btoa(value));
            default:
                return value;
        }
    }
}

class PDFFormProcessor {
    /**
     * Process HTML content to remove form field borders and make them PDF-friendly
     */
    processContentForPDF(sourceElement) {
        const clonedElement = sourceElement.cloneNode(true);
        // Remove borders from all form elements
        this.removeFormElementBorders(clonedElement);
        // Replace form elements with static content
        this.replaceFormElementsWithStaticContent(clonedElement);
        // Apply PDF-specific styles
        this.applyPDFStyles(clonedElement);
        return clonedElement;
    }
    /**
     * Remove borders from all form elements using CSS
     */
    removeFormElementBorders(container) {
        const style = document.createElement('style');
        style.textContent = `
      /* Remove borders from all form elements */
      input, textarea, select, button {
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
        background: transparent !important;
        -webkit-appearance: none !important;
        -moz-appearance: none !important;
        appearance: none !important;
      }

      /* Specific styling for different input types */
      input[type="text"],
      input[type="email"],
      input[type="password"],
      input[type="number"],
      input[type="tel"],
      input[type="url"],
      input[type="search"],
      input[type="date"],
      input[type="datetime-local"],
      input[type="time"],
      textarea {
        border: none !important;
        background: transparent !important;
        color: #000 !important;
        font-family: inherit !important;
        font-size: inherit !important;
      }

      /* Hide checkbox and radio borders */
      input[type="checkbox"],
      input[type="radio"] {
        border: none !important;
        background: transparent !important;
        width: 0 !important;
        height: 0 !important;
        opacity: 0 !important;
      }

      /* Remove select dropdown styling */
      select {
        border: none !important;
        background: transparent !important;
        color: #000 !important;
        font-family: inherit !important;
        font-size: inherit !important;
      }

      /* Remove button styling */
      button {
        border: none !important;
        background: transparent !important;
        color: #000 !important;
      }
    `;
        container.appendChild(style);
    }
    /**
     * Replace form elements with their static content representation
     */
    replaceFormElementsWithStaticContent(container) {
        // Process input elements
        const inputs = container.querySelectorAll('input');
        inputs.forEach(input => this.processInputElement(input));
        // Process textarea elements
        const textareas = container.querySelectorAll('textarea');
        textareas.forEach(textarea => this.processTextareaElement(textarea));
        // Process select elements
        const selects = container.querySelectorAll('select');
        selects.forEach(select => this.processSelectElement(select));
        // Process button elements
        const buttons = container.querySelectorAll('button');
        buttons.forEach(button => this.processButtonElement(button));
    }
    /**
     * Process individual input elements
     */
    processInputElement(input) {
        const inputType = input.type.toLowerCase();
        switch (inputType) {
            case 'text':
            case 'email':
            case 'password':
            case 'number':
            case 'tel':
            case 'url':
            case 'search':
            case 'date':
            case 'datetime-local':
            case 'time':
                this.replaceTextInputWithSpan(input);
                break;
            case 'checkbox':
                this.replaceCheckboxWithSymbol(input);
                break;
            case 'radio':
                this.replaceRadioWithSymbol(input);
                break;
            case 'submit':
            case 'button':
                this.replaceButtonInputWithSpan(input);
                break;
            case 'hidden':
                // Remove hidden inputs entirely
                input.remove();
                break;
            default:
                this.replaceTextInputWithSpan(input);
                break;
        }
    }
    /**
     * Replace text input with span containing the value
     */
    replaceTextInputWithSpan(input) {
        const span = document.createElement('span');
        const value = input.value || '';
        span.textContent = value || '_'.repeat(Math.max(10, (input.placeholder?.length || 10)));
        span.className = 'pdf-input-replacement';
        // Copy computed styles
        const computedStyle = window.getComputedStyle(input);
        span.style.fontFamily = computedStyle.fontFamily;
        span.style.fontSize = computedStyle.fontSize;
        span.style.fontWeight = value ? 'bold' : 'normal';
        span.style.color = '#000';
        span.style.display = 'inline-block';
        span.style.minWidth = '50px';
        span.style.minHeight = '20px';
        span.style.padding = '2px 4px';
        // Add underline for empty values
        if (!value) {
            span.style.borderBottom = '1px solid #ccc';
            span.style.color = '#ccc';
        }
        input.parentNode?.replaceChild(span, input);
    }
    /**
     * Replace checkbox with check symbol
     */
    replaceCheckboxWithSymbol(input) {
        const span = document.createElement('span');
        span.textContent = input.checked ? '☑' : '☐';
        span.className = 'pdf-checkbox-replacement';
        span.style.fontSize = '16px';
        span.style.color = '#000';
        span.style.display = 'inline-block';
        span.style.width = '20px';
        span.style.height = '20px';
        span.style.textAlign = 'center';
        span.style.lineHeight = '20px';
        span.style.fontFamily = 'Arial, sans-serif';
        input.parentNode?.replaceChild(span, input);
    }
    /**
     * Replace radio button with circle symbol
     */
    replaceRadioWithSymbol(input) {
        const span = document.createElement('span');
        span.textContent = input.checked ? '●' : '○';
        span.className = 'pdf-radio-replacement';
        span.style.fontSize = '16px';
        span.style.color = '#000';
        span.style.display = 'inline-block';
        span.style.width = '20px';
        span.style.height = '20px';
        span.style.textAlign = 'center';
        span.style.lineHeight = '20px';
        span.style.fontFamily = 'Arial, sans-serif';
        input.parentNode?.replaceChild(span, input);
    }
    /**
     * Replace button input with span
     */
    replaceButtonInputWithSpan(input) {
        const span = document.createElement('span');
        span.textContent = input.value || 'Button';
        span.className = 'pdf-button-replacement';
        span.style.padding = '6px 12px';
        span.style.border = '1px solid #000';
        span.style.borderRadius = '4px';
        span.style.backgroundColor = '#f8f9fa';
        span.style.color = '#000';
        span.style.display = 'inline-block';
        span.style.fontWeight = 'bold';
        input.parentNode?.replaceChild(span, input);
    }
    /**
     * Process textarea elements
     */
    processTextareaElement(textarea) {
        const div = document.createElement('div');
        const value = textarea.value || '';
        div.textContent = value || 'Enter text here...';
        div.className = 'pdf-textarea-replacement';
        // Copy computed styles
        const computedStyle = window.getComputedStyle(textarea);
        div.style.fontFamily = computedStyle.fontFamily;
        div.style.fontSize = computedStyle.fontSize;
        div.style.fontWeight = value ? 'bold' : 'normal';
        div.style.color = value ? '#000' : '#ccc';
        div.style.minHeight = '60px';
        div.style.minWidth = '200px';
        div.style.padding = '8px';
        div.style.whiteSpace = 'pre-wrap';
        div.style.wordBreak = 'break-word';
        // Add border for empty values
        if (!value) {
            div.style.border = '1px dashed #ccc';
            div.style.borderRadius = '4px';
            div.style.backgroundColor = '#f9f9f9';
        }
        textarea.parentNode?.replaceChild(div, textarea);
    }
    /**
     * Process select elements
     */
    processSelectElement(select) {
        const span = document.createElement('span');
        const selectedOption = select.selectedOptions.length > 0
            ? select.selectedOptions[0].text
            : 'Select an option';
        span.textContent = selectedOption;
        span.className = 'pdf-select-replacement';
        // Copy computed styles
        const computedStyle = window.getComputedStyle(select);
        span.style.fontFamily = computedStyle.fontFamily;
        span.style.fontSize = computedStyle.fontSize;
        span.style.fontWeight = select.selectedIndex > 0 ? 'bold' : 'normal';
        span.style.color = select.selectedIndex > 0 ? '#000' : '#ccc';
        span.style.display = 'inline-block';
        span.style.minWidth = '100px';
        span.style.padding = '4px 8px';
        span.style.border = '1px solid #ccc';
        span.style.borderRadius = '4px';
        span.style.backgroundColor = '#fff';
        select.parentNode?.replaceChild(span, select);
    }
    /**
     * Process button elements
     */
    processButtonElement(button) {
        const span = document.createElement('span');
        span.textContent = button.textContent || 'Button';
        span.className = 'pdf-button-replacement';
        span.style.padding = '6px 12px';
        span.style.border = '1px solid #000';
        span.style.borderRadius = '4px';
        span.style.backgroundColor = '#f8f9fa';
        span.style.color = '#000';
        span.style.display = 'inline-block';
        span.style.fontWeight = 'bold';
        button.parentNode?.replaceChild(span, button);
    }
    /**
     * Apply PDF-specific styles to the container
     */
    applyPDFStyles(container) {
        // Add global PDF styles
        const style = document.createElement('style');
        style.textContent = `
      /* Global PDF styles */
      * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
      }

      /* Ensure text is visible */
      .pdf-input-replacement,
      .pdf-textarea-replacement,
      .pdf-select-replacement,
      .pdf-button-replacement,
      .pdf-checkbox-replacement,
      .pdf-radio-replacement {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
        font-family: 'Arial', sans-serif !important;
      }

      /* Remove any remaining borders from form-like elements */
      div[class*="mat-"], 
      div[class*="form-"], 
      div[class*="input-"],
      .mat-form-field,
      .mat-input-element {
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
      }

      /* Ensure proper spacing */
      .pdf-input-replacement + .pdf-input-replacement,
      .pdf-textarea-replacement + .pdf-textarea-replacement {
        margin-left: 10px;
      }
    `;
        container.appendChild(style);
        // Set container-level styles
        container.style.fontFamily = 'Arial, sans-serif';
        container.style.fontSize = '12px';
        container.style.lineHeight = '1.4';
        container.style.color = '#000';
        container.style.backgroundColor = '#fff';
    }
    /**
     * Enhanced jsPDF configuration to avoid form element borders
     */
    getOptimizedJsPDFConfig() {
        return {
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4',
            putOnlyUsedFonts: true,
            floatPrecision: 16,
            compress: true,
            html2canvas: {
                allowTaint: true,
                useCORS: true,
                scale: 0.75,
                logging: false,
                letterRendering: true,
                onclone: (clonedDoc) => {
                    this.enhanceClonedDocumentForPDF(clonedDoc);
                }
            },
            margin: [15, 15, 15, 15],
            pageBreak: {
                mode: ['css', 'avoid-all', 'legacy'],
                avoid: ['.avoid-page-break', '.pdf-input-replacement', '.pdf-checkbox-replacement', '.pdf-radio-replacement']
            }
        };
    }
    /**
     * Enhance the cloned document for better PDF rendering
     */
    enhanceClonedDocumentForPDF(clonedDoc) {
        const style = clonedDoc.createElement('style');
        style.textContent = `
      /* Force remove all form element borders in cloned document */
      input, textarea, select, button {
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
        background: transparent !important;
        -webkit-appearance: none !important;
        -moz-appearance: none !important;
        appearance: none !important;
        visibility: hidden !important;
      }

      /* Make replaced elements visible */
      .pdf-input-replacement,
      .pdf-textarea-replacement,
      .pdf-select-replacement,
      .pdf-button-replacement,
      .pdf-checkbox-replacement,
      .pdf-radio-replacement {
        visibility: visible !important;
        display: inline-block !important;
      }

      /* Remove Material Design form field borders */
      .mat-form-field-underline,
      .mat-form-field-ripple,
      .mat-form-field-outline {
        display: none !important;
      }

      .mat-form-field {
        border: none !important;
      }

      /* Hide Angular Material form indicators */
      .mat-form-field-suffix,
      .mat-form-field-prefix,
      .mat-form-field-hint-wrapper {
        display: none !important;
      }
    `;
        clonedDoc.head.appendChild(style);
        // Also hide any form elements that might still be visible
        const formElements = clonedDoc.querySelectorAll('input, textarea, select, button');
        formElements.forEach(element => {
            element.style.display = 'none';
        });
    }
    static ɵfac = function PDFFormProcessor_Factory(t) { return new (t || PDFFormProcessor)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: PDFFormProcessor, factory: PDFFormProcessor.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PDFFormProcessor, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

class BorderlessPDFGeneratorService {
    pdfFormProcessor;
    constructor(pdfFormProcessor) {
        this.pdfFormProcessor = pdfFormProcessor;
    }
    /**
     * Generate PDF without form element borders
     */
    async generateBorderlessPDF(element, options = {}) {
        const targetElement = element instanceof ElementRef ? element.nativeElement : element;
        if (!targetElement) {
            throw new Error('Target element not found for PDF generation');
        }
        // Process element to remove form borders
        const processedElement = this.pdfFormProcessor.processContentForPDF(targetElement);
        // Create PDF with optimized config
        const pdfConfig = {
            ...this.pdfFormProcessor.getOptimizedJsPDFConfig(),
            ...options.pdfConfig
        };
        const pdf = new jsPDF$1(pdfConfig);
        // Set document properties
        if (options.title || options.author || options.subject) {
            pdf.setProperties({
                title: options.title || 'Document',
                author: options.author || 'Generated PDF',
                subject: options.subject || 'PDF Document',
                keywords: options.keywords || 'pdf, borderless, jsPDF'
            });
        }
        // Temporarily append to body for processing
        document.body.appendChild(processedElement);
        processedElement.style.position = 'absolute';
        processedElement.style.left = '-9999px';
        processedElement.style.backgroundColor = '#fff';
        processedElement.style.padding = options.padding || '20px';
        processedElement.style.width = options.width || '210mm';
        try {
            await new Promise((resolve, reject) => {
                pdf.html(processedElement, {
                    ...pdfConfig,
                    windowWidth: options.windowWidth || 1024,
                    width: options.contentWidth || 180,
                    autoPaging: 'text',
                    pageBreak: {
                        mode: ['css', 'avoid-all', 'legacy'],
                        avoid: ['.avoid-page-break', '.pdf-input-replacement', '.pdf-checkbox-replacement']
                    },
                    callback: (doc) => {
                        try {
                            // Add header and footer if provided
                            if (options.header || options.footer) {
                                this.addHeaderFooter(doc, options.header, options.footer);
                            }
                            // Handle different actions
                            this.handlePDFAction(doc, options.action || 'download', options.fileName || 'document.pdf');
                            resolve();
                        }
                        catch (error) {
                            reject(error);
                        }
                    },
                    x: options.x || 15,
                    y: options.y || 15,
                    margin: options.margin || [15, 15, 15, 15]
                });
            });
        }
        finally {
            // Clean up
            if (document.body.contains(processedElement)) {
                document.body.removeChild(processedElement);
            }
        }
    }
    /**
     * Generate PDF from multiple elements without borders
     */
    async generateMultiElementPDF(elements, options = {}) {
        if (!elements || elements.length === 0) {
            throw new Error('No elements provided for PDF generation');
        }
        // Create a container for all elements
        const container = document.createElement('div');
        container.style.width = '100%';
        container.style.backgroundColor = '#fff';
        // Process each element and add to container
        for (const element of elements) {
            const targetElement = element instanceof ElementRef ? element.nativeElement : element;
            if (targetElement) {
                const processedElement = this.pdfFormProcessor.processContentForPDF(targetElement);
                container.appendChild(processedElement);
                // Add page break between elements if specified
                if (options.pageBreakBetweenElements) {
                    const pageBreak = document.createElement('div');
                    pageBreak.style.pageBreakAfter = 'always';
                    pageBreak.style.height = '1px';
                    container.appendChild(pageBreak);
                }
            }
        }
        // Generate PDF from the container
        await this.generateBorderlessPDF(container, options);
    }
    /**
     * Quick method to generate PDF without any borders - simplified API
     */
    async quickBorderlessPDF(element, fileName = 'document.pdf', action = 'download') {
        await this.generateBorderlessPDF(element, {
            fileName,
            action,
            title: fileName.replace('.pdf', ''),
            padding: '15px',
            margin: [10, 10, 10, 10]
        });
    }
    /**
     * Add header and footer to PDF
     */
    addHeaderFooter(doc, header, footer) {
        const totalPages = doc.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
            doc.setPage(i);
            // Add header
            if (header) {
                doc.setFontSize(header.fontSize || 10);
                doc.setTextColor(header.color || 100);
                if (header.text) {
                    doc.text(header.text, header.x || (doc.internal.pageSize.getWidth() / 2), header.y || 15, {
                        align: header.align || 'center'
                    });
                }
                if (header.line) {
                    doc.line(10, header.lineY || 20, doc.internal.pageSize.getWidth() - 10, header.lineY || 20);
                }
            }
            // Add footer
            if (footer) {
                doc.setFontSize(footer.fontSize || 8);
                doc.setTextColor(footer.color || 100);
                if (footer.line) {
                    doc.line(10, doc.internal.pageSize.getHeight() - 20, doc.internal.pageSize.getWidth() - 10, doc.internal.pageSize.getHeight() - 20);
                }
                if (footer.pageNumbers) {
                    doc.text(`Page ${i} of ${totalPages}`, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
                }
                if (footer.text) {
                    doc.text(footer.text, footer.x || 15, footer.y || (doc.internal.pageSize.getHeight() - 10), {
                        align: footer.align || 'left'
                    });
                }
                if (footer.date) {
                    doc.text(`Generated: ${new Date().toLocaleDateString()}`, doc.internal.pageSize.getWidth() - 15, doc.internal.pageSize.getHeight() - 10, { align: 'right' });
                }
            }
        }
    }
    /**
     * Handle different PDF actions
     */
    handlePDFAction(doc, action, fileName) {
        switch (action) {
            case 'download':
                doc.save(fileName);
                break;
            case 'print':
                doc.autoPrint();
                const printBlob = doc.output('blob');
                const printUrl = URL.createObjectURL(printBlob);
                window.open(printUrl, '_blank');
                setTimeout(() => URL.revokeObjectURL(printUrl), 1000);
                break;
            case 'preview':
                const previewBlob = doc.output('blob');
                const previewUrl = URL.createObjectURL(previewBlob);
                window.open(previewUrl, '_blank');
                setTimeout(() => URL.revokeObjectURL(previewUrl), 1000);
                break;
            default:
                console.warn('Unknown PDF action:', action);
                doc.save(fileName);
        }
    }
    static ɵfac = function BorderlessPDFGeneratorService_Factory(t) { return new (t || BorderlessPDFGeneratorService)(i0.ɵɵinject(PDFFormProcessor)); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: BorderlessPDFGeneratorService, factory: BorderlessPDFGeneratorService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(BorderlessPDFGeneratorService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], () => [{ type: PDFFormProcessor }], null); })();

class WebworkerService {
    // tslint:disable-next-line
    workerFunctionToUrlMap = new WeakMap();
    promiseToWorkerMap = new WeakMap();
    /**
     * <p>Method that runs the given function with the given data.</p>
     * @param workerFunction function to run on the web worker context.
     * @param data data to pass to the web worker context. <b>IMPORTANT</b>:
     * the function must be self-contained, meaning that no external functions or
     * libraries can be passed through this parameter.
     */
    run(workerFunction, data) {
        const url = this.getOrCreateWorkerUrl(workerFunction);
        return this.runUrl(url, data);
    }
    /**
     * <p>Method that runs the given <i>ObjectURL</i> with the given data.</p>
     * @param url <i>ObjectURL</i> to run on the web worker context.
     * @param data data to pass to the web worker context. <b>IMPORTANT</b>:
     * the function must be self-contained, meaning that no external functions or
     * libraries can be passed through this parameter.
     */
    runUrl(url, data) {
        const worker = new Worker(url);
        const promise = this.createPromiseForWorker(worker, data);
        const promiseCleaner = this.createPromiseCleaner(promise);
        this.promiseToWorkerMap.set(promise, worker);
        promise.then(promiseCleaner).catch(promiseCleaner);
        return promise;
    }
    // tslint:disable
    /**
     * <p>Method that terminates the given <i>Promise</i> and removes it from the
     * internal service maps.</p>
     * @param promise promise to terminate.
     */
    terminate(promise) {
        return this.removePromise(promise);
    }
    /**
     * <p>Method that retrieves the <i>web worker</i> to which the given <i>Promise</i>
     * belongs to.
     * @param promise promise whose <i>web worker</i> we want to find.
     */
    getWorker(promise) {
        return this.promiseToWorkerMap.get(promise);
    }
    // tslint:enable
    /**
     * <p>Method that handles the promise creation for the given <i>web worker</i> with
     * the given input data.</p>
     * @param worker worker for which the promise will be created.
     * @param data data that will be passed into the worker object.
     */
    createPromiseForWorker(worker, data) {
        return new Promise((resolve, reject) => {
            worker.addEventListener('message', (event) => resolve(event.data));
            worker.addEventListener('error', reject);
            worker.postMessage(data);
        });
    }
    // tslint:disable
    /**
     * <p>Method that allocates a <i>web worker</i> <i>ObjectURL</i> for the given function.
     * It's used to create caches for the <i>(function, workerUrl)</i> pairs in order to avoid
     * creating the urls more than once.</p>
     * @param fn function whose worker we want to allocate.
     */
    getOrCreateWorkerUrl(fn) {
        if (!this.workerFunctionToUrlMap.has(fn)) {
            const url = this.createWorkerUrl(fn);
            this.workerFunctionToUrlMap.set(fn, url);
            return url;
        }
        return this.workerFunctionToUrlMap.get(fn);
    }
    /**
     * <p>Method that creates a <i>web worker</i> <i>ObjectURL</i> from the given
     * <i>Function</i> object.</p>
     * @param resolve function the <i>web worker</i> will run.
     */
    createWorkerUrl(resolve) {
        const resolveString = resolve.toString();
        // The template is basically an addEventListener attachment that creates a
        // closure (IIFE*) with the provided function and invokes it with the provided
        // data.
        // * IIFE stands for immediately Immediately-Invoked Function Expression
        // Removed the postMessage from this template in order to allow worker functions
        // to use asynchronous functions and resolve whenever they need to.
        const webWorkerTemplate = `
            self.addEventListener('message', function(e) {
                ((${resolveString})(e.data));
            });
        `;
        const blob = new Blob([webWorkerTemplate], { type: 'text/javascript' });
        return URL.createObjectURL(blob);
    }
    // tslint:enable
    /**
     * <p>Method that creates a function that removes the given promise from the
     * service context.</p>
     * @param promise promise the cleaner function will be created for.
     */
    createPromiseCleaner(promise) {
        return (event) => {
            this.removePromise(promise);
            return event;
        };
    }
    /**
     * <p>Method that removes the given promise from the service context.
     * It also terminates the associated worker in case it exists.</p>
     * @param promise promise to be removed from the service context.
     */
    removePromise(promise) {
        const worker = this.promiseToWorkerMap.get(promise);
        if (worker) {
            worker.terminate();
        }
        this.promiseToWorkerMap.delete(promise);
        return promise;
    }
    static ɵfac = function WebworkerService_Factory(t) { return new (t || WebworkerService)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WebworkerService, factory: WebworkerService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WebworkerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

class MaterialComponentModule {
    static ɵfac = function MaterialComponentModule_Factory(t) { return new (t || MaterialComponentModule)(); };
    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: MaterialComponentModule });
    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [MatAutocompleteModule,
            MatSlideToggleModule,
            MatDatepickerModule,
            MatNativeDateModule,
            MatInputModule,
            MatFormFieldModule,
            MatDialogModule,
            MatSnackBarModule,
            MatTooltipModule,
            MatIconModule,
            MatMenuModule,
            MatTableModule,
            MatCheckboxModule,
            MatRadioModule,
            MatPaginatorModule,
            MatSortModule,
            MatTabsModule,
            MatTreeModule,
            MatButtonModule,
            MatSelectModule, MatAutocompleteModule,
            MatSlideToggleModule,
            MatDatepickerModule,
            MatNativeDateModule,
            MatInputModule,
            MatFormFieldModule,
            MatDialogModule,
            MatSnackBarModule,
            MatTooltipModule,
            MatIconModule,
            MatMenuModule,
            MatTableModule,
            MatCheckboxModule,
            MatRadioModule,
            MatPaginatorModule,
            MatSortModule,
            MatTabsModule,
            MatTreeModule,
            MatButtonModule,
            MatSelectModule] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MaterialComponentModule, [{
        type: NgModule,
        args: [{
                imports: [
                    MatAutocompleteModule,
                    MatSlideToggleModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatInputModule,
                    MatFormFieldModule,
                    MatDialogModule,
                    MatSnackBarModule,
                    MatTooltipModule,
                    MatIconModule,
                    MatMenuModule,
                    MatTableModule,
                    MatCheckboxModule,
                    MatRadioModule,
                    MatPaginatorModule,
                    MatSortModule,
                    MatTabsModule,
                    MatTreeModule,
                    MatButtonModule,
                    MatSelectModule
                ],
                exports: [
                    MatAutocompleteModule,
                    MatSlideToggleModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatInputModule,
                    MatFormFieldModule,
                    MatDialogModule,
                    MatSnackBarModule,
                    MatTooltipModule,
                    MatIconModule,
                    MatMenuModule,
                    MatTableModule,
                    MatCheckboxModule,
                    MatRadioModule,
                    MatPaginatorModule,
                    MatSortModule,
                    MatTabsModule,
                    MatTreeModule,
                    MatButtonModule,
                    MatSelectModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(MaterialComponentModule, { imports: [MatAutocompleteModule,
        MatSlideToggleModule,
        MatDatepickerModule,
        MatNativeDateModule,
        MatInputModule,
        MatFormFieldModule,
        MatDialogModule,
        MatSnackBarModule,
        MatTooltipModule,
        MatIconModule,
        MatMenuModule,
        MatTableModule,
        MatCheckboxModule,
        MatRadioModule,
        MatPaginatorModule,
        MatSortModule,
        MatTabsModule,
        MatTreeModule,
        MatButtonModule,
        MatSelectModule], exports: [MatAutocompleteModule,
        MatSlideToggleModule,
        MatDatepickerModule,
        MatNativeDateModule,
        MatInputModule,
        MatFormFieldModule,
        MatDialogModule,
        MatSnackBarModule,
        MatTooltipModule,
        MatIconModule,
        MatMenuModule,
        MatTableModule,
        MatCheckboxModule,
        MatRadioModule,
        MatPaginatorModule,
        MatSortModule,
        MatTabsModule,
        MatTreeModule,
        MatButtonModule,
        MatSelectModule] }); })();

function SnackbarRendererComponent_mat_progress_bar_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-progress-bar", 3);
} }
function SnackbarRendererComponent_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 4);
    i0.ɵɵlistener("click", function SnackbarRendererComponent_button_3_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.snackBar.dismiss()); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(ctx_r1.data.actionButton);
} }
class SnackbarRendererComponent {
    data;
    http;
    router;
    appDataService;
    apiDataService;
    snackBar;
    sharedEventsService;
    wfeStepLoaderService;
    stepId;
    templateId;
    rootData;
    rowData;
    constructor(data, http, router, appDataService, apiDataService, snackBar, sharedEventsService, wfeStepLoaderService) {
        this.data = data;
        this.http = http;
        this.router = router;
        this.appDataService = appDataService;
        this.apiDataService = apiDataService;
        this.snackBar = snackBar;
        this.sharedEventsService = sharedEventsService;
        this.wfeStepLoaderService = wfeStepLoaderService;
    }
    static ɵfac = function SnackbarRendererComponent_Factory(t) { return new (t || SnackbarRendererComponent)(i0.ɵɵdirectiveInject(MAT_SNACK_BAR_DATA), i0.ɵɵdirectiveInject(i9.HttpClient), i0.ɵɵdirectiveInject(i11.Router), i0.ɵɵdirectiveInject(AppDataService), i0.ɵɵdirectiveInject(ApiDataService), i0.ɵɵdirectiveInject(i8.MatSnackBar), i0.ɵɵdirectiveInject(SharedEventsServiceService), i0.ɵɵdirectiveInject(WfeStepLoaderService)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SnackbarRendererComponent, selectors: [["app-snackbar-renderer"]], inputs: { stepId: "stepId", templateId: "templateId", rootData: "rootData", rowData: "rowData" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 4, vars: 3, consts: [[3, "innerHTML"], ["class", "md-warn", "mode", "indeterminate", 4, "ngIf"], ["mat-raised-button", "", 3, "click", 4, "ngIf"], ["mode", "indeterminate", 1, "md-warn"], ["mat-raised-button", "", 3, "click"]], template: function SnackbarRendererComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementContainerStart(0);
            i0.ɵɵelement(1, "div", 0);
            i0.ɵɵtemplate(2, SnackbarRendererComponent_mat_progress_bar_2_Template, 1, 0, "mat-progress-bar", 1)(3, SnackbarRendererComponent_button_3_Template, 2, 1, "button", 2);
            i0.ɵɵelementContainerEnd();
        } if (rf & 2) {
            i0.ɵɵadvance();
            i0.ɵɵproperty("innerHTML", ctx.data.html, i0.ɵɵsanitizeHtml);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.data.progressBar);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.data.actionButton && ctx.data.actionButton != "");
        } }, dependencies: [MatProgressBarModule, i8$2.MatProgressBar, CommonModule, i13.NgIf], styles: [".mat-toolbar[_ngcontent-%COMP%]   .mat-primary[_ngcontent-%COMP%]{font-size:small}.toast-center-center[_ngcontent-%COMP%]{top:50%;left:50%;transform:translate(-50%,-50%)}.toast-top-center[_ngcontent-%COMP%]{top:0;right:0;width:100%}.toast-bottom-center[_ngcontent-%COMP%]{bottom:0;right:0;width:100%}.toast-top-full-width[_ngcontent-%COMP%]{top:0;right:0;width:100%}.toast-bottom-full-width[_ngcontent-%COMP%]{bottom:0;right:0;width:100%}.toast-top-left[_ngcontent-%COMP%]{top:12px;left:12px}.toast-top-right[_ngcontent-%COMP%]{top:12px;right:12px}.toast-bottom-right[_ngcontent-%COMP%]{right:12px;bottom:12px}.toast-bottom-left[_ngcontent-%COMP%]{bottom:12px;left:12px}.toast-title[_ngcontent-%COMP%]{font-weight:700}.toast-message[_ngcontent-%COMP%]{word-wrap:break-word}.toast-message[_ngcontent-%COMP%]   a[_ngcontent-%COMP%], .toast-message[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{color:#fff}.toast-message[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:#ccc;text-decoration:none}.toast-close-button[_ngcontent-%COMP%]{position:relative;right:-.3em;top:-.3em;float:right;font-size:20px;font-weight:700;color:#fff;text-shadow:0 1px 0 #ffffff}.toast-close-button[_ngcontent-%COMP%]:hover, .toast-close-button[_ngcontent-%COMP%]:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.4}button.toast-close-button[_ngcontent-%COMP%]{padding:0;cursor:pointer;background:transparent;border:0}.toast-container[_ngcontent-%COMP%]{pointer-events:none;position:fixed;z-index:999999}.toast-container[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]{box-sizing:border-box}.toast-container[_ngcontent-%COMP%]   .ngx-toastr[_ngcontent-%COMP%]{position:relative;overflow:hidden;margin:0 0 6px;padding:15px 15px 15px 50px;width:300px;border-radius:3px;background-position:15px center;background-repeat:no-repeat;background-size:24px;box-shadow:0 0 12px #999;color:#fff}.toast-container[_ngcontent-%COMP%]   .ngx-toastr[_ngcontent-%COMP%]:hover{box-shadow:0 0 12px #000;opacity:1;cursor:pointer}.toast-info[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1MTIgNTEyJyB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTI1NiA4QzExOS4wNDMgOCA4IDExOS4wODMgOCAyNTZjMCAxMzYuOTk3IDExMS4wNDMgMjQ4IDI0OCAyNDhzMjQ4LTExMS4wMDMgMjQ4LTI0OEM1MDQgMTE5LjA4MyAzOTIuOTU3IDggMjU2IDh6bTAgMTEwYzIzLjE5NiAwIDQyIDE4LjgwNCA0MiA0MnMtMTguODA0IDQyLTQyIDQyLTQyLTE4LjgwNC00Mi00MiAxOC44MDQtNDIgNDItNDJ6bTU2IDI1NGMwIDYuNjI3LTUuMzczIDEyLTEyIDEyaC04OGMtNi42MjcgMC0xMi01LjM3My0xMi0xMnYtMjRjMC02LjYyNyA1LjM3My0xMiAxMi0xMmgxMnYtNjRoLTEyYy02LjYyNyAwLTEyLTUuMzczLTEyLTEydi0yNGMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDY0YzYuNjI3IDAgMTIgNS4zNzMgMTIgMTJ2MTAwaDEyYzYuNjI3IDAgMTIgNS4zNzMgMTIgMTJ2MjR6Jy8+PC9zdmc+)}.toast-error[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1MTIgNTEyJyB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTI1NiA4QzExOSA4IDggMTE5IDggMjU2czExMSAyNDggMjQ4IDI0OCAyNDgtMTExIDI0OC0yNDhTMzkzIDggMjU2IDh6bTEyMS42IDMxMy4xYzQuNyA0LjcgNC43IDEyLjMgMCAxN0wzMzggMzc3LjZjLTQuNyA0LjctMTIuMyA0LjctMTcgMEwyNTYgMzEybC02NS4xIDY1LjZjLTQuNyA0LjctMTIuMyA0LjctMTcgMEwxMzQuNCAzMzhjLTQuNy00LjctNC43LTEyLjMgMC0xN2w2NS42LTY1LTY1LjYtNjUuMWMtNC43LTQuNy00LjctMTIuMyAwLTE3bDM5LjYtMzkuNmM0LjctNC43IDEyLjMtNC43IDE3IDBsNjUgNjUuNyA2NS4xLTY1LjZjNC43LTQuNyAxMi4zLTQuNyAxNyAwbDM5LjYgMzkuNmM0LjcgNC43IDQuNyAxMi4zIDAgMTdMMzEyIDI1Nmw2NS42IDY1LjF6Jy8+PC9zdmc+)}.toast-success[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1MTIgNTEyJyB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTE3My44OTggNDM5LjQwNGwtMTY2LjQtMTY2LjRjLTkuOTk3LTkuOTk3LTkuOTk3LTI2LjIwNiAwLTM2LjIwNGwzNi4yMDMtMzYuMjA0YzkuOTk3LTkuOTk4IDI2LjIwNy05Ljk5OCAzNi4yMDQgMEwxOTIgMzEyLjY5IDQzMi4wOTUgNzIuNTk2YzkuOTk3LTkuOTk3IDI2LjIwNy05Ljk5NyAzNi4yMDQgMGwzNi4yMDMgMzYuMjA0YzkuOTk3IDkuOTk3IDkuOTk3IDI2LjIwNiAwIDM2LjIwNGwtMjk0LjQgMjk0LjQwMWMtOS45OTggOS45OTctMjYuMjA3IDkuOTk3LTM2LjIwNC0uMDAxeicvPjwvc3ZnPg==)}.toast-warning[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1NzYgNTEyJyB3aWR0aD0nNTc2JyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTU2OS41MTcgNDQwLjAxM0M1ODcuOTc1IDQ3Mi4wMDcgNTY0LjgwNiA1MTIgNTI3Ljk0IDUxMkg0OC4wNTRjLTM2LjkzNyAwLTU5Ljk5OS00MC4wNTUtNDEuNTc3LTcxLjk4N0wyNDYuNDIzIDIzLjk4NWMxOC40NjctMzIuMDA5IDY0LjcyLTMxLjk1MSA4My4xNTQgMGwyMzkuOTQgNDE2LjAyOHpNMjg4IDM1NGMtMjUuNDA1IDAtNDYgMjAuNTk1LTQ2IDQ2czIwLjU5NSA0NiA0NiA0NiA0Ni0yMC41OTUgNDYtNDYtMjAuNTk1LTQ2LTQ2LTQ2em0tNDMuNjczLTE2NS4zNDZsNy40MTggMTM2Yy4zNDcgNi4zNjQgNS42MDkgMTEuMzQ2IDExLjk4MiAxMS4zNDZoNDguNTQ2YzYuMzczIDAgMTEuNjM1LTQuOTgyIDExLjk4Mi0xMS4zNDZsNy40MTgtMTM2Yy4zNzUtNi44NzQtNS4wOTgtMTIuNjU0LTExLjk4Mi0xMi42NTRoLTYzLjM4M2MtNi44ODQgMC0xMi4zNTYgNS43OC0xMS45ODEgMTIuNjU0eicvPjwvc3ZnPg==)}.toast-container.toast-top-center[_ngcontent-%COMP%]   .ngx-toastr[_ngcontent-%COMP%], .toast-container.toast-bottom-center[_ngcontent-%COMP%]   .ngx-toastr[_ngcontent-%COMP%]{width:300px;margin-left:auto;margin-right:auto}.toast-container.toast-top-full-width[_ngcontent-%COMP%]   .ngx-toastr[_ngcontent-%COMP%], .toast-container.toast-bottom-full-width[_ngcontent-%COMP%]   .ngx-toastr[_ngcontent-%COMP%]{width:96%;margin-left:auto;margin-right:auto}.ngx-toastr[_ngcontent-%COMP%]{background-color:#030303;pointer-events:auto}.toast-success[_ngcontent-%COMP%]{background-color:#51a351}.toast-error[_ngcontent-%COMP%]{background-color:#bd362f}.toast-info[_ngcontent-%COMP%]{background-color:#2f96b4}.toast-warning[_ngcontent-%COMP%]{background-color:#f89406}.toast-progress[_ngcontent-%COMP%]{position:absolute;left:0;bottom:0;height:4px;background-color:#000;opacity:.4}@media all and (max-width: 240px){.toast-container[_ngcontent-%COMP%]   .ngx-toastr.div[_ngcontent-%COMP%]{padding:8px 8px 8px 50px;width:11em}.toast-container[_ngcontent-%COMP%]   .toast-close-button[_ngcontent-%COMP%]{right:-.2em;top:-.2em}}@media all and (min-width: 241px) and (max-width: 480px){.toast-container[_ngcontent-%COMP%]   .ngx-toastr.div[_ngcontent-%COMP%]{padding:8px 8px 8px 50px;width:18em}.toast-container[_ngcontent-%COMP%]   .toast-close-button[_ngcontent-%COMP%]{right:-.2em;top:-.2em}}@media all and (min-width: 481px) and (max-width: 768px){.toast-container[_ngcontent-%COMP%]   .ngx-toastr.div[_ngcontent-%COMP%]{padding:15px 15px 15px 50px;width:25em}}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SnackbarRendererComponent, [{
        type: Component,
        args: [{ selector: 'app-snackbar-renderer', standalone: true, imports: [MatProgressBarModule, CommonModule], template: "<ng-container>\r\n    <div [innerHTML]=\"data.html\"></div>\r\n    <mat-progress-bar *ngIf=\"data.progressBar\" class=\"md-warn\" mode=\"indeterminate\"></mat-progress-bar>\r\n    <button *ngIf=\"data.actionButton && data.actionButton != ''\" mat-raised-button (click)=\"snackBar.dismiss()\">{{data.actionButton}}</button>\r\n</ng-container>", styles: [".mat-toolbar .mat-primary{font-size:small}.toast-center-center{top:50%;left:50%;transform:translate(-50%,-50%)}.toast-top-center{top:0;right:0;width:100%}.toast-bottom-center{bottom:0;right:0;width:100%}.toast-top-full-width{top:0;right:0;width:100%}.toast-bottom-full-width{bottom:0;right:0;width:100%}.toast-top-left{top:12px;left:12px}.toast-top-right{top:12px;right:12px}.toast-bottom-right{right:12px;bottom:12px}.toast-bottom-left{bottom:12px;left:12px}.toast-title{font-weight:700}.toast-message{word-wrap:break-word}.toast-message a,.toast-message label{color:#fff}.toast-message a:hover{color:#ccc;text-decoration:none}.toast-close-button{position:relative;right:-.3em;top:-.3em;float:right;font-size:20px;font-weight:700;color:#fff;text-shadow:0 1px 0 #ffffff}.toast-close-button:hover,.toast-close-button:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.4}button.toast-close-button{padding:0;cursor:pointer;background:transparent;border:0}.toast-container{pointer-events:none;position:fixed;z-index:999999}.toast-container *{box-sizing:border-box}.toast-container .ngx-toastr{position:relative;overflow:hidden;margin:0 0 6px;padding:15px 15px 15px 50px;width:300px;border-radius:3px;background-position:15px center;background-repeat:no-repeat;background-size:24px;box-shadow:0 0 12px #999;color:#fff}.toast-container .ngx-toastr:hover{box-shadow:0 0 12px #000;opacity:1;cursor:pointer}.toast-info{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1MTIgNTEyJyB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTI1NiA4QzExOS4wNDMgOCA4IDExOS4wODMgOCAyNTZjMCAxMzYuOTk3IDExMS4wNDMgMjQ4IDI0OCAyNDhzMjQ4LTExMS4wMDMgMjQ4LTI0OEM1MDQgMTE5LjA4MyAzOTIuOTU3IDggMjU2IDh6bTAgMTEwYzIzLjE5NiAwIDQyIDE4LjgwNCA0MiA0MnMtMTguODA0IDQyLTQyIDQyLTQyLTE4LjgwNC00Mi00MiAxOC44MDQtNDIgNDItNDJ6bTU2IDI1NGMwIDYuNjI3LTUuMzczIDEyLTEyIDEyaC04OGMtNi42MjcgMC0xMi01LjM3My0xMi0xMnYtMjRjMC02LjYyNyA1LjM3My0xMiAxMi0xMmgxMnYtNjRoLTEyYy02LjYyNyAwLTEyLTUuMzczLTEyLTEydi0yNGMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDY0YzYuNjI3IDAgMTIgNS4zNzMgMTIgMTJ2MTAwaDEyYzYuNjI3IDAgMTIgNS4zNzMgMTIgMTJ2MjR6Jy8+PC9zdmc+)}.toast-error{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1MTIgNTEyJyB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTI1NiA4QzExOSA4IDggMTE5IDggMjU2czExMSAyNDggMjQ4IDI0OCAyNDgtMTExIDI0OC0yNDhTMzkzIDggMjU2IDh6bTEyMS42IDMxMy4xYzQuNyA0LjcgNC43IDEyLjMgMCAxN0wzMzggMzc3LjZjLTQuNyA0LjctMTIuMyA0LjctMTcgMEwyNTYgMzEybC02NS4xIDY1LjZjLTQuNyA0LjctMTIuMyA0LjctMTcgMEwxMzQuNCAzMzhjLTQuNy00LjctNC43LTEyLjMgMC0xN2w2NS42LTY1LTY1LjYtNjUuMWMtNC43LTQuNy00LjctMTIuMyAwLTE3bDM5LjYtMzkuNmM0LjctNC43IDEyLjMtNC43IDE3IDBsNjUgNjUuNyA2NS4xLTY1LjZjNC43LTQuNyAxMi4zLTQuNyAxNyAwbDM5LjYgMzkuNmM0LjcgNC43IDQuNyAxMi4zIDAgMTdMMzEyIDI1Nmw2NS42IDY1LjF6Jy8+PC9zdmc+)}.toast-success{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1MTIgNTEyJyB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTE3My44OTggNDM5LjQwNGwtMTY2LjQtMTY2LjRjLTkuOTk3LTkuOTk3LTkuOTk3LTI2LjIwNiAwLTM2LjIwNGwzNi4yMDMtMzYuMjA0YzkuOTk3LTkuOTk4IDI2LjIwNy05Ljk5OCAzNi4yMDQgMEwxOTIgMzEyLjY5IDQzMi4wOTUgNzIuNTk2YzkuOTk3LTkuOTk3IDI2LjIwNy05Ljk5NyAzNi4yMDQgMGwzNi4yMDMgMzYuMjA0YzkuOTk3IDkuOTk3IDkuOTk3IDI2LjIwNiAwIDM2LjIwNGwtMjk0LjQgMjk0LjQwMWMtOS45OTggOS45OTctMjYuMjA3IDkuOTk3LTM2LjIwNC0uMDAxeicvPjwvc3ZnPg==)}.toast-warning{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1NzYgNTEyJyB3aWR0aD0nNTc2JyBoZWlnaHQ9JzUxMic+PHBhdGggZmlsbD0ncmdiKDI1NSwyNTUsMjU1KScgZD0nTTU2OS41MTcgNDQwLjAxM0M1ODcuOTc1IDQ3Mi4wMDcgNTY0LjgwNiA1MTIgNTI3Ljk0IDUxMkg0OC4wNTRjLTM2LjkzNyAwLTU5Ljk5OS00MC4wNTUtNDEuNTc3LTcxLjk4N0wyNDYuNDIzIDIzLjk4NWMxOC40NjctMzIuMDA5IDY0LjcyLTMxLjk1MSA4My4xNTQgMGwyMzkuOTQgNDE2LjAyOHpNMjg4IDM1NGMtMjUuNDA1IDAtNDYgMjAuNTk1LTQ2IDQ2czIwLjU5NSA0NiA0NiA0NiA0Ni0yMC41OTUgNDYtNDYtMjAuNTk1LTQ2LTQ2LTQ2em0tNDMuNjczLTE2NS4zNDZsNy40MTggMTM2Yy4zNDcgNi4zNjQgNS42MDkgMTEuMzQ2IDExLjk4MiAxMS4zNDZoNDguNTQ2YzYuMzczIDAgMTEuNjM1LTQuOTgyIDExLjk4Mi0xMS4zNDZsNy40MTgtMTM2Yy4zNzUtNi44NzQtNS4wOTgtMTIuNjU0LTExLjk4Mi0xMi42NTRoLTYzLjM4M2MtNi44ODQgMC0xMi4zNTYgNS43OC0xMS45ODEgMTIuNjU0eicvPjwvc3ZnPg==)}.toast-container.toast-top-center .ngx-toastr,.toast-container.toast-bottom-center .ngx-toastr{width:300px;margin-left:auto;margin-right:auto}.toast-container.toast-top-full-width .ngx-toastr,.toast-container.toast-bottom-full-width .ngx-toastr{width:96%;margin-left:auto;margin-right:auto}.ngx-toastr{background-color:#030303;pointer-events:auto}.toast-success{background-color:#51a351}.toast-error{background-color:#bd362f}.toast-info{background-color:#2f96b4}.toast-warning{background-color:#f89406}.toast-progress{position:absolute;left:0;bottom:0;height:4px;background-color:#000;opacity:.4}@media all and (max-width: 240px){.toast-container .ngx-toastr.div{padding:8px 8px 8px 50px;width:11em}.toast-container .toast-close-button{right:-.2em;top:-.2em}}@media all and (min-width: 241px) and (max-width: 480px){.toast-container .ngx-toastr.div{padding:8px 8px 8px 50px;width:18em}.toast-container .toast-close-button{right:-.2em;top:-.2em}}@media all and (min-width: 481px) and (max-width: 768px){.toast-container .ngx-toastr.div{padding:15px 15px 15px 50px;width:25em}}\n"] }]
    }], () => [{ type: undefined, decorators: [{
                type: Inject,
                args: [MAT_SNACK_BAR_DATA]
            }] }, { type: i9.HttpClient }, { type: i11.Router }, { type: AppDataService }, { type: ApiDataService }, { type: i8.MatSnackBar }, { type: SharedEventsServiceService }, { type: WfeStepLoaderService }], { stepId: [{
            type: Input
        }], templateId: [{
            type: Input
        }], rootData: [{
            type: Input
        }], rowData: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(SnackbarRendererComponent, { className: "SnackbarRendererComponent", filePath: "lib\\components\\snackbar-renderer\\snackbar-renderer.component.ts", lineNumber: 18 }); })();

function ImageCropModalComponent_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 8);
    i0.ɵɵlistener("click", function ImageCropModalComponent_button_8_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.zoomOut()); });
    i0.ɵɵtext(1, "Zoom Out");
    i0.ɵɵelementEnd();
} }
function ImageCropModalComponent_button_9_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 8);
    i0.ɵɵlistener("click", function ImageCropModalComponent_button_9_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r3); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.zoomIn()); });
    i0.ɵɵtext(1, "Zoom In");
    i0.ɵɵelementEnd();
} }
class ImageCropModalComponent {
    dialogRef;
    sanitizer;
    data;
    maintainAspectRatio = false;
    cropperStaticWidth = 170;
    cropperStaticHeight = 170;
    cropperMinWidth = 170;
    cropperMinHeight = 170;
    onlyScaleDown = true;
    roundCropper = true;
    imageChangedEvent = '';
    croppedImage = '';
    canvasRotation = 0;
    rotation;
    translateH = 0;
    translateV = 0;
    scale = 1;
    aspectRatio = 1 / 1;
    showCropper = false;
    containWithinAspectRatio = false;
    transform = {
        translateUnit: 'px'
    };
    imageURL;
    loading = false;
    allowMoveImage = true;
    hidden = false;
    ppFormat = 'png';
    additionalParameter;
    allowZoomImage = true;
    constructor(dialogRef, sanitizer, data) {
        this.dialogRef = dialogRef;
        this.sanitizer = sanitizer;
        this.data = data;
        // console.log(data);
        this.imageChangedEvent = data.message;
        this.additionalParameter = data.additionalParameter;
        this.maintainAspectRatio = this.additionalParameter && this.additionalParameter['CEE_PP_MaintainAspectRatio'] && this.additionalParameter['CEE_PP_MaintainAspectRatio'].toLowerCase() == 'true' ? true : false;
        this.aspectRatio = this.additionalParameter && this.additionalParameter['CEE_PP_AspectRatio'] ? this.additionalParameter['CEE_PP_AspectRatio'] : this.aspectRatio;
        this.ppFormat = this.additionalParameter && this.additionalParameter['CEE_PP_Format'] ? this.additionalParameter['CEE_PP_Format'] : this.ppFormat;
        this.cropperMinWidth = this.additionalParameter && this.additionalParameter['CEE_PP_CropperMinWidth'] ? Number(this.additionalParameter['CEE_PP_CropperMinWidth']) : this.cropperMinWidth;
        this.cropperMinHeight = this.additionalParameter && this.additionalParameter['CEE_PP_CropperMinHeight'] ? Number(this.additionalParameter['CEE_PP_CropperMinHeight']) : this.cropperMinHeight;
        this.roundCropper = this.additionalParameter && this.additionalParameter['CEE_PP_RoundCropper'] && this.additionalParameter['CEE_PP_RoundCropper'].toLowerCase() == 'true' ? true : false;
        this.allowMoveImage = this.additionalParameter && this.additionalParameter['CEE_AllowMoveImage'] && this.additionalParameter['CEE_AllowMoveImage'].toLowerCase() == 'true' ? true : false;
        this.allowZoomImage = this.additionalParameter && this.additionalParameter['CEE_AllowZoomImage'] && this.additionalParameter['CEE_AllowZoomImage'].toLowerCase() == 'true' ? true : false;
        // console.log("format: ",this.ppFormat)
        if (data.config && data.config.disableClose) {
            dialogRef.disableClose = data.config.disableClose;
        }
    }
    onPostiveClick() {
        this.dialogRef.close(true);
    }
    onNegativeClick() {
        this.dialogRef.close(false);
    }
    // #####################################
    imageCropped(event) {
        this.croppedImage = this.sanitizer.bypassSecurityTrustUrl(event.objectUrl || event.base64 || '');
        // console.log(event);
    }
    imageLoaded() {
        this.showCropper = true;
        // console.log('Image loaded');
    }
    cropperReady(sourceImageDimensions) {
        // console.log('Cropper ready', sourceImageDimensions);
        this.loading = false;
    }
    loadImageFailed() {
        console.error('Load image failed');
    }
    rotateLeft() {
        this.loading = true;
        setTimeout(() => {
            this.canvasRotation--;
            this.flipAfterRotate();
        });
    }
    rotateRight() {
        this.loading = true;
        setTimeout(() => {
            this.canvasRotation++;
            this.flipAfterRotate();
        });
    }
    moveLeft() {
        this.transform = {
            ...this.transform,
            translateH: ++this.translateH
        };
    }
    moveRight() {
        this.transform = {
            ...this.transform,
            translateH: --this.translateH
        };
    }
    moveTop() {
        this.transform = {
            ...this.transform,
            translateV: ++this.translateV
        };
    }
    moveBottom() {
        this.transform = {
            ...this.transform,
            translateV: --this.translateV
        };
    }
    flipAfterRotate() {
        const flippedH = this.transform.flipH;
        const flippedV = this.transform.flipV;
        this.transform = {
            ...this.transform,
            flipH: flippedV,
            flipV: flippedH
        };
        this.translateH = 0;
        this.translateV = 0;
    }
    flipHorizontal() {
        this.transform = {
            ...this.transform,
            flipH: !this.transform.flipH
        };
    }
    flipVertical() {
        this.transform = {
            ...this.transform,
            flipV: !this.transform.flipV
        };
    }
    resetImage() {
        this.scale = 1;
        this.rotation = 0;
        this.canvasRotation = 0;
        this.transform = {
            translateUnit: 'px'
        };
    }
    zoomOut() {
        this.scale -= .1;
        this.transform = {
            ...this.transform,
            scale: this.scale
        };
    }
    zoomIn() {
        this.scale += .1;
        this.transform = {
            ...this.transform,
            scale: this.scale
        };
    }
    toggleContainWithinAspectRatio() {
        this.containWithinAspectRatio = !this.containWithinAspectRatio;
    }
    updateRotation() {
        this.transform = {
            ...this.transform,
            rotate: this.rotation
        };
    }
    toggleAspectRatio() {
        this.aspectRatio = this.aspectRatio === 4 / 3 ? 16 / 5 : 4 / 3;
    }
    applyCropedImage() {
        // console.log("Cropped Image: ", this.croppedImage )
        this.dialogRef.close(this.croppedImage.changingThisBreaksApplicationSecurity);
    }
    cancelCropedImage() {
        // console.log("cancel Croped Image" )
        this.dialogRef.close();
    }
    static ɵfac = function ImageCropModalComponent_Factory(t) { return new (t || ImageCropModalComponent)(i0.ɵɵdirectiveInject(i7$1.MatDialogRef), i0.ɵɵdirectiveInject(i1.DomSanitizer), i0.ɵɵdirectiveInject(MAT_DIALOG_DATA)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ImageCropModalComponent, selectors: [["lib-image-crop-modal"]], standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 12, vars: 24, consts: [[1, "cropper-container"], [1, "float-item", "cropper-wrapper"], ["imageAltText", "Alternative image text", "backgroundColor", "white", "output", "base64", 3, "transformChange", "imageCropped", "imageLoaded", "cropperReady", "loadImageFailed", "imageChangedEvent", "imageURL", "maintainAspectRatio", "cropperStaticWidth", "cropperStaticHeight", "cropperMinWidth", "cropperMinHeight", "onlyScaleDown", "roundCropper", "containWithinAspectRatio", "aspectRatio", "canvasRotation", "transform", "alignImage", "allowMoveImage", "hidden", "format"], [1, "float-item"], [3, "src"], [1, "pp-action-btn", "btn-container"], [1, "btn", "btn-primary", 3, "click"], ["class", "btn btn-outline-primary", 3, "click", 4, "ngIf"], [1, "btn", "btn-outline-primary", 3, "click"]], template: function ImageCropModalComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "image-cropper", 2);
            i0.ɵɵtwoWayListener("transformChange", function ImageCropModalComponent_Template_image_cropper_transformChange_2_listener($event) { i0.ɵɵtwoWayBindingSet(ctx.transform, $event) || (ctx.transform = $event); return $event; });
            i0.ɵɵlistener("imageCropped", function ImageCropModalComponent_Template_image_cropper_imageCropped_2_listener($event) { return ctx.imageCropped($event); })("imageLoaded", function ImageCropModalComponent_Template_image_cropper_imageLoaded_2_listener() { return ctx.imageLoaded(); })("cropperReady", function ImageCropModalComponent_Template_image_cropper_cropperReady_2_listener($event) { return ctx.cropperReady($event); })("loadImageFailed", function ImageCropModalComponent_Template_image_cropper_loadImageFailed_2_listener() { return ctx.loadImageFailed(); });
            i0.ɵɵelementEnd()();
            i0.ɵɵelementStart(3, "div", 3);
            i0.ɵɵelement(4, "img", 4);
            i0.ɵɵelementEnd()();
            i0.ɵɵelementStart(5, "div", 5)(6, "button", 6);
            i0.ɵɵlistener("click", function ImageCropModalComponent_Template_button_click_6_listener() { return ctx.cancelCropedImage(); });
            i0.ɵɵtext(7, "Cancel");
            i0.ɵɵelementEnd();
            i0.ɵɵtemplate(8, ImageCropModalComponent_button_8_Template, 2, 0, "button", 7)(9, ImageCropModalComponent_button_9_Template, 2, 0, "button", 7);
            i0.ɵɵelementStart(10, "button", 6);
            i0.ɵɵlistener("click", function ImageCropModalComponent_Template_button_click_10_listener() { return ctx.applyCropedImage(); });
            i0.ɵɵtext(11, "Apply");
            i0.ɵɵelementEnd()();
        } if (rf & 2) {
            i0.ɵɵadvance(2);
            i0.ɵɵstyleProp("display", ctx.showCropper ? null : "none");
            i0.ɵɵproperty("imageChangedEvent", ctx.imageChangedEvent)("imageURL", ctx.imageURL)("maintainAspectRatio", ctx.maintainAspectRatio)("cropperStaticWidth", ctx.cropperStaticWidth)("cropperStaticHeight", ctx.cropperStaticHeight)("cropperMinWidth", ctx.cropperMinWidth)("cropperMinHeight", ctx.cropperMinHeight)("onlyScaleDown", ctx.onlyScaleDown)("roundCropper", ctx.roundCropper)("containWithinAspectRatio", ctx.containWithinAspectRatio)("aspectRatio", ctx.aspectRatio)("canvasRotation", ctx.canvasRotation);
            i0.ɵɵtwoWayProperty("transform", ctx.transform);
            i0.ɵɵproperty("alignImage", "center")("allowMoveImage", ctx.allowMoveImage)("hidden", ctx.hidden)("format", ctx.ppFormat);
            i0.ɵɵadvance(2);
            i0.ɵɵstyleProp("border", ctx.croppedImage ? "1px solid black" : "none");
            i0.ɵɵproperty("src", ctx.croppedImage, i0.ɵɵsanitizeUrl);
            i0.ɵɵadvance(4);
            i0.ɵɵproperty("ngIf", ctx.allowZoomImage);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngIf", ctx.allowZoomImage);
        } }, dependencies: [MatFormFieldModule, MatInputModule, CommonModule, i13.NgIf, MatDialogModule, NgxImageZoomModule, FormsModule, ImageCropperComponent], styles: [".cropper-container[_ngcontent-%COMP%]{width:750px;display:flex;flex-wrap:nowrap;padding:25px}.float-item[_ngcontent-%COMP%]{width:50%;text-align:right}.float-item[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{height:295px;width:295px}.btn-container[_ngcontent-%COMP%]{text-align:center;padding:15px}.btn-container[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin:5px}"] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ImageCropModalComponent, [{
        type: Component,
        args: [{ selector: 'lib-image-crop-modal', standalone: true, imports: [NgSwitch, MatFormFieldModule, MatInputModule, CommonModule, MatDialogModule, NgxImageZoomModule, DomSanitizePipe, FormsModule, ImageCropperComponent], schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA], template: "<div class=\"cropper-container\">\r\n    <div class=\"float-item cropper-wrapper\">\r\n        <image-cropper\r\n            [imageChangedEvent]=\"imageChangedEvent\"\r\n            [imageURL]=\"imageURL\"\r\n    \r\n            [maintainAspectRatio]=\"maintainAspectRatio\"\r\n            [cropperStaticWidth]=\"cropperStaticWidth\"\r\n            [cropperStaticHeight]=\"cropperStaticHeight\"\r\n            [cropperMinWidth]=\"cropperMinWidth\"\r\n            [cropperMinHeight]=\"cropperMinHeight\"\r\n            [onlyScaleDown]=\"onlyScaleDown\"\r\n            [roundCropper]=\"roundCropper\"\r\n    \r\n            [containWithinAspectRatio]=\"containWithinAspectRatio\"\r\n            [aspectRatio]=\"aspectRatio\"\r\n            [canvasRotation]=\"canvasRotation\"\r\n            [(transform)]=\"transform\"\r\n            [alignImage]=\"'center'\"\r\n            [style.display]=\"showCropper ? null : 'none'\"\r\n            [allowMoveImage]=\"allowMoveImage\"\r\n            [hidden]=\"hidden\"\r\n            imageAltText=\"Alternative image text\"\r\n            backgroundColor=\"white\"\r\n            output=\"base64\"\r\n            [format]=\"ppFormat\"\r\n            (imageCropped)=\"imageCropped($event)\"\r\n            (imageLoaded)=\"imageLoaded()\"\r\n            (cropperReady)=\"cropperReady($event)\"\r\n            (loadImageFailed)=\"loadImageFailed()\"\r\n        ></image-cropper>\r\n    </div>\r\n    <div class=\"float-item\">\r\n        <img [src]=\"croppedImage\" [style.border]=\"croppedImage ? '1px solid black' : 'none'\" />\r\n    </div>\r\n</div>\r\n<div class=\"pp-action-btn btn-container\">\r\n    <button class=\"btn btn-primary\" (click)=\"cancelCropedImage()\">Cancel</button>\r\n    <button *ngIf=\"allowZoomImage\" class=\"btn btn-outline-primary\" (click)=\"zoomOut()\">Zoom Out</button> \r\n    <button *ngIf=\"allowZoomImage\" class=\"btn btn-outline-primary\" (click)=\"zoomIn()\">Zoom In</button>\r\n    <button class=\"btn btn-primary\" (click)=\"applyCropedImage()\">Apply</button>\r\n</div>\r\n", styles: [".cropper-container{width:750px;display:flex;flex-wrap:nowrap;padding:25px}.float-item{width:50%;text-align:right}.float-item img{height:295px;width:295px}.btn-container{text-align:center;padding:15px}.btn-container button{margin:5px}\n"] }]
    }], () => [{ type: i7$1.MatDialogRef }, { type: i1.DomSanitizer }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }], null); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(ImageCropModalComponent, { className: "ImageCropModalComponent", filePath: "lib\\field-components\\cee-profile-image\\image-crop-modal.component.ts", lineNumber: 21 }); })();

// import { TooltipModule } from './directives/tooltip/tooltip.module';
// @Injectable({providedIn: 'root'})
// export class SocketOne extends Socket {
//   constructor() {
//       super({
//         url: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 0 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][0]['dataSocketUrl'] : '',
//         options: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 0 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][0]['dataSocketOptions'] : { transports: ['websocket'], path:'/' }
//       });
//   }
// }
// @Injectable({providedIn: 'root'})
// export class SocketTwo extends Socket {
//   constructor() {
//       super({
//         url: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 1 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][1]['dataSocketUrl'] : '',
//         options: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 1 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][1]['dataSocketOptions'] : { transports: ['websocket'], path:'/' }
//       });
//   }
// }
// @Injectable({providedIn: 'root'})
// export class SocketThree extends Socket {
//   constructor() {
//       super({
//         url: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 2 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][2]['dataSocketUrl'] : '',
//         options: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 2 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][2]['dataSocketOptions'] : { transports: ['websocket'], path:'/' }
//       });
//   }
// }
// @Injectable({providedIn: 'root'})
// export class SocketFour extends Socket {
//   constructor() {
//       super({
//         url: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 3 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][3]['dataSocketUrl'] : '',
//         options: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 3 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][3]['dataSocketOptions'] : { transports: ['websocket'], path:'/' }
//       });
//   }
// }
// @Injectable({providedIn: 'root'})
// export class SocketFive extends Socket {
//   constructor() {
//       super({
//         url: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 4 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][4]['dataSocketUrl'] : '',
//         options: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 4 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][4]['dataSocketOptions'] : { transports: ['websocket'], path:'/' }
//       });
//   }
// }
const config = {
    url: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 0 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][0]['dataSocketUrl'] : '',
    options: localStorage.getItem('socket_settings') && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'] && JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'].length > 0 ? JSON.parse(localStorage.getItem('socket_settings'))['dataSocketDetails'][0]['dataSocketOptions'] : { transports: ['websocket'], path: '/', autoConnect: false }
};
class NgCeeCoreModule {
    static ɵfac = function NgCeeCoreModule_Factory(t) { return new (t || NgCeeCoreModule)(); };
    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: NgCeeCoreModule });
    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [
            Title,
            WfeStepLoaderService,
            UserDataHandlerService,
            CeeApiService,
            CeeLogHandlerService,
            DynamicComponentHandlerService,
            DatePipe,
            ThemeService,
            NgxDaterangepickerLocaleService,
            NgxBarcodeScannerService,
            WebworkerService,
            { provide: 'googleMapsApiKey', useValue: 'AIzaSyD9HeCFeg5EUx5CKvXGTdwJANhESMVTIWI' },
            { provide: NgChartsConfiguration, useValue: { generateColors: false } },
            provideAnimations(),
            provideToastr(), // Toastr providers
        ], imports: [FormsModule,
            ReactiveFormsModule,
            CommonModule,
            HttpClientModule,
            BrowserAnimationsModule,
            NgIdleKeepaliveModule.forRoot(),
            UiSwitchModule,
            MaterialComponentModule,
            MatChipsModule,
            MatIconModule,
            MatProgressBarModule,
            NgbModule,
            NgbTimepickerModule,
            // AgmCoreModule.forRoot({
            //     apiKey: 'YOUR_GOOGLE_MAPS_API_KEY'
            // }),
            NgChartsModule.forRoot(),
            Ng2GoogleChartsModule,
            NgxMaterialTimepickerModule,
            SocketIoModule.forRoot(config),
            OAuthModule.forRoot(),
            WebcamModule,
            NgxBarcodeScannerModule,
            NgxImageZoomModule,
            ToastrModule.forRoot({
                enableHtml: true,
                easing: 'ease-in-out-elastic',
                easeTime: 300
            }),
            CdkMenuModule,
            NgxMatTimepickerModule,
            NgxMatNativeDateModule,
            NgxMatDatetimePickerModule,
            YouTubePlayerModule,
            MatInputModule,
            MatFormFieldModule,
            BrowserModule,
            GoogleMapsModule,
            NgxDaterangepickerBootstrapModule.forRoot(),
            QuillModule.forRoot({
                modules: {
                    toolbar: [
                        ['bold', 'italic', 'underline', 'strike'],
                        ['blockquote', 'code-block'],
                        [{ 'header': 1 }, { 'header': 2 }],
                        [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                        [{ 'script': 'sub' }, { 'script': 'super' }],
                        [{ 'indent': '-1' }, { 'indent': '+1' }],
                        [{ 'direction': 'rtl' }],
                        [{ 'size': ['small', false, 'large', 'huge'] }],
                        [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                        [{ 'color': [] }, { 'background': [] }],
                        [{ 'font': [] }],
                        [{ 'align': [] }],
                        ['clean'],
                        ['link', 'image'] // CRITICAL: No video in global config
                    ]
                }
            })
            // TooltipModule
        ] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NgCeeCoreModule, [{
        type: NgModule,
        args: [{
                declarations: [
                // StepRendererComponent,
                // CeeButtonComponent,
                // CeeCheckboxComponent,
                // CeeDateComponent,
                // CeeImageComponent,
                // CeeLabelComponent,
                // CeeTagComponent,
                // CeePickerComponent,
                // CeeRadioComponent,
                // CeeSignatureComponent,
                // CeeSliderComponent,
                // CeeTextfieldComponent,
                // CeeCaptchaComponent,
                // CeeAutoCompleteComponent,
                // CeeTextareaComponent,
                // CeeToggleButtonComponent,
                // CeeSwitchComponent,
                // SectionRendererComponent,
                // BlockRendererComponent,
                // CeeLinkComponent,
                // CeeVideoComponent,
                // CeeTimePickerComponent,
                // CeePhoneNumberComponent,
                // DynamicRendererComponent,
                // DynamicFormComponent,
                // ViewRendererComponent,
                // CeeTableComponent,
                // BreadcrumbRendererComponent,
                // RepeatableBlockRendererComponent,
                // // LoadingRendererComponent,
                // ListRendererComponent,
                // TreeRendererComponent,
                // TabRendererComponent,
                // AccordionRendererComponent,
                // ModalRendererComponent,
                // SnackbarRendererComponent,
                // CeeMenuComponent,
                // CeeMenucontextComponent,
                // CeeMapComponent,
                // CeeChartComponent,
                // AlertModalComponent,
                // GenericBlockRendererComponent,
                // BreadcrumbCellRendererComponent,
                // CeeCarouselComponent,
                // ProgressBarRendererComponent,
                // CeeAttachmentsComponent,
                // CeeTimeSlotsComponent,
                // CeeCalendarComponent,
                // CeeNumberComponent,
                // CustomTooltipDirective,
                // CeeTickerComponent,
                // CeeCameraComponent,
                // ShowPasswordDirective,
                // ResizeColumnDirective,
                // SortableHeaderDirective
                ],
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    HttpClientModule,
                    BrowserAnimationsModule,
                    NgIdleKeepaliveModule.forRoot(),
                    UiSwitchModule,
                    MaterialComponentModule,
                    MatChipsModule,
                    MatIconModule,
                    MatProgressBarModule,
                    NgbModule,
                    NgbTimepickerModule,
                    // AgmCoreModule.forRoot({
                    //     apiKey: 'YOUR_GOOGLE_MAPS_API_KEY'
                    // }),
                    NgChartsModule.forRoot(),
                    Ng2GoogleChartsModule,
                    NgxMaterialTimepickerModule,
                    SocketIoModule.forRoot(config),
                    OAuthModule.forRoot(),
                    WebcamModule,
                    NgxBarcodeScannerModule,
                    NgxImageZoomModule,
                    ToastrModule.forRoot({
                        enableHtml: true,
                        easing: 'ease-in-out-elastic',
                        easeTime: 300
                    }),
                    CdkMenuModule,
                    NgxMatTimepickerModule,
                    NgxMatNativeDateModule,
                    NgxMatDatetimePickerModule,
                    YouTubePlayerModule,
                    MatInputModule,
                    MatFormFieldModule,
                    BrowserModule,
                    GoogleMapsModule,
                    NgxDaterangepickerBootstrapModule.forRoot(),
                    QuillModule.forRoot({
                        modules: {
                            toolbar: [
                                ['bold', 'italic', 'underline', 'strike'],
                                ['blockquote', 'code-block'],
                                [{ 'header': 1 }, { 'header': 2 }],
                                [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                [{ 'script': 'sub' }, { 'script': 'super' }],
                                [{ 'indent': '-1' }, { 'indent': '+1' }],
                                [{ 'direction': 'rtl' }],
                                [{ 'size': ['small', false, 'large', 'huge'] }],
                                [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                                [{ 'color': [] }, { 'background': [] }],
                                [{ 'font': [] }],
                                [{ 'align': [] }],
                                ['clean'],
                                ['link', 'image'] // CRITICAL: No video in global config
                            ]
                        }
                    })
                    // TooltipModule
                ],
                providers: [
                    Title,
                    WfeStepLoaderService,
                    UserDataHandlerService,
                    CeeApiService,
                    CeeLogHandlerService,
                    DynamicComponentHandlerService,
                    DatePipe,
                    ThemeService,
                    NgxDaterangepickerLocaleService,
                    NgxBarcodeScannerService,
                    WebworkerService,
                    { provide: 'googleMapsApiKey', useValue: 'AIzaSyD9HeCFeg5EUx5CKvXGTdwJANhESMVTIWI' },
                    { provide: NgChartsConfiguration, useValue: { generateColors: false } },
                    provideAnimations(),
                    provideToastr(), // Toastr providers
                ],
                exports: [
                // StepRendererComponent,
                // DynamicRendererComponent,
                // ModalRendererComponent,
                // SnackbarRendererComponent,
                // AlertModalComponent,
                // BlockRendererComponent
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgCeeCoreModule, { imports: [FormsModule,
        ReactiveFormsModule,
        CommonModule,
        HttpClientModule,
        BrowserAnimationsModule, i9$1.NgIdleKeepaliveModule, UiSwitchModule,
        MaterialComponentModule,
        MatChipsModule,
        MatIconModule,
        MatProgressBarModule,
        NgbModule,
        NgbTimepickerModule, i2.NgChartsModule, Ng2GoogleChartsModule,
        NgxMaterialTimepickerModule, i1$1.SocketIoModule, i4.OAuthModule, WebcamModule,
        NgxBarcodeScannerModule,
        NgxImageZoomModule, i7.ToastrModule, CdkMenuModule,
        NgxMatTimepickerModule,
        NgxMatNativeDateModule,
        NgxMatDatetimePickerModule,
        YouTubePlayerModule,
        MatInputModule,
        MatFormFieldModule,
        BrowserModule,
        GoogleMapsModule, i6.NgxDaterangepickerBootstrapModule, i7$2.QuillModule] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NgCeeCoreModule as $, APIKeyUtil as A, BlockRendererComponent as B, ConditionalUtil as C, DynamicLabelUtil as D, EmptyUtil as E, FlatUnflat as F, GenerateFieldRow as G, SectionRendererComponent as H, ImageCropModalComponent as I, Event$1 as J, Log as K, LoaderInterceptorService as L, ESBRequestBodyUtil as M, NgCEEStoreService as N, SessionTimeoutUtil as O, ProgressBarRendererComponent as P, WFEConditionalExecuter as Q, RepeatableBlockData as R, SetAPICallbackData as S, TooltipModule as T, UserDataHandlerService as U, ViewRendererComponent as V, WFEEventListHandler as W, ConditionalValidator as X, SidemenuUtil as Y, PDFFormProcessor as Z, BorderlessPDFGeneratorService as _, CommonUtil as a, ModalRendererComponent as a0, ContentProjectionWrapperComponent as a1, SnackbarRendererComponent as a2, DrawerComponent as a3, ceeButton_component as a4, Constant as b, SharedEventsServiceService as c, CEEInternalEmitterService as d, AppDataService as e, ApiDataService as f, WfeStepLoaderService as g, CeeApiService as h, AlertModalComponent as i, BaseView as j, WfeEncryptionUtil as k, SessionKeyUtil as l, TooltipDirective as m, AccordionService as n, UndoRedo as o, FileUploadService as p, AssociatedMapUtil as q, WebworkerService as r, DynamicRendererComponent as s, StepRendererComponent as t, BearerTokenServiceService as u, CeeInitServiceService as v, CeeLogHandlerService as w, DynamicComponentHandlerService as x, LoaderService as y, EventResponseHandlerService as z };
//# sourceMappingURL=ng-cee-core-ng-cee-core-B-GWW1tg.mjs.map
